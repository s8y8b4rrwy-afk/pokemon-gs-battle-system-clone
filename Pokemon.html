<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G/S Battle Simulator: Final Polish v2</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --bg-color: #f8f8f8;
            --screen-bg: #ffffff;
            --ui-border: #202020;
            --hp-green: #48c050;
            --hp-yellow: #d8b030;
            --hp-red: #c83828;
            --xp-blue: #40a8c0;
            --gs-black: #181818;
            --gs-blue: #283048;
        }

        body {
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'Press Start 2P', cursive;
            user-select: none;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
        }

        #game-boy {
            width: 320px;
            height: 288px;
            background-color: var(--screen-bg);
            border: 4px solid #888;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            image-rendering: pixelated;
        }

        /* --- FIX: HIGHLIGHT PRIORITY --- */
        /* These ensure the cursor override 'gray' or 'red' buttons when selected */
        .move-btn.cancel.focused {
            background: #202020 !important;
            color: white !important;
            border-color: #000 !important;
        }

        .confirm-btn.secondary.focused {
            background: #000 !important;
            color: white !important;
        }

        .confirm-btn.danger.focused {
            background: #000 !important;
            color: white !important;
        }

        /* Ensure the Cancel button turns black when selected so it's visible */
        .pack-item.cancel-btn.focused {
            background: #202020 !important;
            color: white !important;
            border-color: #000 !important;
        }

        /* --- LOADING TEXT ANIMATION --- */
        .blink-text {
            animation: blinker 0.8s steps(2) infinite;
        }

        @keyframes blinker {
            50% {
                opacity: 0;
            }
        }

        /* --- LCD FILTER --- */
        #lcd-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
            background:
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%),
                linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 2px 100%;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transition: opacity 0.5s;
        }

        #lcd-overlay.active {
            opacity: 1;
        }

        /* --- START SCREEN --- */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--gs-black);
            color: white;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            gap: 20px;
        }

        .start-title {
            color: #d8b030;
            font-size: 16px;
            line-height: 24px;
            text-shadow: 2px 2px 0 #000;
            margin-bottom: 20px;
        }

        .start-btn {
            background: white;
            color: black;
            border: 2px solid #888;
            padding: 10px;
            font-size: 8px;
            font-family: 'Press Start 2P';
            cursor: pointer;
        }

        .start-btn:hover {
            background: #eee;
        }

        .toggle-box {
            font-size: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .checkbox {
            width: 10px;
            height: 10px;
            border: 2px solid white;
            display: inline-block;
            position: relative;
        }

        .checkbox.checked::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 6px;
            height: 6px;
            background: #d8b030;
        }

        /* --- NAME ENTRY SCREEN --- */
        #name-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--gs-blue);
            color: white;
            z-index: 950;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 40px;
        }

        #name-input {
            background: white;
            color: black;
            border: 2px solid #888;
            padding: 5px;
            font-family: 'Press Start 2P';
            font-size: 12px;
            text-transform: uppercase;
            width: 150px;
            text-align: center;
            outline: none;
            margin-bottom: 20px;
        }

        /* --- CONTINUE SCREEN --- */
        #continue-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--gs-blue);
            color: white;
            z-index: 900;
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
        }

        .cont-menu-box {
            background: #fff;
            color: black;
            border: 4px solid #202020;
            border-radius: 4px;
            margin-bottom: 10px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .cont-opt {
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
        }

        .cont-opt::before {
            content: ' ';
            width: 10px;
            display: inline-block;
        }

        .cont-opt.focused::before {
            content: '▶';
        }

        .save-info-box {
            background: var(--gs-blue);
            border: 2px solid white;
            border-radius: 4px;
            padding: 10px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .save-row {
            font-size: 8px;
            display: flex;
            justify-content: space-between;
        }

        .party-preview-row {
            display: flex;
            gap: 4px;
            margin-top: 10px;
            background: rgba(0, 0, 0, 0.3);
            padding: 4px;
            border-radius: 4px;
            overflow-x: auto;
        }

        .mini-icon {
            width: 32px;
            height: 24px;
            image-rendering: pixelated;
            cursor: pointer;
        }

        .mini-icon.fainted {
            filter: grayscale(100%) brightness(0.7);
            opacity: 0.8;
        }

        .mini-icon:hover {
            transform: translateY(-2px);
        }

        /* --- UTILS --- */
        .hidden {
            display: none !important;
        }

        .btn-bar {
            background: #ddd;
            text-align: center;
            padding: 6px;
            font-size: 8px;
            cursor: pointer;
            border-top: 2px solid #999;
            margin-top: auto;
        }

        .btn-bar:hover,
        .btn-bar.focused {
            background: #ccc;
        }

        /* --- FOCUS / HOVER STATES --- */
        .menu-item:hover,
        .menu-item.focused {
            background-color: #eee;
        }

        .menu-item:hover::before,
        .menu-item.focused::before {
            opacity: 1;
        }

        .move-btn:hover,
        .move-btn.focused {
            background: #e0e0e0;
            border-color: #202020;
        }

        .party-slot:hover,
        .party-slot.focused {
            background: #eee;
            border-color: #000;
        }

        .pack-item:hover,
        .pack-item.focused {
            background: #eee;
            border: 1px solid #ccc;
        }

        .ctx-btn:hover,
        .ctx-btn.focused {
            background: #eee;
        }

        .confirm-btn:hover,
        .confirm-btn.focused {
            background: #000;
        }

        /* --- SELECTION SCREEN --- */
        #selection-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #202020;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        .sel-preview-box {
            height: 110px;
            margin: 10px 10px 0 10px;
            background: #fff;
            border: 4px solid #444;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .preview-sprite {
            width: 96px;
            height: 96px;
            image-rendering: pixelated;
        }

        .shiny-mark {
            position: absolute;
            top: 5px;
            right: 5px;
            color: gold;
            font-size: 12px;
            display: none;
        }

        .lab-table-area {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #202020;
            position: relative;
        }

        .table-graphic {
            width: 200px;
            height: 60px;
            background: #fff;
            border: 2px solid #888;
            display: flex;
            justify-content: space-around;
            align-items: center;
            border-radius: 4px;
            position: relative;
        }

        .pokeball-select {
            width: 20px;
            height: 20px;
            background: radial-gradient(circle at 35% 35%, white 10%, red 11%, red 50%, black 51%, black 60%, white 61%);
            border-radius: 50%;
            border: 1px solid black;
            position: relative;
            cursor: pointer;
            box-shadow: 0 2px 2px rgba(0, 0, 0, 0.4);
        }

        .pokeball-select.focused {
            transform: scale(1.1);
            box-shadow: 0 0 5px gold;
        }

        .sel-cursor {
            position: absolute;
            top: -20px;
            left: 0;
            width: 20px;
            height: 20px;
            transition: left 0.1s steps(1);
            pointer-events: none;
        }

        .sel-cursor::after {
            content: "▼";
            color: #d8b030;
            font-size: 12px;
            position: absolute;
            left: 4px;
            animation: bounceCursor 0.6s infinite;
        }

        @keyframes bounceCursor {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-3px);
            }
        }

        .sel-desc-box {
            height: 60px;
            background: white;
            border-top: 4px solid #888;
            padding: 8px;
            font-size: 8px;
            line-height: 12px;
            text-transform: uppercase;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        /* --- SUMMARY SCREEN --- */
        #summary-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            z-index: 950;
            display: flex;
            flex-direction: column;
            padding: 8px;
            box-sizing: border-box;
        }

        .sum-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #444;
            padding-bottom: 4px;
            margin-bottom: 4px;
        }

        .sum-body {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .sum-sprite {
            width: 96px;
            height: 96px;
            border: 1px solid #ccc;
            background: #f8f8f8;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sum-sprite img {
            width: 96px;
            height: 96px;
            image-rendering: pixelated;
        }

        .sum-data {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 2px;
            font-size: 8px;
            justify-content: center;
        }

        .sum-stat-bar {
            width: 100%;
            height: 6px;
            background: #ddd;
            border: 1px solid #000;
            border-radius: 2px;
            margin-bottom: 2px;
            position: relative;
        }

        .sum-stat-fill {
            height: 100%;
            display: block;
            transition: width 0.3s;
        }

        .sum-divider {
            width: 100%;
            height: 2px;
            background: #444;
            margin: 4px 0;
        }

        .sum-moves {
            border-top: 2px solid #444;
            padding-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .move-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px dotted #ccc;
            padding-bottom: 2px;
        }

        .move-name {
            color: #000;
            text-transform: uppercase;
            font-size: 6px;
        }

        .move-info-grp {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .move-pwr {
            font-size: 6px;
            color: #444;
        }

        .move-type {
            color: #666;
            text-transform: uppercase;
            font-size: 6px;
            background: #eee;
            padding: 1px 3px;
            border-radius: 2px;
        }

        .type-tag {
            background: #333;
            color: white;
            padding: 2px 4px;
            display: inline-block;
            margin-right: 4px;
            border-radius: 2px;
        }

        .sum-buttons {
            margin-top: auto;
            display: flex;
            gap: 5px;
        }

        .confirm-btn {
            flex: 1;
            background: #444;
            color: white;
            border: none;
            padding: 8px;
            font-family: 'Press Start 2P';
            font-size: 7px;
            cursor: pointer;
            text-align: center;
        }

        .confirm-btn:disabled {
            background: #bbb;
            color: #eee;
            pointer-events: none;
        }

        .confirm-btn.secondary {
            background: #888;
        }

        .confirm-btn.nav-btn {
            flex: 0 0 20px;
        }

        .confirm-btn.danger {
            background: #c83828;
        }

        /* --- PARTY SCREEN --- */
        #party-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #f8f8f8;
            z-index: 300;
            display: flex;
            flex-direction: column;
        }

        .party-header {
            background: #282828;
            color: white;
            padding: 8px;
            font-size: 10px;
            border-bottom: 2px solid #a0a0a0;
        }

        .party-list {
            flex-grow: 1;
            overflow-y: auto;
            padding: 4px;
        }

        .party-slot {
            display: flex;
            align-items: center;
            background: white;
            border: 2px solid #ccc;
            margin-bottom: 4px;
            padding: 2px;
            cursor: pointer;
            height: 40px;
            position: relative;
        }

        .party-slot.fainted {
            opacity: 0.6;
            background: #ddd;
        }

        .party-slot.fainted .slot-icon {
            filter: grayscale(100%);
        }

        .party-slot.active-mon {
            border: 2px solid #d8b030;
            background: #fffbe0;
        }

        .party-slot.new-catch {
            border: 2px dashed #40a8c0;
            background: #e0f8ff;
        }

        .slot-icon {
            width: 40px;
            height: 30px;
            image-rendering: pixelated;
            margin-right: 5px;
        }

        .party-slot:hover .slot-icon,
        .party-slot.focused .slot-icon {
            animation: jump 0.3s infinite;
        }

        .slot-info {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            font-size: 8px;
        }

        .slot-row {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 2px;
        }

        .mini-hp-bg {
            width: 60px;
            height: 4px;
            background: #ccc;
            border: 1px solid #000;
            border-radius: 2px;
        }

        .mini-hp-fill {
            height: 100%;
            background: var(--hp-green);
            width: 100%;
        }

        #party-context {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 90px;
            background: white;
            border: 2px solid #202020;
            z-index: 350;
            box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
        }

        .ctx-btn {
            padding: 10px;
            font-size: 8px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            background: white;
        }

        .ctx-btn.warn {
            color: #c83828;
            font-weight: bold;
        }

        /* --- PACK SCREEN --- */
        #pack-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #f8f8f8;
            z-index: 250;
            display: flex;
            flex-direction: column;
        }

        .pack-header {
            background: #282828;
            color: white;
            padding: 8px;
            font-size: 10px;
            border-bottom: 2px solid #a0a0a0;
        }

        .pack-body {
            display: flex;
            flex-grow: 1;
            height: 150px;
        }

        .pack-graphic {
            width: 40%;
            background: #e0e0e0;
            border-right: 2px solid #a0a0a0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .bag-icon {
            width: 64px;
            height: 64px;
            image-rendering: pixelated;
            background-image: url('https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/backpack.png');
            background-size: contain;
            background-repeat: no-repeat;
            transition: background-image 0.1s;
        }

        .pack-list {
            width: 60%;
            background: white;
            padding: 6px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            overflow-y: auto;
            max-height: 210px;
        }

        .pack-list::-webkit-scrollbar {
            width: 4px;
        }

        .pack-list::-webkit-scrollbar-thumb {
            background: #888;
        }

        .pack-item {
            font-size: 8px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            padding: 6px;
            border: 1px solid transparent;
            flex-shrink: 0;
        }

        .pack-item.cancel-btn {
            justify-content: center;
            font-weight: bold;
            background: #eee;
            border: 1px solid #ccc;
        }

        .pack-item.disabled {
            color: #aaa;
            pointer-events: none;
        }

        .pack-desc-box {
            height: 60px;
            background: #282828;
            color: white;
            border-top: 4px solid #a0a0a0;
            padding: 8px;
            font-size: 8px;
            line-height: 12px;
            margin-top: auto;
        }

        /* --- BATTLE SCENE --- */
        .scene {
            height: 200px;
            position: relative;
            background: linear-gradient(to bottom, #f8f8f8 0%, #e0e0e0 100%);
            transform-origin: center center;
        }

        /* UPDATED: Added transform and filter to transition for smooth shrinking/growing */
        .sprite {
            position: absolute;
            image-rendering: pixelated;
            z-index: 5;
            transition: opacity 0.2s, transform 0.4s, filter 0.4s;
        }

        /* REVERTED: Original positioning */
        #enemy-sprite {
            width: 112px;
            height: 112px;
            top: 5px;
            right: 20px;
        }

        /* Kept 'bottom center' for player as requested previously */
        #player-sprite {
            width: 224px;
            height: 224px;
            bottom: -40px;
            left: -30px;
            transform-origin: bottom center;
        }


        /* --- HUD SYSTEM --- */
        .hud {
            position: absolute;
            background: white;
            border: 2px solid var(--ui-border);
            border-radius: 2px;
            padding: 4px;
            width: 135px;
            z-index: 10;
            box-shadow: 2px 2px 0px rgba(0, 0, 0, 0.2);
            transition: transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        /* Off-screen positions */
        #enemy-hud {
            top: 10px;
            left: 10px;
            transform: translateX(-250px);
        }

        #player-hud {
            bottom: 25px;
            right: 10px;
            transform: translateX(250px);
        }

        /* Slide-in Active State */
        #enemy-hud.hud-active,
        #player-hud.hud-active {
            transform: translateX(0);
        }

        /* Substitute Back Sprite (Player side) */
        .sub-back {
            transform: scaleX(-1);
            /* Flips the sprite */
        }

        /* Animation for Substitute Fading/Breaking */
        @keyframes subBreak {
            0% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.5;
                transform: scale(1.2);
                filter: grayscale(1);
            }

            100% {
                opacity: 0;
                transform: scale(0);
            }
        }

        .anim-break {
            animation: subBreak 0.5s ease-out forwards;
        }

        /* Level Up Flash Animation */
        @keyframes flashHudBlue {
            0% {
                background-color: white;
                box-shadow: 0 0 0 #40a8c0;
            }

            50% {
                background-color: #e0f8ff;
                box-shadow: 0 0 15px #40a8c0;
                border-color: #40a8c0;
            }

            100% {
                background-color: white;
                box-shadow: 0 0 0 #40a8c0;
            }
        }

        .hud-flash-blue {
            animation: flashHudBlue 0.6s ease-in-out;
        }

        /* NAME CSS: Wraps text inside box, icon stays at the end */
        .name {
            font-size: 10px;
            margin-bottom: 4px;
            text-transform: uppercase;
            display: block;
            white-space: normal;
            line-height: 14px;
            /* Increased from 12px to prevent clipping */
            overflow: visible;
            /* Ensures the bottom of the icon isn't cut off */
        }

        .level {
            font-size: 10px;
            float: right;
        }

        .hp-box {
            display: flex;
            align-items: center;
            font-size: 8px;
            font-weight: bold;
        }

        .hp-bar-bg {
            width: 90px;
            height: 6px;
            background: #f0f0f0;
            border: 1px solid #000;
            border-radius: 2px;
            position: relative;
        }

        .hp-fill {
            height: 100%;
            background-color: var(--hp-green);
            width: 100%;
            transition: width 0.5s ease;
            border-right: 1px solid black;
        }

        #player-hp-text {
            font-size: 10px;
            text-align: right;
            margin-top: 4px;
            letter-spacing: 1px;
        }

        .exp-box {
            display: flex;
            align-items: center;
            margin-top: 2px;
            justify-content: flex-end;
        }

        .exp-bar-bg {
            width: 80px;
            height: 2px;
            background: #ccc;
            border: 1px solid #444;
            border-radius: 2px;
            margin-left: 4px;
        }

        .exp-fill {
            height: 100%;
            width: 0%;
            background: var(--xp-blue);
            transition: width 0.5s ease;
        }

        .aggro-icon {
            font-size: 10px;
            margin-left: 4px;
            font-weight: bold;
            text-shadow: 1px 1px 0 #fff;
            flex-shrink: 0;
            display: inline-block;
        }

        .aggro-1 {
            color: #d8b030;
        }

        .aggro-2 {
            color: #c86028;
        }

        .aggro-3 {
            color: #c83828;
            animation: pulseAggro 0.5s infinite;
        }

        @keyframes pulseAggro {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.3);
            }

            100% {
                transform: scale(1);
            }
        }

        #streak-box {
            position: absolute;
            top: 8px;
            right: 8px;
            background: white;
            border: 2px solid #202020;
            padding: 4px 6px;
            font-size: 8px;
            z-index: 50;
            box-shadow: 2px 2px 0px rgba(0, 0, 0, 0.2);
            color: black;
        }

        .smoke-particle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: white;
            border: 0px solid #000;
            border-radius: 50%;
            pointer-events: none;
            z-index: 25;
            opacity: 1;
            box-shadow: inset -0px -0px 0 #ccc;
            animation: smokePop 0.4s ease-out forwards;
        }

        @keyframes smokePop {
            0% {
                transform: translate(0, 0) scale(0.5);
                opacity: 1;
            }

            100% {
                transform: translate(var(--tx), var(--ty)) scale(1.5);
                opacity: 0;
            }
        }

        #dialog-box {
            height: 88px;
            background-color: #282828;
            color: white;
            border-top: 4px solid #a0a0a0;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            position: relative;
            z-index: 20;
        }

        #text-content {
            width: 60%;
            font-size: 12px;
            line-height: 18px;
            text-transform: uppercase;
            white-space: pre-wrap;
        }

        #text-content.full-width {
            width: 292px;
        }

        #action-menu {
            width: 45%;
            background: white;
            color: black;
            border-left: 4px solid #a0a0a0;
            display: grid;
            grid-template-columns: 1fr 1fr;
            padding: 5px;
            position: absolute;
            right: 0;
            top: 0;
            height: 100%;
            box-sizing: border-box;
            cursor: pointer;
            z-index: 20;
        }

        #move-menu {
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            position: absolute;
            background: white;
            z-index: 25;
            display: flex;
        }

        #move-info {
            width: 35%;
            background: #282828;
            color: white;
            padding: 8px;
            font-size: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 6px;
            border-right: 2px solid #a0a0a0;
            box-sizing: border-box;
        }

        #move-grid {
            width: 65%;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-auto-rows: 1fr;
            gap: 2px;
            padding: 4px;
            box-sizing: border-box;
        }

        .move-btn {
            background: #fff;
            border: 2px solid #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            cursor: pointer;
            text-transform: uppercase;
            text-align: center;
            padding: 2px;
            color: #000;
        }

        .move-btn.cancel {
            grid-column: span 2;
            border-color: #a0a0a0;
            background: #f0f0f0;
            color: #444;
            font-weight: bold;
        }

        .menu-item {
            font-size: 10px;
            display: flex;
            align-items: center;
            padding-left: 4px;
            text-transform: uppercase;
            white-space: nowrap;
            overflow: hidden;
        }

        .menu-item::before {
            content: "▸";
            opacity: 0;
            margin-right: 2px;
        }

        .menu-item.centered {
            justify-content: center;
            padding-left: 0;
        }

        /* --- ANIMATIONS --- */

        /* --- STATUS ANIMATIONS (Solid Silhouettes) --- */
        /* BRN: Dark Red Silhouette */
        @keyframes spriteFlashRed {

            0%,
            100% {
                filter: none;
            }

            50% {
                filter: brightness(0.4) sepia(1) saturate(100) hue-rotate(-50deg);
            }
        }

        /* PAR: Yellow Silhouette */
        @keyframes spriteFlashYellow {

            0%,
            100% {
                filter: none;
            }

            50% {
                filter: brightness(0.8) sepia(1) saturate(100) hue-rotate(0deg);
            }
        }

        /* PSN: Purple Silhouette */
        @keyframes spriteFlashPurple {

            0%,
            100% {
                filter: none;
            }

            50% {
                filter: brightness(0.5) sepia(1) saturate(100) hue-rotate(240deg);
            }
        }

        /* FRZ/SLP: Cyan/Blue Silhouette */
        @keyframes spriteFlashCyan {

            0%,
            100% {
                filter: none;
            }

            50% {
                filter: brightness(0.6) sepia(1) saturate(100) hue-rotate(150deg);
            }
        }

        .status-anim-brn {
            animation: spriteFlashRed 0.6s steps(4);
        }

        .status-anim-par {
            animation: spriteFlashYellow 0.6s steps(4);
        }

        .status-anim-psn {
            animation: spriteFlashPurple 0.6s steps(4);
        }

        .status-anim-frz,
        .status-anim-slp {
            animation: spriteFlashCyan 0.6s steps(4);
        }


        /* --- STATUS ANIMATIONS (Sprite Only) --- */
        @keyframes spriteFlashRed {

            0%,
            100% {
                filter: none;
            }

            50% {
                filter: sepia(1) saturate(8) hue-rotate(-50deg) brightness(0.8);
            }
        }

        @keyframes spriteFlashYellow {

            0%,
            100% {
                filter: none;
            }

            50% {
                filter: sepia(1) saturate(10) hue-rotate(20deg) brightness(1.2);
            }
        }

        @keyframes spriteFlashPurple {

            0%,
            100% {
                filter: none;
            }

            50% {
                filter: sepia(1) saturate(5) hue-rotate(220deg) brightness(0.7);
            }
        }

        @keyframes spriteFlashCyan {

            0%,
            100% {
                filter: none;
            }

            50% {
                filter: sepia(1) saturate(5) hue-rotate(130deg) brightness(1.2);
            }
        }

        .status-anim-brn {
            animation: spriteFlashRed 0.6s steps(4);
        }

        .status-anim-par {
            animation: spriteFlashYellow 0.6s steps(4);
        }

        .status-anim-psn {
            animation: spriteFlashPurple 0.6s steps(4);
        }

        .status-anim-frz,
        .status-anim-slp {
            animation: spriteFlashCyan 0.6s steps(4);
        }

        @keyframes spawn {
            0% {
                transform: scale(0);
                filter: brightness(0) invert(1);
                opacity: 0;
            }

            70% {
                transform: scale(1);
                filter: brightness(0) invert(1);
                opacity: 1;
            }

            100% {
                transform: scale(1);
                filter: brightness(1) invert(0);
                opacity: 1;
            }
        }

        .anim-enter {
            animation: spawn 0.6s ease-out forwards;
        }

        @keyframes withdraw {
            0% {
                transform: scale(1);
                filter: brightness(1) invert(0);
                opacity: 1;
            }

            30% {
                transform: scale(1);
                filter: brightness(0) invert(1);
                opacity: 1;
            }

            100% {
                transform: scale(0);
                filter: brightness(0) invert(1);
                opacity: 0;
            }
        }

        .anim-return {
            animation: withdraw 0.4s ease-in forwards;
        }

        .anim-return {
            animation: withdraw 0.4s ease-in forwards;
        }

        .anim-return {
            animation: withdraw 0.4s ease-in forwards;
        }

        @keyframes faint {
            0% {
                transform: translateY(0);
                opacity: 1;
            }

            100% {
                transform: translateY(40px);
                opacity: 0;
            }
        }

        .anim-faint {
            animation: faint 0.6s ease-out forwards;
        }

        .anim-faint {
            animation: faint 0.6s ease-out forwards;
        }

        .anim-faint {
            animation: faint 0.6s ease-out forwards;
        }

        @keyframes captureThrow {
            0% {
                transform: translate(0, 0) rotate(0deg);
            }

            25% {
                transform: translate(60px, -140px) rotate(180deg);
            }

            50% {
                transform: translate(140px, -180px) rotate(360deg);
            }

            75% {
                transform: translate(180px, -140px) rotate(540deg);
            }

            100% {
                transform: translate(215px, -100px) rotate(720deg);
            }
        }

        @keyframes captureShake {

            0%,
            100% {
                transform: translate(215px, -100px) rotate(0deg);
            }

            25% {
                transform: translate(215px, -100px) rotate(-15deg);
            }

            75% {
                transform: translate(215px, -100px) rotate(15deg);
            }
        }

        .pokeball-anim {
            position: absolute;
            bottom: 40px;
            left: 20px;
            width: 16px;
            height: 16px;
            background: radial-gradient(circle at 35% 35%, white 10%, red 11%, red 50%, black 51%, black 60%, white 61%);
            border-radius: 50%;
            border: 1px solid black;
            z-index: 50;
        }

        .pokeball-anim.great {
            background: radial-gradient(circle at 35% 35%, white 10%, #3b82c4 11%, #3b82c4 50%, black 51%, black 60%, white 61%);
        }

        .pokeball-anim.ultra {
            background: radial-gradient(circle at 35% 35%, white 10%, #333 11%, #333 50%, gold 51%, gold 60%, white 61%);
        }

        .pokeball-anim.master {
            background: radial-gradient(circle at 35% 35%, white 10%, #7e30cc 11%, #7e30cc 50%, pink 51%, pink 60%, white 61%);
        }

        .pokeball-caught {
            position: absolute;
            width: 16px;
            height: 16px;
            background: radial-gradient(circle at 35% 35%, white 10%, #555 11%, #555 50%, black 51%, black 60%, white 61%);
            border-radius: 50%;
            border: 1px solid black;
            z-index: 40;
            filter: grayscale(1);
        }

        @keyframes deflectAnim {
            0% {
                transform: translateX(0);
            }

            20% {
                transform: translateX(15px);
            }

            40% {
                transform: translateX(-10px);
            }

            60% {
                transform: translateX(5px);
            }

            100% {
                transform: translateX(0);
            }
        }

        .anim-deflect {
            animation: deflectAnim 0.3s ease-out;
        }

        @keyframes sparkle {
            0% {
                transform: scale(0) rotate(0deg);
                opacity: 1;
            }

            50% {
                transform: scale(1) rotate(180deg);
                opacity: 1;
            }

            100% {
                transform: scale(0) rotate(360deg);
                opacity: 0;
            }
        }

        .shiny-star {
            position: absolute;
            width: 10px;
            height: 10px;
            background: transparent;
            pointer-events: none;
            z-index: 20;
        }

        .shiny-star::before {
            content: "✦";
            color: gold;
            font-size: 16px;
            position: absolute;
        }

        @keyframes shake {
            0% {
                transform: translate(0, 0);
            }

            25% {
                transform: translate(-6px, 0);
            }

            75% {
                transform: translate(6px, 0);
            }

            100% {
                transform: translate(0, 0);
            }
        }

        @keyframes flicker {
            0% {
                opacity: 1;
            }

            25% {
                opacity: 0;
            }

            50% {
                opacity: 1;
            }

            75% {
                opacity: 0;
            }

            100% {
                opacity: 1;
            }
        }

        .anim-hit {
            animation: shake 0.4s, flicker 0.4s;
        }

        @keyframes bossIntroSequence {
            0% {
                filter: brightness(10);
                transform: translate(0, 0);
            }

            10% {
                filter: brightness(1);
                transform: translate(-8px, 8px);
            }

            20% {
                transform: translate(8px, -8px);
            }

            30% {
                transform: translate(-8px, -8px);
            }

            40% {
                transform: translate(8px, 8px);
            }

            50% {
                transform: translate(-8px, 0);
            }

            60% {
                transform: translate(8px, 0);
            }

            100% {
                filter: brightness(1);
                transform: translate(0, 0);
            }
        }

        @keyframes flashPurple {
            0% {
                box-shadow: inset 0 0 0 #a040a0;
            }

            50% {
                box-shadow: inset 0 0 150px #a040a0;
            }

            100% {
                box-shadow: inset 0 0 0 #a040a0;
            }
        }

        .fx-poison {
            animation: flashPurple 0.5s steps(5);
        }


        @keyframes statUpAnim {
            0% {
                transform: scale(1);
                filter: brightness(1);
            }

            50% {
                transform: scale(1.1, 1.1) translateY(-5px);
                filter: sepia(1) saturate(3) hue-rotate(-50deg);
            }

            100% {
                transform: scale(1);
                filter: brightness(1);
            }
        }

        @keyframes statDownAnim {
            0% {
                transform: scale(1);
                filter: brightness(1);
            }

            50% {
                transform: scale(0.9, 0.9) translateY(5px);
                filter: sepia(1) saturate(3) hue-rotate(180deg);
            }

            100% {
                transform: scale(1);
                filter: brightness(1);
            }
        }

        .anim-stat-up {
            animation: statUpAnim 0.8s steps(8);
        }

        .anim-stat-down {
            animation: statDownAnim 0.8s steps(8);
        }


        /* --- RESUME TRANSITION --- */
        @keyframes fadeInScene {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .anim-fade-in {
            animation: fadeInScene 0.8s ease-out forwards;
        }

        /* RAGE ANIMATION: Pure shake, no rotation */
        @keyframes violentShake {
            0% {
                transform: translate(0, 0);
            }

            25% {
                transform: translate(-10px, 5px);
            }

            50% {
                transform: translate(10px, -5px);
            }

            75% {
                transform: translate(-10px, -5px);
            }

            100% {
                transform: translate(0, 0);
            }
        }

        .boss-intro {
            animation: bossIntroSequence 1.0s ease-out forwards;
        }

        .anim-violent {
            animation: violentShake 0.5s ease-in-out;
        }

        /* --- FX (UPDATED: Always Retro) --- */
        @keyframes flashRed {
            0% {
                box-shadow: inset 0 0 0 red;
            }

            50% {
                box-shadow: inset 0 0 150px red;
            }

            100% {
                box-shadow: inset 0 0 0 red;
            }
        }

        @keyframes flashBlue {
            0% {
                box-shadow: inset 0 0 0 cyan;
            }

            50% {
                box-shadow: inset 0 0 150px cyan;
            }

            100% {
                box-shadow: inset 0 0 0 cyan;
            }
        }

        @keyframes flashGreen {
            0% {
                box-shadow: inset 0 0 0 lime;
            }

            50% {
                box-shadow: inset 0 0 150px lime;
            }

            100% {
                box-shadow: inset 0 0 0 lime;
            }
        }

        @keyframes flashWhite {
            0% {
                filter: brightness(1);
            }

            20% {
                filter: brightness(10);
            }

            40% {
                filter: brightness(10);
            }

            60% {
                filter: brightness(10);
            }

            100% {
                filter: brightness(1);
            }
        }

        @keyframes wobble {
            0% {
                filter: hue-rotate(0deg);
                transform: skew(0) rotate(0);
            }

            25% {
                transform: skew(10deg) rotate(5deg);
            }

            75% {
                transform: skew(-10deg) rotate(-5deg);
            }

            100% {
                filter: hue-rotate(0deg);
                transform: skew(0) rotate(0);
            }
        }

        @keyframes impact {
            0% {
                transform: translate(0, 0);
            }

            20% {
                transform: translate(-10px, 10px) rotate(5deg);
            }

            100% {
                transform: translate(0, 0);
            }
        }

        @keyframes brownQuake {
            0% {
                transform: translateY(0);
            }

            25% {
                transform: translateY(-10px);
            }

            75% {
                transform: translateY(10px);
            }

            100% {
                transform: translateY(0);
            }
        }

        /* Added 'steps(5)' to all these rules to force choppy animation */
        .fx-fire {
            animation: flashRed 0.5s steps(5);
        }

        .fx-water {
            animation: flashBlue 0.5s steps(5);
        }

        .fx-ice {
            animation: flashBlue 0.5s steps(5);
        }

        .fx-grass {
            animation: flashGreen 0.5s steps(5);
        }

        .fx-electric {
            animation: flashWhite 0.4s steps(4);
        }

        .fx-psychic,
        .fx-dragon {
            animation: wobble 0.6s steps(6);
        }

        .fx-ground,
        .fx-rock {
            animation: brownQuake 0.4s steps(8);
        }

        .fx-normal,
        .fx-fighting,
        .fx-flying {
            animation: impact 0.3s steps(8);
        }

        .transformed-sprite {
            filter: grayscale(0.4) brightness(0.9) contrast(1.1) sepia(0.2) hue-rotate(240deg) !important;
        }

        /* --- SMART RETRO MOTION OVERRIDE --- */
        /* When this class is active, FORCE all animations to look stepped/choppy */
        body.retro-motion * {
            transition-timing-function: steps(10) !important;
            animation-timing-function: steps(10) !important;
        }

        /* Exception: HP/EXP Bars look better with slightly smoother steps */
        body.retro-motion .hp-fill,
        body.retro-motion .exp-fill {
            transition-timing-function: steps(10) !important;
        }

        /* Exception: The LCD Overlay must stay smooth or it flickers badly */
        body.retro-motion #lcd-overlay {
            transition-timing-function: ease !important;
        }
    </style>
</head>

<body>

    <div id="game-container">
        <div id="game-boy">
            <div id="lcd-overlay"></div>
            <div id="streak-box" class="hidden">WINS: 0</div>

            <!-- Start Screen -->
            <div id="start-screen">
                <div class="start-title">POKEMON<br>GOLD & SILVER<br>SIMULATION</div>
                <div class="start-btn" onclick="Game.checkSave()">CLICK TO START</div>
                <div class="toggle-box" onclick="Game.toggleLcd()">
                    <div class="checkbox" id="lcd-check"></div>
                    <span>RETRO FILTER</span>
                </div>
                <!-- NEW: Retro Motion Toggle -->
                <div class="toggle-box" onclick="Game.toggleRetroMotion()">
                    <div class="checkbox" id="motion-check"></div>
                    <span>RETRO MOTION</span>
                </div>
                <div style="font-size: 6px; color: #888; margin-top: 20px;">Z: CONFIRM | X: BACK | ARROWS: MOVE</div>
            </div>

            <!-- Name Input Screen -->
            <div id="name-screen" class="hidden">
                <div style="margin-bottom: 10px;">REGISTRATION</div>
                <div style="font-size: 8px; margin-bottom: 20px;">PLEASE ENTER YOUR NAME</div>
                <input type="text" id="name-input" maxlength="8" placeholder="NAME">
                <div class="start-btn" onclick="Game.confirmName()">CONFIRM</div>
            </div>

            <!-- CONTINUE SCREEN -->
            <div id="continue-screen" class="hidden">
                <div class="cont-menu-box">
                    <div class="cont-opt" id="opt-continue" onclick="Game.loadGame()">CONTINUE</div>
                    <div class="cont-opt" id="opt-newgame" onclick="Game.startNameInput()">NEW GAME</div>
                </div>
                <div class="save-info-box">
                    <div class="save-row" style="color:yellow" id="save-name">PLAYER</div>
                    <div class="save-row"><span>WINS</span> <span id="save-wins">0</span></div>
                    <div class="save-row"><span>BOSSES</span> <span id="save-bosses">0</span></div>
                    <div class="save-row" style="margin-top:4px;">PARTY</div>
                    <div class="party-preview-row" id="save-preview"></div>
                    <div style="font-size:6px; text-align:center; color:#888;">CLICK PKMN FOR INFO</div>
                </div>
            </div>

            <!-- Summary Screen -->
            <div id="summary-panel" class="hidden">
                <div class="sum-header">
                    <div style="font-weight: bold; font-size: 10px;" id="sum-name">NAME</div>
                    <div id="sum-shiny-icon" style="color:gold; font-size:10px; display:none;">✦</div>
                    <div id="sum-status-text" style="font-size:8px;">STATUS/OK</div>
                </div>
                <div class="sum-body">
                    <div class="sum-sprite"><img id="sum-sprite-img" src=""></div>
                    <div class="sum-data">
                        <div id="sum-types"></div>
                        <div style="margin-top:4px;">HP <span id="sum-hp-txt"></span></div>
                        <div class="sum-stat-bar">
                            <div class="sum-stat-fill" id="sum-hp-bar" style="background:var(--hp-green);"></div>
                        </div>
                        <div>EXP <span id="sum-exp-txt"></span></div>
                        <div class="sum-stat-bar">
                            <div class="sum-stat-fill" id="sum-exp-bar" style="background:var(--xp-blue);"></div>
                        </div>

                        <div class="sum-divider"></div>

                        <div id="summary-stats"></div>
                    </div>
                </div>
                <div style="font-size:8px; font-weight:bold; margin-bottom:2px;">MOVES:</div>
                <div id="summary-moves" class="sum-moves"></div>
                <div class="sum-buttons">
                    <button class="confirm-btn nav-btn" id="btn-prev" onclick="Game.navSummary(-1)">&lt;</button>
                    <button class="confirm-btn" id="btn-action">ACTION</button>
                    <button class="confirm-btn secondary" id="btn-back-sum" onclick="Game.closeSummary()">CLOSE</button>
                    <button class="confirm-btn nav-btn" id="btn-next" onclick="Game.navSummary(1)">&gt;</button>
                </div>
            </div>

            <!-- Party Screen -->
            <div id="party-screen" class="hidden">
                <div class="party-header" id="party-header-text">POKEMON PARTY</div>
                <div id="party-list" class="party-list"></div>
                <div id="party-context" class="hidden"></div>
                <div class="btn-bar" id="party-close-btn" onclick="Battle.uiToMenu()">CLOSE</div>
            </div>

            <!-- Pack Screen -->
            <div id="pack-screen" class="hidden">
                <div class="pack-header">ITEM POCKET</div>
                <div class="pack-body">
                    <div class="pack-graphic">
                        <div class="bag-icon"></div>
                    </div>
                    <div class="pack-list" id="pack-list"></div>
                </div>
                <div class="pack-desc-box" id="pack-desc">Choose an item.</div>
            </div>

            <!-- RETRO SELECTION SCREEN -->
            <div id="selection-screen" class="hidden">
                <div class="sel-preview-box">
                    <img id="sel-preview-img" class="preview-sprite" src="" style="display:none">
                    <div id="sel-preview-shiny" class="shiny-mark">✦</div>
                </div>
                <div class="lab-table-area">
                    <div class="table-graphic" id="lab-table">
                        <div class="sel-cursor" id="sel-cursor"></div>
                    </div>
                </div>
                <div class="sel-desc-box" id="sel-text-box">SELECT A POKEMON</div>
            </div>

            <!-- Battle Scene -->
            <div class="scene hidden" id="scene">
                <div id="fx-container"
                    style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none;"></div>
                <div class="hud" id="enemy-hud">
                    <div class="name"><span id="enemy-name">LOADING...</span><span id="aggro-icon"
                            class="aggro-icon"></span></div>
                    <div class="level" id="enemy-lvl">Lv15</div>
                    <div class="hp-box"><span style="margin-right:2px; color:#e6ae27;">HP</span>
                        <div class="hp-bar-bg">
                            <div id="enemy-hp-bar" class="hp-fill"></div>
                        </div>
                    </div>
                </div>

                <!-- REVERTED: No anchor div, just the sprite -->
                <img id="enemy-sprite" class="sprite" src="" alt="Enemy">

                <img id="player-sprite" class="sprite" src="" alt="Player">
                <div class="hud" id="player-hud">
                    <div class="name"><span id="player-name">LOADING...</span></div>
                    <div class="level" id="player-lvl">Lv15</div>
                    <div class="hp-box"><span style="margin-right:2px; color:#e6ae27;">HP</span>
                        <div class="hp-bar-bg">
                            <div id="player-hp-bar" class="hp-fill"></div>
                        </div>
                    </div>
                    <div id="player-hp-text">--/--</div>
                    <div class="exp-box"><span style="font-size:6px; margin-right:1px;">EXP</span>
                        <div class="exp-bar-bg">
                            <div id="player-exp-bar" class="exp-fill"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Dialog Box -->
            <div id="dialog-box" class="hidden">
                <div id="text-content">...</div>
                <div id="action-menu" class="hidden">
                    <div class="menu-item" id="opt-fight" onclick="Battle.uiToMoves()">FIGHT</div>
                    <div class="menu-item" id="opt-pkmn" onclick="Game.openParty(false)">PKMN</div>
                    <div class="menu-item" id="opt-pack" onclick="Battle.openPack()">PACK</div>
                    <div class="menu-item" id="opt-run" onclick="Battle.askRun()">RUN</div>
                </div>
                <div id="move-menu" class="hidden"></div>
            </div>
        </div>
    </div>

    <script>


        // --- DEBUG SETTINGS ------------------------
        // Change ENABLED to true to activate these overrides.
        const DEBUG = {
            ENABLED: true,

            // Customize your starting items (Quantity)
            INVENTORY: {
                masterball: 50,
                maxpotion: 10,
                potion: 10,
                superpotion: 10,
                ultraball: 40,
                pokeball: 20
            },

            // Force specific Enemy attributes
            ENEMY: {
                ID: null,       // Pokedex Number (e.g. 150 = Mewtwo). Set null for random.
                LEVEL: null,    // Level (1-100). Set null for auto-scaling.
                SHINY: null,    // true = Always Shiny, false = Never Shiny, null = Random.
                IS_BOSS: null,  // true = Boss stats & music.
                RAGE: null,        // Start with Rage (0 = None, 1 = !, 2 = !!, 3 = MAX).

                // Major Status (Persistent)
                // Options: 'brn' (Burn), 'par' (Paralysis), 'slp' (Sleep), 'frz' (Freeze), 'psn' (Poison)
                STATUS: null,

                // Volatile Status (Temporary / Wear off)
                // e.g. { confused: 3 } (Confused for 3 turns)
                VOLATILES: {},

                // Stat Stages (Buffs/Debuffs)
                // Keys: atk, def, spa (Sp. Atk), spd (Sp. Def), spe, acc, eva
                // Range: -6 (Min) to +6 (Max)
                // e.g. { atk: 6, def: -2 }
                STAGES: null
            },

            // Force specific Player attributes
            PLAYER: {
                ID: null,       // Pokedex Number (e.g. 249 = Lugia).
                LEVEL: null,    // Level (1-100).
                SHINY: null,    // true/false.
                RAGE: 0,        // Start with Rage (0-3).

                // Major Status: 'brn', 'par', 'slp', 'frz', 'psn'
                STATUS: null,

                // Volatile Status: e.g. { confused: 5 }
                VOLATILES: null,

                // Stat Stages: e.g. { atk: 6, spe: 6 }
                STAGES: null,

                // Force specific moves (Array of lowercase strings with dashes)
                // e.g. ['fly', 'dig', 'solar-beam', 'protect']
                MOVES: ['substitute', 'baton-pass', 'self-destruct', 'tackle']
            },

            // Control Drop Rates
            LOOT: {
                WIN_RATE: null,       // 0.0 to 1.0 (e.g. 1.0 = Guaranteed drop on win).
                MID_BATTLE_RATE: null,// 0.0 to 1.0 (e.g. 0.5 = 50% chance on every hit).
                FORCE_ITEM: null      // Force a specific item ID (e.g. 'masterball').
            }
        };

        // --- HELPER ---
        const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // --- ANIMATION CONTROLLER ---
        // Edit these values to change game speed globally!
        const ANIM = {
            // Global UI
            HUD_SLIDE_DELAY: 200,      // Delay before HUD moves
            TEXT_READ_PAUSE: 600,      // Time to read short text (like "Come back!")

            // Intro Sequence
            INTRO_SILHOUETTE: 200,     // How long the enemy stays black
            INTRO_REVEAL_DELAY: 220,   // Pause after enemy turns color before HUD
            INTRO_BOSS_RUMBLE: 1000,   // Duration of Boss shake
            INTRO_PLAYER_WAIT: 1000,   // Pause before Player HUD appears

            // Battle Events
            CRY_DURATION: 200,        // Generic wait time for a Cry to finish
            FAINT_PRE_DELAY: 500,      // "Wait a little" before fainting
            FAINT_DROP_ANIM: 600,      // Duration of the fall animation
            FAINT_POST_DELAY: 800,     // Time to sit there before "X Fainted" text

            // Switching
            SWITCH_RETURN_ANIM: 400,   // Time for "Red beam" withdraw animation
            SWITCH_STABILIZE: 250,     // Small pause to let menus close

            // Catching
            THROW_ANIM: 600,           // How long the ball flies
            CATCH_SHAKE_DELAY: 800,    // Time between wobbles
            CATCH_SUCCESS_ANIM: 1000,  // How long the "Click" and dimming lasts
            OVERFLOW_WARNING: 1000     // How long to show "Party Full"
        };

        // --- LOOT SYSTEM ---
        // A. Define your Rarities in plain English
        const RARITY = {
            // BASE: How likely it is at Level 1 (Higher = More Common)
            // SCALING: How much more likely it gets as you level up (Higher = Becomes common later)

            COMMON: { base: 1000, scaling: 0.2 }, // Always finds these (Potions/Pokeballs)
            UNCOMMON: { base: 300, scaling: 1.5 }, // Sometimes finds these
            RARE: { base: 60, scaling: 3.0 }, // Hard to find early, easier later
            ULTRA_RARE: { base: 5, scaling: 6.0 }, // Almost impossible early, possible later
            LEGENDARY: { base: 0, scaling: 0.3 }  // Masterball (Very rare, increases VERY slowly)
        };

        // B. Assign Items to Rarities
        const LOOT_SYSTEM = {
            DROP_RATE_WILD: 0.40,       // 40% chance
            DROP_RATE_BOSS: 1.00,       // 100% chance
            DROP_RATE_MID_BATTLE: 0.20, // chance on hit

            TABLE: [
                { key: 'potion', ...RARITY.COMMON },
                { key: 'pokeball', ...RARITY.COMMON },

                { key: 'superpotion', ...RARITY.UNCOMMON },
                { key: 'greatball', ...RARITY.UNCOMMON },

                { key: 'revive', ...RARITY.RARE },
                { key: 'hyperpotion', ...RARITY.RARE },

                { key: 'ultraball', ...RARITY.ULTRA_RARE },
                { key: 'maxpotion', ...RARITY.ULTRA_RARE },

                { key: 'masterball', ...RARITY.LEGENDARY }
            ]
        };

        // --- 1. GAME BALANCE CONTROLLER ---
        // Tweak difficulty, RNG, and rewards here.
        const GAME_BALANCE = {
            // Battle Math
            CRIT_CHANCE_PLAYER: 0.0625, // 6.25%
            CRIT_CHANCE_BOSS: 0.25,     // 25%
            DAMAGE_VARIANCE_MIN: 0.85,  // Damage rolls between 85% and 100%
            DAMAGE_VARIANCE_MAX: 1.00,

            // Catching & Rage
            CATCH_RATE_MODIFIER: 1.0,   // Higher = Easier to catch
            RAGE_TRIGGER_CHANCE: 0.25,  // 25% chance to get angry on miss/fail
            RAGE_DEFLECT_CHANCE: 0.20,  // % per rage level to deflect ball

            // RAGE MECHANICS (New)
            RAGE_MULTIHIT_BASE: 0.34,   // 34% chance per rage level to hit again
            RAGE_RECOIL_CHANCE: 0.20,   // 20% chance to take damage on extra hits
            RAGE_RECOIL_DMG: 0.20,      // Take 20% of damage dealt as recoil

            // Post-Battle
            HEAL_WIN_MIN_PCT: 0.15,     // Heal at least 15% HP after win
            HEAL_WIN_MAX_PCT: 0.35      // Heal up to 35% HP
        };

        // --- 2. ENCOUNTER CONFIGURATION ---
        // Control what spawns and when.
        const ENCOUNTER_CONFIG = {
            BOSS_CHANCE: 0.05,          // 5% base chance
            BOSS_STREAK_TRIGGER: 5,     // Every 5 wins, high boss chance
            BOSS_STREAK_CHANCE: 0.95,   // 95% chance on streak turns

            SHINY_CHANCE: 0.05,         // 1/20 chance (Generous for a simulation)

            // Level Scaling (Relative to Player)
            WILD_LEVEL_MIN: -5,         // Player Level - 5
            WILD_LEVEL_MAX: -2,         // Player Level - 2
            BOSS_LEVEL_MIN: 1,          // Player Level + 1
            BOSS_LEVEL_MAX: 5           // Player Level + 5
        };

        // --- 3. AUDIO PALETTE ---
        // Define the "Voice" of the game here.
        const SFX_LIB = {
            // Simple Tones: { freq, type, duration, vol }
            select: { freq: 1200, type: 'square', dur: 0.05, vol: 0.05 },
            exp: { freq: 800, type: 'square', dur: 0.05, vol: 0.1 },
            clank: { freq: 2000, type: 'square', dur: 0.05, vol: 0.1 },

            // Complex Theme Frequencies (used in sequences)
            shiny_1: 1396.91, shiny_2: 1760.00,
            heal_base: 523.25,
            levelup_base: 1046.50
        };

        // --- 4. TYPE CHART MATRIX ---
        // Moved out of function for easy editing. 
        // 2 = Super Effective, 0.5 = Not Very, 0 = Immune
        const TYPE_CHART = {
            normal: { rock: 0.5, ghost: 0, steel: 0.5 },
            fire: { fire: 0.5, water: 0.5, grass: 2, ice: 2, bug: 2, rock: 0.5, dragon: 0.5, steel: 2 },
            water: { fire: 2, water: 0.5, grass: 0.5, ground: 2, rock: 2, dragon: 0.5 },
            electric: { water: 2, electric: 0.5, grass: 0.5, ground: 0, flying: 2, dragon: 0.5 },
            grass: { fire: 0.5, water: 2, grass: 0.5, poison: 0.5, ground: 2, flying: 0.5, bug: 0.5, rock: 2, dragon: 0.5, steel: 0.5 },
            ice: { fire: 0.5, water: 0.5, grass: 2, ice: 0.5, ground: 2, flying: 2, dragon: 2, steel: 0.5 },
            fighting: { normal: 2, ice: 2, poison: 0.5, flying: 0.5, psychic: 0.5, bug: 0.5, rock: 2, ghost: 0, dark: 2, steel: 2 },
            poison: { grass: 2, poison: 0.5, ground: 0.5, bug: 1, rock: 0.5, ghost: 0.5, steel: 0 },
            ground: { fire: 2, electric: 2, grass: 0.5, poison: 2, flying: 0, bug: 0.5, rock: 2, steel: 2 },
            flying: { electric: 0.5, grass: 2, fighting: 2, bug: 2, rock: 0.5, steel: 0.5 },
            psychic: { fighting: 2, poison: 2, psychic: 0.5, dark: 0, steel: 0.5 },
            bug: { fire: 0.5, grass: 2, fighting: 0.5, poison: 0.5, flying: 0.5, psychic: 2, ghost: 0.5, dark: 2, steel: 0.5 },
            rock: { fire: 2, ice: 2, fighting: 0.5, ground: 0.5, flying: 2, bug: 2, steel: 0.5 },
            ghost: { normal: 0, psychic: 2, ghost: 2, dark: 0.5, steel: 0.5 },
            dragon: { dragon: 2, steel: 0.5 },
            dark: { fighting: 0.5, psychic: 2, ghost: 2, dark: 0.5, steel: 0.5 },
            steel: { fire: 0.5, water: 0.5, electric: 0.5, ice: 2, rock: 2, steel: 0.5 }
        };

        // --- UNIQUE MOVE DATABASE ---
        const MOVE_DEX = {
            // --- RNG GODS ---
            'METRONOME': {
                isUnique: true,
                onHit: async (battle, user, target) => {
                    await battle.typeText("Waggling a finger...");
                    let rndId = Math.floor(Math.random() * 700) + 1;
                    const moveData = await API.getMove(rndId);

                    if (!moveData || moveData.name === 'METRONOME' || moveData.name === 'STRUGGLE') {
                        await battle.typeText("But it failed!");
                        return false;
                    }

                    await battle.typeText(`${user.name} used\n${moveData.name}!`);

                    // --- FIX: APPLY LOGIC FLAGS (Recharge, etc) ---
                    // This ensures Hyper Beam via Metronome still triggers recharge.
                    const subLogic = MOVE_LOGIC[moveData.id];
                    if (subLogic && subLogic.type === 'recharge') {
                        user.volatiles.recharging = true;
                    }

                    await battle.executeDamagePhase(user, target, moveData, user === battle.p);
                    return true;
                }
            },

            // --- SUBSTITUTE MECHANIC ---
            'SUBSTITUTE': {
                isUnique: true,
                onHit: async (battle, user, target) => {
                    if (user.volatiles.substituteHP > 0) {
                        await battle.typeText("But it failed!");
                        return false;
                    }
                    if (user.currentHp <= Math.floor(user.maxHp / 4)) {
                        await battle.typeText("Not enough HP!");
                        return false;
                    }

                    // 1. Pay Cost
                    const cost = Math.floor(user.maxHp / 4);
                    user.currentHp -= cost;
                    user.volatiles.substituteHP = cost + 1;

                    battle.updateHUD(user, user === battle.p ? 'player' : 'enemy');

                    // 2. Save Original Sprite
                    if (!user.volatiles.originalSprite) user.volatiles.originalSprite = user === battle.p ? user.backSprite : user.frontSprite;

                    const isPlayer = (user === battle.p);
                    const dollSrc = "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/substitute.png";

                    // 3. ANIMATION + TEXT SYNC
                    // We run them together so the doll appears WHILE the text types
                    const animPromise = battle.performVisualSwap(user, dollSrc, true, isPlayer);
                    const textPromise = battle.typeText(`${user.name} made\na SUBSTITUTE!`);

                    await Promise.all([animPromise, textPromise]);

                    return true;
                }
            },


            // --- BATON PASS ---
            'BATON PASS': {
                isUnique: true,
                onHit: async (battle, user, target) => {
                    // 1. AI Check
                    if (user !== battle.p) {
                        await battle.typeText("But it failed!");
                        return false;
                    }

                    // 2. Valid Party Check
                    const valid = Game.party.filter((p, i) => p.currentHp > 0 && i !== Game.activeSlot);
                    if (valid.length === 0) {
                        await battle.typeText("But there is no one\nto switch to!");
                        return false;
                    }

                    await battle.typeText(`${user.name} wants to\nswitch out!`);

                    // 3. PAUSE BATTLE - WAIT FOR SELECTION
                    // This prevents the enemy from attacking while the menu is open
                    const selectedIndex = await new Promise(resolve => {
                        battle.userInputPromise = resolve;
                        Game.openParty(true);
                    });

                    battle.userInputPromise = null; // Clean up listener

                    // 4. RESUME - EXECUTE SWITCH
                    const newMon = Game.party[selectedIndex];

                    // Set flag so processSwitch knows to copy stats
                    battle.batonPassActive = true;

                    // Trigger the switch animation manually
                    await battle.processSwitch(newMon, false);

                    // Reset flag
                    battle.batonPassActive = false;

                    return true;
                }
            },

            // --- HEALING & RESTORATION ---
            'REST': {
                isUnique: true,
                onHit: async (battle, user, target) => {
                    if (user.currentHp === user.maxHp) { await battle.typeText("It's already\nfully healthy!"); return false; }

                    AudioEngine.playSfx('heal');

                    // 1. Heal & Status Clear
                    user.status = 'slp';
                    user.volatiles = {}; // Clears confusion, bad poison, etc
                    user.volatiles.sleepTurns = 2; // Gen 2 style: 2 turns guaranteed sleep
                    user.currentHp = user.maxHp;

                    battle.updateHUD(user, user === battle.p ? 'player' : 'enemy');

                    // 2. Animation
                    const sprite = user === battle.p ? document.getElementById('player-sprite') : document.getElementById('enemy-sprite');
                    sprite.classList.add('status-anim-slp');
                    await wait(600);
                    sprite.classList.remove('status-anim-slp');

                    await battle.typeText(`${user.name} slept and\nbecame healthy!`);
                    return true;
                }
            },
            'RECOVER': { isUnique: true, onHit: async (b, u, t) => _heal(b, u, 0.5) },
            'SOFT BOILED': { isUnique: true, onHit: async (b, u, t) => _heal(b, u, 0.5) },
            'MILK DRINK': { isUnique: true, onHit: async (b, u, t) => _heal(b, u, 0.5) },
            'SLACK OFF': { isUnique: true, onHit: async (b, u, t) => _heal(b, u, 0.5) },
            'ROOST': { isUnique: true, onHit: async (b, u, t) => _heal(b, u, 0.5) },
            'SYNTHESIS': { isUnique: true, onHit: async (b, u, t) => _weatherHeal(b, u) },
            'MORNING SUN': { isUnique: true, onHit: async (b, u, t) => _weatherHeal(b, u) },
            'MOONLIGHT': { isUnique: true, onHit: async (b, u, t) => _weatherHeal(b, u) },

            // --- DELAYED ATTACKS ---
            'FUTURE SIGHT': {
                isUnique: true,
                onHit: async (battle, user, target) => {
                    const exists = battle.delayedMoves.find(m => m.moveData.name === 'FUTURE SIGHT' && m.target === target);
                    if (exists) { await battle.typeText("But it failed!"); return false; }

                    await battle.typeText(`${user.name} foresaw\nan attack!`);
                    battle.delayedMoves.push({
                        turns: 2, user: user, target: target, isPlayer: (user === battle.p),
                        moveData: { name: 'FUTURE SIGHT', type: 'psychic', power: 120, category: 'special' }
                    });
                    return true;
                }
            },
            'DOOM DESIRE': {
                isUnique: true,
                onHit: async (battle, user, target) => {
                    const exists = battle.delayedMoves.find(m => m.moveData.name === 'DOOM DESIRE' && m.target === target);
                    if (exists) { await battle.typeText("But it failed!"); return false; }
                    await battle.typeText(`${user.name} chose\nDoom Desire!`);
                    battle.delayedMoves.push({
                        turns: 2, user: user, target: target, isPlayer: (user === battle.p),
                        moveData: { name: 'DOOM DESIRE', type: 'steel', power: 140, category: 'special' }
                    });
                    return true;
                }
            },

            // --- FIXED / UNIQUE DAMAGE ---
            'DRAGON RAGE': { fixedDamage: 40 },
            'SONIC BOOM': { fixedDamage: 20 },
            'SEISMIC TOSS': { damageCallback: (u, t) => u.level },
            'NIGHT SHADE': { damageCallback: (u, t) => u.level },
            'PSYWAVE': { damageCallback: (u, t) => Math.floor(u.level * (0.5 + Math.random())) },
            'SUPER FANG': { damageCallback: (u, t) => Math.max(1, Math.floor(t.currentHp / 2)) },
            'ENDEAVOR': { damageCallback: (u, t) => Math.max(0, t.currentHp - u.currentHp) },

            // --- OHKO ---
            'FISSURE': { ohko: true },
            'GUILLOTINE': { ohko: true },
            'HORN DRILL': { ohko: true },
            'SHEER COLD': { ohko: true },

            // --- COMPLEX STATUS/STATS ---

            'SUBSTITUTE': {
                isUnique: true,
                onHit: async (battle, user, target) => {
                    if (user.volatiles.substituteHP > 0) {
                        await battle.typeText("But it failed!");
                        return false;
                    }
                    if (user.currentHp <= Math.floor(user.maxHp / 4)) {
                        await battle.typeText("Not enough HP!");
                        return false;
                    }

                    const cost = Math.floor(user.maxHp / 4);
                    user.currentHp -= cost;
                    user.volatiles.substituteHP = cost + 1;

                    battle.updateHUD(user, user === battle.p ? 'player' : 'enemy');
                    await battle.typeText(`${user.name} made\na SUBSTITUTE!`);

                    const sprite = user === battle.p ? document.getElementById('player-sprite') : document.getElementById('enemy-sprite');
                    AudioEngine.playSfx('swoosh');

                    // Save Original
                    if (!user.volatiles.originalSprite) user.volatiles.originalSprite = user === battle.p ? user.backSprite : user.frontSprite;

                    // Apply Doll
                    sprite.src = "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/substitute.png";

                    // FIX: Apply Flip Class if Player
                    if (user === battle.p) sprite.classList.add('sub-back');

                    sprite.classList.add('anim-enter');
                    setTimeout(() => sprite.classList.remove('anim-enter'), 500);

                    return true;
                }
            },

            'ROAR': {
                isUnique: true,
                onHit: async (battle, user, target) => {
                    return await _forceSwitchOrRun(battle, user, target);
                }
            },
            'WHIRLWIND': {
                isUnique: true,
                onHit: async (battle, user, target) => {
                    return await _forceSwitchOrRun(battle, user, target);
                }
            },

            'TRANSFORM': {
                isUnique: true,
                onHit: async (battle, user, target) => {
                    if (user.transformBackup) return false; // Already transformed

                    // Create Backup
                    user.transformBackup = {
                        name: user.name, moves: [...user.moves], stats: { ...user.stats },
                        types: [...user.types], stages: { ...user.stages },
                        frontSprite: user.frontSprite, backSprite: user.backSprite
                    };

                    // Copy Data (Keep own HP)
                    user.moves = target.moves.map(m => ({ ...m, max_pp: 5, pp: 5 }));
                    user.stats = { ...target.stats, hp: user.stats.hp };
                    user.types = [...target.types];
                    user.stages = { ...target.stages };
                    user.frontSprite = target.frontSprite;
                    user.backSprite = target.backSprite;

                    const sprite = user === battle.p ? document.getElementById('player-sprite') : document.getElementById('enemy-sprite');

                    // Animation
                    AudioEngine.playSfx('swoosh');
                    sprite.style.transition = 'filter 0.2s';
                    sprite.style.filter = "brightness(10)";
                    await wait(300);
                    sprite.src = user === battle.p ? user.backSprite : user.frontSprite;
                    sprite.classList.add('transformed-sprite');
                    sprite.style.filter = "";

                    await battle.typeText(`${user.transformBackup.name} transformed\ninto ${target.name}!`);
                    return true;
                }
            },
            'HAZE': {
                isUnique: true,
                onHit: async (battle, user, target) => {
                    user.stages = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, acc: 0, eva: 0 };
                    target.stages = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, acc: 0, eva: 0 };
                    AudioEngine.playSfx('swoosh');
                    await battle.typeText("All stat changes\nwere eliminated!");
                    return true;
                }
            },
            'BELLY DRUM': {
                isUnique: true,
                onHit: async (battle, user, target) => {
                    if (user.currentHp <= user.maxHp / 2 || user.stages.atk >= 6) { await battle.typeText("But it failed!"); return false; }
                    user.currentHp = Math.floor(user.currentHp - (user.maxHp / 2));
                    user.stages.atk = 6;
                    battle.updateHUD(user, user === battle.p ? 'player' : 'enemy');
                    await battle.typeText(`${user.name} cut its HP\nto max ATTACK!`);
                    return true;
                }
            },
            'CURSE': {
                isUnique: true,
                onHit: async (battle, user, target) => {
                    if (user.types.includes('ghost')) {
                        user.currentHp = Math.floor(user.currentHp / 2);
                        battle.updateHUD(user, user === battle.p ? 'player' : 'enemy');
                        await battle.typeText(`${user.name} cut its HP\nto lay a curse!`);

                        // Direct Damage Simulation (Since we don't have Curse volatile logic yet)
                        const dmg = Math.floor(target.maxHp / 4);
                        target.currentHp -= dmg;
                        battle.updateHUD(target, user === battle.p ? 'enemy' : 'player');
                        await battle.typeText(`${target.name} was hurt\nby the curse!`);
                    } else {
                        await battle.applyStatChanges(user, [{ stat: { name: 'speed' }, change: -1 }, { stat: { name: 'attack' }, change: 1 }, { stat: { name: 'defense' }, change: 1 }], user === battle.p);
                    }
                    return true;
                }
            },
            'PAIN SPLIT': {
                isUnique: true,
                onHit: async (battle, user, target) => {
                    const avg = Math.floor((user.currentHp + target.currentHp) / 2);
                    user.currentHp = Math.min(user.maxHp, avg);
                    target.currentHp = Math.min(target.maxHp, avg);
                    battle.updateHUD(user, 'player');
                    battle.updateHUD(target, 'enemy');
                    battle.updateHUD(user, 'enemy'); // Redundant safety update
                    battle.updateHUD(target, 'player');
                    await battle.typeText("The battlers shared\ntheir pain!");
                    return true;
                }
            },

            // --- CONDITIONAL ---
            'DREAM EATER': { condition: (t) => t.status === 'slp' },
            'NIGHTMARE': { condition: (t) => t.status === 'slp' },
            'SNORE': { condition: (t) => true }, // Placeholder for sleep check
        };

        // --- HELPERS for DEX ---
        async function _heal(battle, user, pct) {
            if (user.currentHp === user.maxHp) { await battle.typeText("It's already\nfully healthy!"); return false; }

            const amt = Math.floor(user.maxHp * pct);
            // Use Helper (automatically handles HUD, Sound, and "Regained health" text)
            await battle.applyHeal(user, amt);

            return true;
        }

        async function _weatherHeal(battle, user) {
            let pct = 0.5;
            if (battle.weather.type === 'sun') pct = 0.66;
            else if (battle.weather.type !== 'none') pct = 0.25;
            return _heal(battle, user, pct);
        }

        // Helper to use constants easier
        // Usage: await sleep(ANIM.CRY_DURATION);
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));



        const STATUS_DATA = {
            par: { name: "PAR", color: "#d8b030", msg: "is paralyzed!\nIt can't move!" },
            brn: { name: "BRN", color: "#c83828", msg: "is hurt\nby its burn!" },
            psn: { name: "PSN", color: "#a040a0", msg: "is hurt\nby poison!" },
            frz: { name: "FRZ", color: "#40a8c0", msg: "is frozen\nsolid!" },
            slp: { name: "SLP", color: "#888888", msg: "is fast\nasleep!" },
            confused: { name: "confused", msg: "is confused!" }
        };

        // Stat stage multipliers: -6 to +6
        const STAGE_MULT = {
            '-6': 2 / 8, '-5': 2 / 7, '-4': 2 / 6, '-3': 2 / 5, '-2': 2 / 4, '-1': 2 / 3,
            '0': 1,
            '1': 1.5, '2': 2.0, '3': 2.5, '4': 3.0, '5': 3.5, '6': 4.0
        };

        // Logic for Two-Turn and Special Moves
        const MOVE_LOGIC = {
            'fly': { type: 'charge', msg: "flew up high!", invuln: 'flying', hide: true },
            'dig': { type: 'charge', msg: "burrowed underground!", invuln: 'digging', hide: true },
            'dive': { type: 'charge', msg: "hid underwater!", invuln: 'diving', hide: true },
            'solar-beam': { type: 'charge', msg: "took in sunlight!", invuln: null, hide: false, weatherSkip: 'sun' },
            'skull-bash': { type: 'charge', msg: "lowered its head!", invuln: null, hide: false, buff: { stat: 'def', val: 1 } },
            'hyper-beam': { type: 'recharge' },
            'giga-impact': { type: 'recharge' },
            'protect': { type: 'protect' },
            'detect': { type: 'protect' }
        };

        // Weather Visuals & Text
        const WEATHER_FX = {
            'sun': {
                color: 'rgba(255, 200, 0, 0.1)',
                msg: "The sunlight is strong.",
                continue: "The sunlight is strong."
            },
            'rain': {
                color: 'rgba(0, 0, 255, 0.1)',
                msg: "It started to rain.",
                continue: "Rain continues to fall."
            },
            'sand': {
                color: 'rgba(180, 160, 100, 0.2)',
                msg: "A sandstorm is brewing.",
                continue: "The sandstorm rages."
            },
            'hail': {
                color: 'rgba(200, 255, 255, 0.2)',
                msg: "It started to hail.",
                continue: "The hail continues to fall."
            }
        };

        const ITEMS = {
            potion: { name: "POTION", heal: 20, type: 'heal', desc: "Restores Pokemon HP by 20.", img: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/potion.png" },
            superpotion: { name: "SUPER POTION", heal: 50, type: 'heal', desc: "Restores Pokemon HP by 50.", img: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/super-potion.png" },
            hyperpotion: { name: "HYPER POTION", heal: 200, type: 'heal', desc: "Restores Pokemon HP by 200.", img: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/hyper-potion.png" },
            maxpotion: { name: "MAX POTION", heal: 9999, type: 'heal', desc: "Fully restores Pokemon HP.", img: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/max-potion.png" },
            revive: { name: "REVIVE", type: 'revive', desc: "Restores a fainted Pokemon to 50% HP.", img: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/revive.png" },
            pokeball: { name: "POKE BALL", type: 'ball', rate: 1, desc: "A device for catching wild Pokemon.", css: '', img: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/poke-ball.png" },
            greatball: { name: "GREAT BALL", type: 'ball', rate: 1.5, desc: "A good Ball with a higher catch rate.", css: 'great', img: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/great-ball.png" },
            ultraball: { name: "ULTRA BALL", type: 'ball', rate: 2, desc: "A better Ball with a high catch rate.", css: 'ultra', img: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/ultra-ball.png" },
            masterball: { name: "MASTER BALL", type: 'ball', rate: 255, desc: "The best Ball. It catches without fail.", css: 'master', img: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/master-ball.png" }
        };


        const StatCalc = {
            // Gen 2 Style Formula
            other: (base, lvl) => Math.floor((2 * base * lvl) / 100 + 5),
            hp: (base, lvl) => Math.floor((2 * base * lvl) / 100 + lvl + 10),

            // Updates a Pokemon object in-place
            recalculate: (p) => {
                const oldMax = p.maxHp;

                p.stats.atk = StatCalc.other(p.baseStats.atk, p.level);
                p.stats.def = StatCalc.other(p.baseStats.def, p.level);
                p.stats.spa = StatCalc.other(p.baseStats.spa, p.level);
                p.stats.spd = StatCalc.other(p.baseStats.spd, p.level);
                p.stats.spe = StatCalc.other(p.baseStats.spe, p.level);
                p.stats.hp = StatCalc.hp(p.baseStats.hp, p.level);

                // Adjust current HP to match the growth
                p.maxHp = p.stats.hp;
                p.currentHp += (p.maxHp - oldMax);
            }
        };

        const AudioEngine = {
            ctx: null,
            lastCryTimeout: null,
            init() { if (!this.ctx) { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); } if (this.ctx.state === 'suspended') this.ctx.resume(); },
            playCry(url) {
                if (!url) return;
                if (this.lastCryTimeout) clearTimeout(this.lastCryTimeout);
                this.init();
                const a = new Audio(url); a.volume = 0.4; a.play().catch(() => { });
            },
            playTone(freq, type, dur, vol, delay) {
                const t = this.ctx.currentTime + delay; const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
                o.type = type; o.frequency.value = freq; o.connect(g); g.connect(this.ctx.destination);
                g.gain.setValueAtTime(vol, t); g.gain.linearRampToValueAtTime(0, t + dur); o.start(t); o.stop(t + dur);
            },
            playNoise(dur) {
                const t = this.ctx.currentTime; const bufSize = this.ctx.sampleRate * dur; const buf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
                const data = buf.getChannelData(0); for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = this.ctx.createBufferSource(); noise.buffer = buf;
                const gain = this.ctx.createGain(); gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t + dur);
                noise.connect(gain); gain.connect(this.ctx.destination); noise.start(t);
            },
            playSfx(key) {
                this.init(); const now = this.ctx.currentTime;

                if (SFX_LIB[key]) {
                    const s = SFX_LIB[key];
                    this.playTone(s.freq, s.type, s.dur, s.vol, 0);
                    return;
                }

                const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.connect(gain); gain.connect(this.ctx.destination);

                switch (key) {

                    case 'run':
                        // Blue Noise Sweep (Escaping sound)
                        const rBuf = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.4, this.ctx.sampleRate);
                        const rData = rBuf.getChannelData(0);
                        for (let i = 0; i < rBuf.length; i++) rData[i] = Math.random() * 2 - 1;
                        const rSrc = this.ctx.createBufferSource(); rSrc.buffer = rBuf;
                        const rFilter = this.ctx.createBiquadFilter(); rFilter.type = "lowpass";
                        rFilter.frequency.setValueAtTime(800, now);
                        rFilter.frequency.linearRampToValueAtTime(100, now + 0.3); // Filter closes down
                        const rGain = this.ctx.createGain(); rGain.gain.setValueAtTime(0.2, now); rGain.gain.linearRampToValueAtTime(0, now + 0.3);
                        rSrc.connect(rFilter); rFilter.connect(rGain); rGain.connect(this.ctx.destination);
                        rSrc.start(now);
                        break;

                    case 'electric':
                        // BZZT Sound: Sawtooth with rapid frequency modulation
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(150, now);
                        osc.frequency.linearRampToValueAtTime(600, now + 0.1); // Zip up
                        osc.frequency.linearRampToValueAtTime(100, now + 0.3); // Zip down

                        // Rough amplitude (stutter)
                        gain.gain.setValueAtTime(0.15, now);
                        gain.gain.setValueAtTime(0, now + 0.05);
                        gain.gain.setValueAtTime(0.15, now + 0.1);
                        gain.gain.linearRampToValueAtTime(0, now + 0.3);

                        osc.start(now); osc.stop(now + 0.3);
                        break;

                    case 'ball': this.playNoise(0.3); break;
                    case 'rumble': this.playNoise(0.5); break;
                    case 'catch_success': this.playNoise(0.2); break;

                    case 'shiny':
                        this.playTone(SFX_LIB.shiny_1, 'sine', 0.1, 0.1, 0);
                        this.playTone(SFX_LIB.shiny_2, 'sine', 0.2, 0.1, 0.1);
                        return;

                    case 'heal':
                        [0, 0.1, 0.2, 0.3].forEach((d, i) => {
                            const ratios = [1, 1.25, 1.5, 2];
                            this.playTone(SFX_LIB.heal_base * ratios[i], 'sine', 0.1 + (i * 0.05), 0.1, d);
                        });
                        return;

                    case 'levelup':
                        [0, 0.15, 0.3, 0.45].forEach((d, i) => {
                            const ratios = [1, 1.25, 1.5, 2];
                            this.playTone(SFX_LIB.levelup_base * ratios[i], 'square', 0.1, 0.1, d);
                        });
                        return;

                    case 'funfair':
                        this.playTone(523.25, 'square', 0.1, 0.1, 0); this.playTone(659.25, 'square', 0.1, 0.1, 0.1); this.playTone(783.99, 'square', 0.1, 0.1, 0.2); this.playTone(1046.50, 'square', 0.2, 0.1, 0.3); return;

                    case 'error': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); gain.gain.setValueAtTime(0.3, now); gain.gain.linearRampToValueAtTime(0, now + 0.2); osc.start(now); osc.stop(now + 0.2); break;
                    case 'crit': osc.type = 'square'; osc.frequency.setValueAtTime(80, now); gain.gain.setValueAtTime(0.5, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3); osc.start(now); osc.stop(now + 0.3); break;
                    case 'miss': osc.type = 'square'; osc.frequency.setValueAtTime(500, now); gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.1); osc.start(now); osc.stop(now + 0.1); break;
                    case 'damage': osc.type = 'square'; osc.frequency.setValueAtTime(200, now); osc.frequency.exponentialRampToValueAtTime(50, now + 0.2); gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.2); osc.start(now); osc.stop(now + 0.2); break;
                    case 'throw': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(300, now); osc.frequency.linearRampToValueAtTime(100, now + 0.3); gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.3); osc.start(now); osc.stop(now + 0.3); break;
                    case 'catch_click': osc.type = 'square'; osc.frequency.setValueAtTime(800, now); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05); osc.start(now); osc.stop(now + 0.05); break;

                    case 'swoosh':
                        const bBuf = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.3, this.ctx.sampleRate);
                        const bData = bBuf.getChannelData(0);
                        for (let i = 0; i < bBuf.length; i++) bData[i] = Math.random() * 2 - 1;
                        const bSrc = this.ctx.createBufferSource(); bSrc.buffer = bBuf;
                        const bFilter = this.ctx.createBiquadFilter(); bFilter.type = "lowpass";
                        bFilter.frequency.setValueAtTime(800, now); bFilter.frequency.linearRampToValueAtTime(100, now + 0.2);
                        const bGain = this.ctx.createGain(); bGain.gain.setValueAtTime(0.1, now); bGain.gain.linearRampToValueAtTime(0, now + 0.2);
                        bSrc.connect(bFilter); bFilter.connect(bGain); bGain.connect(this.ctx.destination);
                        bSrc.start(now);
                        break;

                    default: osc.type = 'square'; osc.frequency.setValueAtTime(150, now); osc.frequency.exponentialRampToValueAtTime(40, now + 0.1); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1); osc.start(now); osc.stop(now + 0.1); break;
                }
            },
        };

        const API = {
            base: 'https://pokeapi.co/api/v2',
            async getPokemon(id, level, overrides = {}) {
                try {
                    const res = await fetch(`${this.base}/pokemon/${id}`); const data = await res.json();
                    const getStat = (n) => data.stats.find(s => s.stat.name === n).base_stat;

                    const isShiny = (overrides.shiny !== undefined && overrides.shiny !== null) ? overrides.shiny : Math.random() < 0.05;

                    const stats = {
                        hp: StatCalc.hp(getStat('hp'), level),
                        atk: StatCalc.other(getStat('attack'), level),
                        def: StatCalc.other(getStat('defense'), level),
                        spa: StatCalc.other(getStat('special-attack'), level),
                        spd: StatCalc.other(getStat('special-defense'), level),
                        spe: StatCalc.other(getStat('speed'), level)
                    };

                    // MOVE FETCHING LOGIC
                    let availableMoves = data.moves.map(m => m.move.name).sort(() => 0.5 - Math.random());
                    let selectedMoveNames = availableMoves.slice(0, 4);

                    if (overrides.moves && Array.isArray(overrides.moves)) {
                        selectedMoveNames = overrides.moves;
                    }

                    const moves = [];

                    for (let name of selectedMoveNames) {
                        try {
                            const mRes = await fetch(`${this.base}/move/${name}`);
                            if (!mRes.ok) continue;
                            const mData = await mRes.json();

                            moves.push({
                                name: mData.name.replace('-', ' ').toUpperCase(),
                                id: mData.name,
                                type: mData.type.name,
                                power: mData.power || 0,
                                accuracy: mData.accuracy || 100,
                                category: mData.damage_class.name,
                                priority: mData.priority,
                                meta: mData.meta || {},
                                stat_changes: mData.stat_changes || [],
                                target: mData.target.name,
                                stat_chance: mData.meta ? mData.meta.stat_chance : 0,
                                // NEW: Fetch Multi-Hit Data
                                min_hits: mData.meta ? mData.meta.min_hits : null,
                                max_hits: mData.meta ? mData.meta.max_hits : null
                            });
                        } catch (err) { console.error("Move fetch failed:", name); }
                    }

                    const vCrystal = data.sprites.versions['generation-ii']['crystal'];
                    const baseExp = data.base_experience || 64;
                    const nextLvlExp = Math.pow(level + 1, 3) - Math.pow(level, 3);
                    const bst = getStat('hp') + getStat('attack') + getStat('defense') + getStat('special-attack') + getStat('special-defense') + getStat('speed');
                    const highTier = bst > 480;

                    let initStatus = null;
                    let initStages = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, acc: 0, eva: 0 };

                    if (overrides.status) initStatus = overrides.status;
                    if (overrides.stages) Object.assign(initStages, overrides.stages);

                    return {
                        id: data.id, name: data.name.toUpperCase(), level: level,
                        maxHp: stats.hp, currentHp: stats.hp, stats: stats,
                        baseStats: { hp: getStat('hp'), atk: getStat('attack'), def: getStat('defense'), spa: getStat('special-attack'), spd: getStat('special-defense'), spe: getStat('speed') },
                        exp: 0, nextLvlExp: nextLvlExp, baseExp: baseExp,
                        status: initStatus, volatiles: {}, stages: initStages,
                        types: data.types.map(t => t.type.name), moves: moves, isShiny: isShiny,
                        frontSprite: isShiny ? vCrystal.front_shiny_transparent : vCrystal.front_transparent,
                        backSprite: isShiny ? vCrystal.back_shiny_transparent : vCrystal.back_transparent,
                        icon: data.sprites.versions['generation-vii']['icons'].front_default, cry: data.cries.latest, isBoss: false,
                        failedCatches: 0, rageLevel: 0, isHighTier: highTier
                    };
                } catch (e) { console.error(e); return null; }
            },
            // --- NEW: FETCH SINGLE MOVE (For Metronome) ---
            async getMove(idOrName) {
                try {
                    const res = await fetch(`${this.base}/move/${idOrName}`);
                    if (!res.ok) return null;
                    const mData = await res.json();

                    return {
                        name: mData.name.replace(/-/g, ' ').toUpperCase(),
                        id: mData.name,
                        type: mData.type.name,
                        power: mData.power || 0,
                        accuracy: mData.accuracy || 100,
                        category: mData.damage_class.name,
                        priority: mData.priority,
                        meta: mData.meta || {},
                        stat_changes: mData.stat_changes || [],
                        target: mData.target.name,
                        stat_chance: mData.meta ? mData.meta.stat_chance : 0,
                        min_hits: mData.meta ? mData.meta.min_hits : null,
                        max_hits: mData.meta ? mData.meta.max_hits : null
                    };
                } catch (e) { return null; }
            },

        };

        const Input = {
            focus: 0, mode: 'NONE', lcdEnabled: false, lastFocus: -1,

            init() { document.addEventListener('keydown', (e) => this.handleKey(e)); },

            setMode(m, resetIndex = 0) {
                this.mode = m;
                this.focus = resetIndex;
                this.lastFocus = -1;
                this.updateVisuals();
            },

            // --- 1. VISUAL HIGHLIGHTING LOGIC ---
            visuals: {
                'BATTLE': () => document.getElementById(['opt-fight', 'opt-pkmn', 'opt-pack', 'opt-run'][Input.focus]),
                'CONTINUE': () => document.getElementById(['opt-continue', 'opt-newgame'][Input.focus]),
                'CONFIRM_RUN': () => document.querySelectorAll('#action-menu .menu-item')[Input.focus],

                'MOVES': () => {
                    const opts = document.querySelectorAll('#move-grid .move-btn');
                    if (Input.focus >= opts.length) Input.focus = opts.length - 1;
                    const target = opts[Input.focus];

                    // Update Info Panel
                    if (target) {
                        const info = document.getElementById('move-info');
                        if (target.dataset.action === 'back') {
                            info.innerHTML = '<div>RETURN<br>TO MENU</div>';
                        } else if (target.dataset.type) {
                            info.innerHTML = `<div>TYPE/<br>${target.dataset.type.toUpperCase()}</div><div>PWR/${target.dataset.power}</div><div>ACC/${target.dataset.accuracy}%</div>`;
                        }
                    }
                    return target;
                },

                'SELECTION': () => {
                    const target = document.getElementById(`ball-${Input.focus}`);
                    const cursor = document.getElementById('sel-cursor');
                    const positions = [25, 90, 155];
                    if (cursor) cursor.style.left = positions[Input.focus] + 'px';

                    if (Game.tempSelectionList && Game.tempSelectionList[Input.focus]) {
                        const p = Game.tempSelectionList[Input.focus];
                        if (Input.lastFocus !== Input.focus) {
                            Input.lastFocus = Input.focus;
                            AudioEngine.playCry(p.cry);
                            const prevImg = document.getElementById('sel-preview-img');
                            const prevShiny = document.getElementById('sel-preview-shiny');
                            if (prevImg) {
                                prevImg.src = p.frontSprite;
                                prevImg.style.display = 'block';
                                prevShiny.style.display = p.isShiny ? 'block' : 'none';
                            }
                            Battle.typeText(`Will you choose\n${p.name}?`, null, true);
                        }
                    }
                    return target;
                },

                'PARTY': () => {
                    const opts = document.querySelectorAll('.party-slot');
                    if (Input.focus === opts.length) return document.getElementById('party-close-btn');
                    return opts[Input.focus];
                },

                'CONTEXT': () => document.querySelectorAll('#party-context .ctx-btn')[Input.focus],

                'BAG': () => {
                    const target = document.querySelectorAll('.pack-item')[Input.focus];
                    // Trigger hover description
                    if (target && target.classList.contains('pack-item') && !target.classList.contains('cancel-btn')) target.onmouseover();
                    return target;
                },

                'SUMMARY': () => document.querySelectorAll('.sum-buttons .confirm-btn')[Input.focus]
            },

            updateVisuals() {
                // Clear old focus
                document.querySelectorAll('.focused').forEach(el => el.classList.remove('focused'));

                // Find new target based on current Mode
                let target = null;
                if (this.visuals[this.mode]) {
                    target = this.visuals[this.mode]();
                }

                // Apply Focus
                if (target) {
                    target.classList.add('focused');
                    if (target.scrollIntoViewIfNeeded) target.scrollIntoViewIfNeeded(false);
                    else target.scrollIntoView({ block: 'nearest' });
                }
            },

            // --- 2. INPUT HANDLERS ---
            handlers: {
                'START': (k) => {
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(k)) { Game.toggleLcd(); AudioEngine.playSfx('select'); }
                    if (['z', 'Z', 'Enter'].includes(k)) Game.checkSave();
                },
                'NAME': (k) => {
                    if (['z', 'Z', 'Enter'].includes(k)) Game.confirmName();
                },
                'CONTINUE': (k) => {
                    if (k === 'ArrowUp' || k === 'ArrowDown') Input.focus = Input.focus === 0 ? 1 : 0;
                    if (['z', 'Z', 'Enter'].includes(k)) document.getElementById(['opt-continue', 'opt-newgame'][Input.focus]).click();
                },
                'BATTLE': (k) => {
                    if (k === 'ArrowRight' && Input.focus % 2 === 0) Input.focus++;
                    if (k === 'ArrowLeft' && Input.focus % 2 !== 0) Input.focus--;
                    if (k === 'ArrowDown' && Input.focus < 2) Input.focus += 2;
                    if (k === 'ArrowUp' && Input.focus > 1) Input.focus -= 2;
                    if (['z', 'Z', 'Enter'].includes(k)) document.getElementById(['opt-fight', 'opt-pkmn', 'opt-pack', 'opt-run'][Input.focus]).click();
                },
                'CONFIRM_RUN': (k) => {
                    if (k === 'ArrowRight' || k === 'ArrowDown') Input.focus = 1;
                    if (k === 'ArrowLeft' || k === 'ArrowUp') Input.focus = 0;
                    if (['z', 'Z', 'Enter'].includes(k)) document.querySelectorAll('#action-menu .menu-item')[Input.focus].click();
                },
                'MOVES': (k) => {
                    const len = document.querySelectorAll('.move-btn').length;
                    if (k === 'ArrowRight' && Input.focus % 2 === 0 && Input.focus < len - 1) Input.focus++;
                    if (k === 'ArrowLeft' && Input.focus % 2 !== 0) Input.focus--;
                    if (k === 'ArrowDown') { if (Input.focus < len - 2) Input.focus += 2; else if (Input.focus < len - 1) Input.focus = len - 1; }
                    if (k === 'ArrowUp') { if (Input.focus >= 2) Input.focus -= 2; else if (Input.focus === len - 1) Input.focus = 0; }
                    if (Input.focus >= len) Input.focus = len - 1;
                    if (['z', 'Z', 'Enter'].includes(k)) document.querySelectorAll('.move-btn')[Input.focus].click();
                },
                'SELECTION': (k) => {
                    if (k === 'ArrowRight') Input.focus = Math.min(2, Input.focus + 1);
                    if (k === 'ArrowLeft') Input.focus = Math.max(0, Input.focus - 1);
                    if (['z', 'Z', 'Enter'].includes(k)) document.getElementById(`ball-${Input.focus}`).click();
                },
                'BAG': (k) => {
                    const len = document.querySelectorAll('.pack-item').length;
                    if (k === 'ArrowDown') Input.focus = Math.min(len - 1, Input.focus + 1);
                    if (k === 'ArrowUp') Input.focus = Math.max(0, Input.focus - 1);
                    if (['z', 'Z', 'Enter'].includes(k)) document.querySelectorAll('.pack-item')[Input.focus].click();
                },
                'PARTY': (k) => {
                    const len = Game.party.length; // Length is the Close Button index
                    if (k === 'ArrowDown') Input.focus = Math.min(len, Input.focus + 1);
                    if (k === 'ArrowUp') Input.focus = Math.max(0, Input.focus - 1);
                    if (['z', 'Z', 'Enter'].includes(k)) {
                        if (Input.focus === len) document.getElementById('party-close-btn').click();
                        else document.querySelectorAll('.party-slot')[Input.focus].click();
                    }
                },
                'CONTEXT': (k) => {
                    const len = document.querySelectorAll('#party-context .ctx-btn').length;
                    if (k === 'ArrowDown') Input.focus = Math.min(len - 1, Input.focus + 1);
                    if (k === 'ArrowUp') Input.focus = Math.max(0, Input.focus - 1);
                    if (['z', 'Z', 'Enter'].includes(k)) document.querySelectorAll('#party-context .ctx-btn')[Input.focus].click();
                },
                'SUMMARY': (k) => {
                    if (k === 'ArrowRight') { if (Input.focus < 3) Input.focus++; else Game.navSummary(1); }
                    if (k === 'ArrowLeft') { if (Input.focus > 0) Input.focus--; else Game.navSummary(-1); }
                    if (k === 'ArrowDown') Game.navSummary(1);
                    if (k === 'ArrowUp') Game.navSummary(-1);
                    if (['z', 'Z', 'Enter'].includes(k)) document.querySelectorAll('.sum-buttons .confirm-btn')[Input.focus].click();
                }
            },

            handleKey(e) {
                // Global Lock Check (Except for Title Screens)
                if (Battle.uiLocked && !['START', 'CONTINUE', 'NAME'].includes(this.mode)) return;

                const k = e.key;

                // 1. Global Back Button (X)
                if (k === 'x' || k === 'X') {
                    if (['MOVES', 'BAG', 'CONFIRM_RUN'].includes(this.mode)) { Battle.uiToMenu(); return; }
                    if (this.mode === 'PARTY') { if (document.getElementById('party-close-btn').innerText !== "CHOOSE A POKEMON") Battle.uiToMenu(); return; }
                    if (this.mode === 'CONTEXT') { Game.closeContext(); return; }
                    if (this.mode === 'SUMMARY') { Game.closeSummary(); return; }
                }

                // 2. Global Navigation Sound
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(k) && this.mode !== 'NAME' && this.mode !== 'START') {
                    AudioEngine.playSfx('select');
                }

                // 3. Delegate to Specific Handler
                if (this.handlers[this.mode]) {
                    this.handlers[this.mode](k);
                    this.updateVisuals();
                }
            }
        };

        const Game = {
            tempSelection: null, tempSelectionList: [], party: [], activeSlot: 0, enemyMon: null, selectedItemKey: null,
            inventory: { potion: 1, superpotion: 0, hyperpotion: 0, maxpotion: 0, revive: 0, pokeball: 1, greatball: 0, ultraball: 0, masterball: 0 },
            state: 'START', selectedPartyIndex: -1, forcedSwitch: false, previousState: 'SELECTION', wins: 0, bossesDefeated: 0,
            playerName: 'PLAYER', currentSummaryIndex: 0,

            toggleLcd() {
                Input.lcdEnabled = !Input.lcdEnabled;
                const el = document.getElementById('lcd-check');
                const overlay = document.getElementById('lcd-overlay');
                if (Input.lcdEnabled) { el.classList.add('checked'); overlay.classList.add('active'); } else { el.classList.remove('checked'); overlay.classList.remove('active'); }
            },

            toggleRetroMotion() {
                document.body.classList.toggle('retro-motion');
                const el = document.getElementById('motion-check');

                if (document.body.classList.contains('retro-motion')) {
                    el.classList.add('checked');
                } else {
                    el.classList.remove('checked');
                }
            },


            checkSave() {
                const saved = localStorage.getItem('gs_battler_save');
                if (saved) {
                    const data = JSON.parse(saved);
                    document.getElementById('start-screen').classList.add('hidden');
                    document.getElementById('continue-screen').classList.remove('hidden');
                    document.getElementById('save-wins').innerText = data.wins || 0;
                    document.getElementById('save-bosses').innerText = data.bossesDefeated || 0;
                    document.getElementById('save-name').innerText = data.playerName || 'PLAYER';

                    const prevRow = document.getElementById('save-preview');
                    prevRow.innerHTML = '';
                    data.party.forEach((p, i) => {
                        const img = document.createElement('img'); img.src = p.icon; img.className = 'mini-icon';
                        if (p.currentHp <= 0) img.classList.add('fainted');
                        img.onclick = () => this.openSummary(p, 'READ_ONLY');
                        prevRow.appendChild(img);
                    });

                    Input.setMode('CONTINUE');
                } else {
                    document.getElementById('start-screen').classList.add('hidden');
                    this.startNameInput();
                }
            },

            startNameInput() {
                document.getElementById('continue-screen').classList.add('hidden');
                document.getElementById('name-screen').classList.remove('hidden');
                document.getElementById('name-input').focus();
                Input.setMode('NAME');
            },

            confirmName() {
                const val = document.getElementById('name-input').value.trim().toUpperCase();
                this.playerName = val || 'GOLD';
                document.getElementById('name-screen').classList.add('hidden');
                this.newGame();
            },

            loadGame() {
                document.getElementById('continue-screen').classList.add('hidden');

                // 1. NUCLEAR RESET FIRST
                Battle.resetScene();

                // Force Lock immediately so user can't click things while loading
                Battle.uiLocked = true;

                if (this.load()) {
                    // Debug Injection
                    if (typeof DEBUG !== 'undefined' && DEBUG.ENABLED) Object.assign(this.inventory, DEBUG.INVENTORY);

                    // UI Setup
                    document.getElementById('selection-screen').classList.add('hidden');
                    document.getElementById('scene').classList.remove('hidden');
                    document.getElementById('dialog-box').classList.remove('hidden');
                    document.getElementById('streak-box').classList.remove('hidden');
                    document.getElementById('streak-box').innerText = `WINS: ${this.wins}`;

                    // Validate Active Pokemon
                    if (!this.party[this.activeSlot] || this.party[this.activeSlot].currentHp <= 0) {
                        const aliveIdx = this.party.findIndex(p => p.currentHp > 0);
                        if (aliveIdx !== -1) this.activeSlot = aliveIdx;
                        else {
                            this.party.forEach(p => p.currentHp = p.maxHp);
                            this.activeSlot = 0;
                        }
                    }

                    this.state = 'BATTLE';

                    // --- RESUME LOGIC ---
                    if (this.enemyMon && this.enemyMon.currentHp > 0) {

                        // 2. APPLY SAVED BATTLE DATA (Now that resetScene is done)
                        if (this.savedBattleState) {
                            Battle.weather = this.savedBattleState.weather;
                            Battle.delayedMoves = this.savedBattleState.delayedMoves;
                        }

                        // 3. RESTORE WEATHER VISUALS
                        if (Battle.weather.type !== 'none' && WEATHER_FX[Battle.weather.type]) {
                            document.getElementById('scene').style.backgroundColor = WEATHER_FX[Battle.weather.type].color;
                        }

                        // 4. PRELOAD IMAGE (Prevents "Invisible Enemy")
                        const img = new Image();
                        img.onload = () => {
                            const eSprite = document.getElementById('enemy-sprite');
                            eSprite.src = this.enemyMon.frontSprite;

                            // 5. SETUP BATTLE (Skip Intro)
                            Battle.setup(this.party[this.activeSlot], this.enemyMon, false, true);

                            // 6. FORCE VISIBILITY & ANIMATION
                            // We manually override any opacity/transitions to ensure it appears
                            eSprite.style.transition = 'none';
                            eSprite.style.opacity = 1;
                            document.getElementById('player-sprite').style.opacity = 1;
                            document.getElementById('player-hud').classList.add('hud-active');
                            document.getElementById('enemy-hud').classList.add('hud-active');

                            // 7. FADE IN SCENE
                            const scene = document.getElementById('scene');
                            scene.classList.add('anim-fade-in');
                            setTimeout(() => scene.classList.remove('anim-fade-in'), 1000);

                            // 8. UNLOCK UI
                            Battle.typeText(`Resumed battle against\n${this.enemyMon.name}!`, () => {
                                Battle.uiLocked = false;
                                Battle.uiToMenu();
                            });
                        };

                        // Fallback if image errors
                        img.onerror = img.onload;
                        img.src = this.enemyMon.frontSprite;

                    } else {
                        // START FRESH BATTLE
                        this.startNewBattle(true);
                    }
                }
            },

            newGame() {
                localStorage.removeItem('gs_battler_save');
                this.party = [];
                this.wins = 0;
                this.bossesDefeated = 0;
                this.inventory = { potion: 1, superpotion: 0, hyperpotion: 0, maxpotion: 0, revive: 0, pokeball: 1, greatball: 0, ultraball: 0, masterball: 0 };

                // DEBUG: INJECT INVENTORY
                if (DEBUG.ENABLED) Object.assign(this.inventory, DEBUG.INVENTORY);

                this.showSelectionScreen();
            },

            save() {
                // 1. Capture Current Battle State
                // We need to know if a battle is actually active to save the enemy
                const currentEnemy = (this.state === 'BATTLE' && this.enemyMon && this.enemyMon.currentHp > 0) ? this.enemyMon : null;
                const weatherState = (this.state === 'BATTLE') ? Battle.weather : { type: 'none', turns: 0 };
                const delayedState = (this.state === 'BATTLE') ? Battle.delayedMoves : [];

                const saveObj = {
                    party: this.party,
                    inventory: this.inventory,
                    wins: this.wins,
                    bossesDefeated: this.bossesDefeated,
                    activeSlot: this.activeSlot,
                    playerName: this.playerName,

                    // --- NEW: SUSPEND DATA ---
                    enemyMon: currentEnemy,
                    weather: weatherState,
                    delayedMoves: delayedState
                };

                localStorage.setItem('gs_battler_save', JSON.stringify(saveObj));
            },

            load() {
                const saved = localStorage.getItem('gs_battler_save');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);

                        this.party = data.party || [];
                        this.inventory = data.inventory || {};
                        this.wins = data.wins || 0;
                        this.bossesDefeated = data.bossesDefeated || 0;
                        this.activeSlot = data.activeSlot || 0;
                        this.playerName = data.playerName || 'PLAYER';

                        // Restore Suspend Data
                        this.enemyMon = data.enemyMon || null;

                        // --- HOLD BATTLE DATA (Don't apply to Battle object yet) ---
                        this.savedBattleState = {
                            weather: data.weather || { type: 'none', turns: 0 },
                            delayedMoves: data.delayedMoves || []
                        };

                        // Sanitization (Clean up party if NOT resuming a battle)
                        const isResuming = (this.enemyMon !== null);

                        this.party.forEach(p => {
                            p.nextLvlExp = Math.pow(p.level + 1, 3) - Math.pow(p.level, 3);
                            if (!isResuming) {
                                p.volatiles = {};
                                p.rageLevel = 0;
                                if (p.transformBackup) {
                                    p.moves = p.transformBackup.moves;
                                    p.stats = p.transformBackup.stats;
                                    p.types = p.transformBackup.types;
                                    p.frontSprite = p.transformBackup.frontSprite;
                                    p.backSprite = p.transformBackup.backSprite;
                                    p.transformBackup = null;
                                }
                            }
                        });

                        return true;
                    } catch (e) {
                        console.error("Save file corrupted", e);
                        return false;
                    }
                }
                return false;
            },

            resetToTitle() {
                localStorage.removeItem('gs_battler_save');
                this.party = [];
                this.wins = 0;
                this.bossesDefeated = 0;
                this.inventory = { potion: 1, superpotion: 0, hyperpotion: 0, maxpotion: 0, revive: 0, pokeball: 1, greatball: 0, ultraball: 0, masterball: 0 };

                document.getElementById('scene').classList.add('hidden');
                document.getElementById('dialog-box').classList.add('hidden');
                document.getElementById('summary-panel').classList.add('hidden');
                document.getElementById('streak-box').classList.add('hidden');
                document.getElementById('pack-screen').classList.add('hidden');
                document.getElementById('party-screen').classList.add('hidden');
                document.getElementById('action-menu').classList.add('hidden');
                document.getElementById('move-menu').classList.add('hidden');
                document.getElementById('selection-screen').classList.add('hidden');

                document.getElementById('start-screen').classList.remove('hidden');
                Input.setMode('START');
            },

            // Safely go back to menu without deleting save
            returnToTitle() {
                // 1. Stop any battle logic
                this.state = 'START';

                // 2. Hide all Battle UI
                document.getElementById('scene').classList.add('hidden');
                document.getElementById('dialog-box').classList.add('hidden');
                document.getElementById('streak-box').classList.add('hidden');
                document.getElementById('summary-panel').classList.add('hidden');
                document.getElementById('party-screen').classList.add('hidden');
                document.getElementById('pack-screen').classList.add('hidden');
                document.getElementById('action-menu').classList.add('hidden');
                document.getElementById('move-menu').classList.add('hidden');

                // 3. Clean up sprites/animations/TIMERS
                Battle.resetScene();

                // 4. Show Title
                document.getElementById('start-screen').classList.remove('hidden');

                // 5. Reset Input
                Input.setMode('START');
            },

            // Ends battle immediately and finds a new opponent (Roar/Whirlwind effect)
            skipBattle() {
                Battle.cleanup();
                // Ensure party is saved (HP loss etc)
                this.save();

                // Brief pause then start new
                setTimeout(() => {
                    this.startNewBattle(false);
                }, 1000);
            },

            // IN: Game object
            // IN: Game object
            async showSelectionScreen() {
                this.state = 'SELECTION';
                Battle.uiLocked = false;
                Input.setMode('NONE');

                document.getElementById('scene').classList.add('hidden');
                document.getElementById('dialog-box').classList.add('hidden');
                document.getElementById('summary-panel').classList.add('hidden');
                document.getElementById('streak-box').classList.add('hidden');

                const selScreen = document.getElementById('selection-screen');
                selScreen.classList.remove('hidden');

                const textBox = document.getElementById('sel-text-box');
                const table = document.getElementById('lab-table');
                const cursor = document.getElementById('sel-cursor');
                const oldBalls = document.querySelectorAll('.pokeball-select');
                oldBalls.forEach(b => b.remove());

                document.getElementById('sel-preview-img').style.display = 'none';
                document.getElementById('sel-preview-shiny').style.display = 'none';

                cursor.style.display = 'none';
                textBox.innerHTML = '<span class="blink-text">CATHING POKEMON...</span>';

                // 1. Determine IDs (Force ID if set, otherwise Random)
                const ids = [];
                if (DEBUG.ENABLED && DEBUG.PLAYER.ID) { ids.push(DEBUG.PLAYER.ID); }
                while (ids.length < 3) { const r = Math.floor(Math.random() * 251) + 1; if (!ids.includes(r)) ids.push(r); }

                const minWait = new Promise(resolve => setTimeout(resolve, 1000));

                // 2. Fetch Data
                const dataFetch = Promise.all(ids.map((id, index) => {
                    let lvl = 15;
                    let shinyVal = null;
                    const overrides = {};

                    // --- FIX: Check index === 0 ONLY (Removed dependency on DEBUG.PLAYER.ID) ---
                    if (DEBUG.ENABLED && index === 0) {
                        if (DEBUG.PLAYER.LEVEL) lvl = DEBUG.PLAYER.LEVEL;
                        if (DEBUG.PLAYER.SHINY !== null) shinyVal = DEBUG.PLAYER.SHINY;

                        if (DEBUG.PLAYER.STATUS) overrides.status = DEBUG.PLAYER.STATUS;
                        if (DEBUG.PLAYER.STAGES) overrides.stages = DEBUG.PLAYER.STAGES;
                        if (DEBUG.PLAYER.MOVES) overrides.moves = DEBUG.PLAYER.MOVES;
                    }

                    if (shinyVal !== null) overrides.shiny = shinyVal;

                    return API.getPokemon(id, lvl, overrides);
                }));

                const [_, pokemonList] = await Promise.all([minWait, dataFetch]);
                this.tempSelectionList = pokemonList;

                // 3. Render Balls
                this.tempSelectionList.forEach((p, i) => {
                    if (!p) return;
                    const ball = document.createElement('div'); ball.className = 'pokeball-select'; ball.id = `ball-${i}`;
                    ball.onmouseenter = () => { Input.focus = i; Input.updateVisuals(); };
                    ball.onclick = () => { this.selectPokemon(p); };
                    table.appendChild(ball);
                });

                textBox.innerHTML = 'SELECT A POKEMON';
                cursor.style.display = 'block';

                Input.setMode('SELECTION', 0);
            },

            selectPokemon(p) { this.tempSelection = p; this.openSummary(p, 'SELECTION'); },

            openSummary(p, mode) {
                this.previousState = this.state;
                if (mode) this.state = mode; else this.state = 'SUMMARY';
                Input.setMode('SUMMARY', 1);

                // NEW: Correctly find index for Starters
                if (mode === 'SELECTION') {
                    this.currentSummaryIndex = this.tempSelectionList.indexOf(p);
                } else {
                    const foundIdx = this.party.findIndex(mon => mon.id === p.id && mon.exp === p.exp);
                    this.currentSummaryIndex = foundIdx !== -1 ? foundIdx : 0;
                }

                document.getElementById('summary-panel').classList.remove('hidden');
                this.renderSummaryData(p);

                const btn = document.getElementById('btn-action');
                btn.onclick = null;
                const prevBtn = document.getElementById('btn-prev');
                const nextBtn = document.getElementById('btn-next');

                prevBtn.onmouseenter = () => { Input.focus = 0; Input.updateVisuals(); };
                btn.onmouseenter = () => { Input.focus = 1; Input.updateVisuals(); };
                document.getElementById('btn-back-sum').onmouseenter = () => { Input.focus = 2; Input.updateVisuals(); };
                nextBtn.onmouseenter = () => { Input.focus = 3; Input.updateVisuals(); };

                if (this.state === 'SELECTION') {
                    btn.innerText = "I CHOOSE YOU!"; btn.disabled = false;
                    btn.onclick = () => this.confirmSelection();
                    // NEW: Enable navigation buttons for starters
                    prevBtn.disabled = false; nextBtn.disabled = false;
                }
                else if (this.state === 'OVERFLOW') {
                    btn.innerText = "RELEASE"; btn.className = "confirm-btn danger"; btn.disabled = false;
                    btn.onclick = () => this.releasePokemon(this.selectedPartyIndex);
                    prevBtn.disabled = true; nextBtn.disabled = true;
                }
                else if (this.state === 'READ_ONLY') {
                    btn.innerText = "ACTION"; btn.disabled = true;
                    btn.className = "confirm-btn";
                    prevBtn.disabled = false; nextBtn.disabled = false;
                }
                else if (this.state === 'HEAL') {
                    btn.innerText = "USE"; btn.disabled = false; btn.className = "confirm-btn";
                    btn.onclick = () => this.applyItemToPokemon(this.selectedPartyIndex);
                    prevBtn.disabled = true; nextBtn.disabled = true;
                }
                else {
                    btn.innerText = "SHIFT"; btn.disabled = false; btn.className = "confirm-btn";
                    btn.onclick = () => this.partySwitch();
                    prevBtn.disabled = false; nextBtn.disabled = false;
                }
            },

            // IN: Game object
            renderSummaryData(p) {
                AudioEngine.playCry(p.cry);

                // STATUS TEXT LOGIC
                const statusEl = document.getElementById('sum-status-text');

                if (p.currentHp <= 0) {
                    statusEl.innerText = "STATUS/FNT";
                    statusEl.style.color = "#c83828";
                }
                else if (p.status && STATUS_DATA[p.status]) {
                    const s = STATUS_DATA[p.status];
                    statusEl.innerText = `STATUS/${s.name}`;
                    statusEl.style.color = s.color;
                }
                else {
                    statusEl.innerText = "STATUS/OK";
                    statusEl.style.color = "black";
                }

                document.getElementById('sum-name').innerText = p.name;
                document.getElementById('sum-name').style.color = p.isShiny ? "#d8b030" : "black";
                document.getElementById('sum-shiny-icon').style.display = p.isShiny ? "block" : "none";
                document.getElementById('sum-sprite-img').src = p.frontSprite;
                document.getElementById('sum-types').innerHTML = p.types.map(t => `<span class="type-tag">${t.toUpperCase()}</span>`).join('');

                document.getElementById('sum-hp-txt').innerText = `${Math.max(0, p.currentHp)}/${p.maxHp}`;
                const hpPct = Math.min(100, Math.max(0, (p.currentHp / p.maxHp) * 100));
                const hpBar = document.getElementById('sum-hp-bar');
                hpBar.style.width = `${hpPct}%`;
                hpBar.style.background = hpPct > 50 ? "var(--hp-green)" : hpPct > 20 ? "var(--hp-yellow)" : "var(--hp-red)";

                document.getElementById('sum-exp-txt').innerText = `${p.exp}/${p.nextLvlExp}`;
                const expPct = (p.exp / p.nextLvlExp) * 100;
                document.getElementById('sum-exp-bar').style.width = `${Math.min(100, expPct)}%`;

                document.getElementById('summary-stats').innerHTML = `
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:4px;">
                <div>ATK ${p.stats.atk}</div><div>DEF ${p.stats.def}</div>
                <div>SPA ${p.stats.spa}</div><div>SPD ${p.stats.spd}</div>
                <div>SPE ${p.stats.spe}</div>
            </div>
        `;
                document.getElementById('summary-moves').innerHTML = p.moves.map(m => `
            <div class="move-row">
                <span class="move-name">${m.name}</span>
                <div class="move-info-grp">
                    <span class="move-pwr">PWR ${m.power > 0 ? m.power : '-'}</span>
                    <span class="move-type">${m.type.toUpperCase()}</span>
                </div>
            </div>`).join('');
            },

            navSummary(dir) {
                if (this.state === 'HEAL' || this.state === 'OVERFLOW') return;

                // NEW: Choose which list to scroll through
                let list = (this.state === 'SELECTION') ? this.tempSelectionList : this.party;

                let nextIdx = this.currentSummaryIndex + dir;
                if (nextIdx < 0) nextIdx = list.length - 1;
                if (nextIdx >= list.length) nextIdx = 0;

                this.currentSummaryIndex = nextIdx;

                if (this.state === 'PARTY' || this.state === 'SUMMARY') {
                    this.selectedPartyIndex = nextIdx;
                }

                // NEW: Update the temporary selection so "I Choose You" grabs the correct one
                if (this.state === 'SELECTION') {
                    this.tempSelection = list[nextIdx];
                }

                this.renderSummaryData(list[nextIdx]);
            },

            closeSummary() {
                document.getElementById('summary-panel').classList.add('hidden');
                this.state = this.previousState;

                if (this.state === 'SELECTION') {
                    // Return to ball selection, remembering which one we were looking at
                    Input.setMode('SELECTION', this.currentSummaryIndex);
                }
                else if (this.state === 'PARTY') {
                    // NEW: Skip Context menu, go straight to Party List
                    document.getElementById('party-context').classList.add('hidden');
                    Input.setMode('PARTY', this.selectedPartyIndex);
                }
                else if (this.state === 'HEAL') Input.setMode('CONTEXT');
                else if (this.state === 'READ_ONLY') Input.setMode('CONTINUE');
            },

            async confirmSelection() {
                if (!this.tempSelection) return;
                document.getElementById('summary-panel').classList.add('hidden');
                this.party = [this.tempSelection];
                this.activeSlot = 0; this.wins = 0; this.bossesDefeated = 0; this.save();
                document.getElementById('selection-screen').classList.add('hidden');
                document.getElementById('scene').classList.remove('hidden');
                document.getElementById('dialog-box').classList.remove('hidden');
                document.getElementById('streak-box').classList.remove('hidden');
                document.getElementById('streak-box').innerText = "WINS: 0";
                this.state = 'BATTLE'; this.startNewBattle(true);
            },




            async startNewBattle(isFirst = false) {
                // 1. NUCLEAR RESET (Clears old styles/classes)
                Battle.resetScene();

                // 2. GHOST FIX (Force hide immediately)
                const eSprite = document.getElementById('enemy-sprite');
                eSprite.style.opacity = 0;
                eSprite.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"; // Blank placeholder

                Battle.uiLocked = true;
                this.enemyMon = null;

                Battle.typeText("Searching for wild Pokemon...", null, true);

                // 3. LOGIC RESET (Reset Player Volatiles/Stages)
                if (this.party[this.activeSlot]) {
                    const p = this.party[this.activeSlot];
                    p.volatiles = {};
                    p.stages = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, acc: 0, eva: 0 };
                    p.rageLevel = 0;

                    if (typeof DEBUG !== 'undefined' && DEBUG.ENABLED) {
                        if (DEBUG.PLAYER.RAGE !== null) p.rageLevel = DEBUG.PLAYER.RAGE;
                        if (DEBUG.PLAYER.STATUS !== null) p.status = DEBUG.PLAYER.STATUS;
                        if (DEBUG.PLAYER.STAGES !== null) Object.assign(p.stages, DEBUG.PLAYER.STAGES);
                        if (DEBUG.PLAYER.VOLATILES) Object.assign(p.volatiles, DEBUG.PLAYER.VOLATILES);
                    }
                }

                // 4. DETERMINE ENCOUNTER LEVEL
                const levels = this.party.map(p => p.level);
                const avgLvl = levels.reduce((a, b) => a + b, 0) / levels.length;
                const maxLvlInParty = Math.max(...levels);
                const refLevel = Math.ceil((avgLvl + maxLvlInParty) / 2);

                const isStreak = (this.wins > 0 && this.wins % ENCOUNTER_CONFIG.BOSS_STREAK_TRIGGER === 0);
                const bossRate = isStreak ? ENCOUNTER_CONFIG.BOSS_STREAK_CHANCE : ENCOUNTER_CONFIG.BOSS_CHANCE;
                let isBoss = Math.random() < bossRate;

                let minLvl, maxLvl;
                if (isBoss) {
                    minLvl = refLevel + ENCOUNTER_CONFIG.BOSS_LEVEL_MIN;
                    maxLvl = refLevel + ENCOUNTER_CONFIG.BOSS_LEVEL_MAX;
                } else {
                    minLvl = Math.max(1, refLevel + ENCOUNTER_CONFIG.WILD_LEVEL_MIN);
                    maxLvl = Math.max(1, refLevel + ENCOUNTER_CONFIG.WILD_LEVEL_MAX);
                }

                let r = Math.floor(Math.random() * 251) + 1;
                let lvl = Math.floor(Math.random() * (maxLvl - minLvl + 1)) + minLvl;
                let shinyVal = null;

                const enemyOverrides = {};

                if (typeof DEBUG !== 'undefined' && DEBUG.ENABLED) {
                    if (DEBUG.ENEMY.ID) r = DEBUG.ENEMY.ID;
                    if (DEBUG.ENEMY.LEVEL) lvl = DEBUG.ENEMY.LEVEL;
                    if (DEBUG.ENEMY.IS_BOSS !== null) isBoss = DEBUG.ENEMY.IS_BOSS;
                    if (DEBUG.ENEMY.SHINY !== null) shinyVal = DEBUG.ENEMY.SHINY;
                    if (shinyVal !== null) enemyOverrides.shiny = shinyVal;
                    if (DEBUG.ENEMY.STATUS) enemyOverrides.status = DEBUG.ENEMY.STATUS;
                    if (DEBUG.ENEMY.STAGES) enemyOverrides.stages = DEBUG.ENEMY.STAGES;
                }

                if (shinyVal === null && Math.random() < ENCOUNTER_CONFIG.SHINY_CHANCE) enemyOverrides.shiny = true;

                // 5. FETCH DATA (The Critical Part)
                try {
                    this.enemyMon = await API.getPokemon(r, lvl, enemyOverrides);
                } catch (err) {
                    console.error("API Error:", err);
                    // Fallback if API fails
                    this.enemyMon = await API.getPokemon(25, 5, {});
                }

                // Apply Debug Volatiles
                if (typeof DEBUG !== 'undefined' && DEBUG.ENABLED && DEBUG.ENEMY.VOLATILES) {
                    Object.assign(this.enemyMon.volatiles, DEBUG.ENEMY.VOLATILES);
                }

                if (isBoss) {
                    this.enemyMon.isBoss = true;
                    this.enemyMon.name = "BOSS " + this.enemyMon.name;
                    this.enemyMon.isHighTier = true;
                    this.enemyMon.rageLevel = 3;
                    this.enemyMon.maxHp = Math.floor(this.enemyMon.maxHp * 1.5);
                    this.enemyMon.currentHp = this.enemyMon.maxHp;
                }

                if (typeof DEBUG !== 'undefined' && DEBUG.ENABLED && DEBUG.ENEMY.RAGE !== null) {
                    this.enemyMon.rageLevel = DEBUG.ENEMY.RAGE;
                }

                // 6. LOAD IMAGE & START
                const img = new Image();
                img.onload = () => {
                    eSprite.src = this.enemyMon.frontSprite;
                    Battle.setup(this.party[this.activeSlot], this.enemyMon, true, !isFirst);
                };

                // Safety catch: If image fails to load, start anyway so game doesn't freeze
                img.onerror = () => {
                    console.warn("Sprite load error, forcing start.");
                    eSprite.src = this.enemyMon.frontSprite;
                    Battle.setup(this.party[this.activeSlot], this.enemyMon, true, !isFirst);
                };

                img.src = this.enemyMon.frontSprite;

                this.save();
            },

            openParty(forced) {
                if (Battle.uiLocked && !forced && this.state !== 'OVERFLOW' && this.state !== 'HEAL') return;

                // --- NEW: MEMORY LOGIC ---
                // If we are opening the party from the main Battle menu, save the cursor position (e.g., on "PKMN")
                if (this.state === 'BATTLE' && !forced) {
                    Battle.lastMenuIndex = Input.focus;
                }
                // -------------------------

                if (this.state !== 'OVERFLOW' && this.state !== 'HEAL') this.state = 'PARTY';
                this.forcedSwitch = forced;
                document.getElementById('party-screen').classList.remove('hidden');
                document.getElementById('party-context').classList.add('hidden');
                const closeBtn = document.getElementById('party-close-btn');
                const header = document.getElementById('party-header-text');

                // Ensure the Close button highlights when hovered/focused
                closeBtn.onmouseenter = () => { Input.focus = this.party.length; Input.updateVisuals(); };

                if (this.state === 'OVERFLOW') {
                    header.innerText = "PARTY FULL! RELEASE ONE.";
                    closeBtn.innerText = "SELECT TO RELEASE";
                    closeBtn.style.pointerEvents = "none";
                    closeBtn.style.display = "block";
                }
                else if (this.state === 'HEAL') {
                    header.innerText = "USE ON WHICH PKMN?";
                    closeBtn.innerText = "CANCEL";
                    closeBtn.onclick = () => {
                        document.getElementById('party-screen').classList.add('hidden');
                        Battle.openPack();
                    };
                    closeBtn.style.pointerEvents = "auto";
                    closeBtn.style.display = "block";
                }
                else {
                    header.innerText = "POKEMON PARTY";
                    closeBtn.innerText = forced ? "CHOOSE A POKEMON" : "CLOSE [X]"; // Added [X] for clarity
                    closeBtn.onclick = forced ? null : () => Battle.uiToMenu();
                    if (forced) { closeBtn.style.display = "none"; }
                    else { closeBtn.style.display = "block"; closeBtn.style.pointerEvents = "auto"; }
                }
                this.renderParty();
                Input.setMode('PARTY');
            },
            renderParty() {
                const list = document.getElementById('party-list'); list.innerHTML = "";
                this.party.forEach((p, i) => {
                    const div = document.createElement('div'); div.className = 'party-slot';
                    if (p.currentHp <= 0) div.classList.add('fainted');
                    if (i === this.activeSlot && p.currentHp > 0) div.classList.add('active-mon');
                    if (i === 6) div.classList.add('new-catch');
                    const pct = (p.currentHp / p.maxHp) * 100; const color = pct > 50 ? "#48c050" : pct > 20 ? "#d8b030" : "#c83828";
                    div.innerHTML = `<img class="slot-icon" src="${p.icon}"><div class="slot-info"><div class="slot-row"><span>${p.name}</span><span>Lv${p.level}</span></div><div class="slot-row"><div class="mini-hp-bg"><div class="mini-hp-fill" style="width:${pct}%; background:${color}"></div></div><span>${Math.max(0, p.currentHp)}/${p.maxHp}</span></div></div>`;
                    div.onmouseenter = () => { Input.focus = i; Input.updateVisuals(); };
                    div.onclick = () => { if (this.state === 'HEAL') { this.selectedPartyIndex = i; this.openContext(i); } else { this.openContext(i); } };
                    list.appendChild(div);
                });
            },
            openContext(index) {
                this.selectedPartyIndex = index; const ctx = document.getElementById('party-context'); ctx.classList.remove('hidden'); ctx.innerHTML = "";
                const addBtn = (txt, fn, cls = '') => { const b = document.createElement('div'); b.className = `ctx-btn ${cls}`; b.innerText = txt; b.onclick = fn; const idx = ctx.children.length; b.onmouseenter = () => { Input.focus = idx; Input.updateVisuals(); }; ctx.appendChild(b); };
                if (this.state === 'HEAL') { addBtn("USE", () => this.applyItemToPokemon(index)); addBtn("SUMMARY", () => this.partyStats()); addBtn("CLOSE", () => this.closeContext()); }
                else if (this.state === 'OVERFLOW') { addBtn("RELEASE", () => this.releasePokemon(index), "warn"); addBtn("SUMMARY", () => this.partyStats()); addBtn("CLOSE", () => this.closeContext()); }
                else { addBtn("SHIFT", () => this.partySwitch()); addBtn("SUMMARY", () => this.partyStats()); addBtn("CLOSE", () => this.closeContext()); }
                Input.setMode('CONTEXT');
            },
            closeContext() { document.getElementById('party-context').classList.add('hidden'); Input.setMode('PARTY', this.selectedPartyIndex); },

            releasePokemon(index) {
                this.closeContext(); this.closeSummary();
                const releasedMon = this.party[index];
                this.party.splice(index, 1);
                document.getElementById('party-screen').classList.add('hidden');

                if (index < this.activeSlot) { this.activeSlot--; }

                if (index === this.activeSlot) {
                    if (this.activeSlot >= this.party.length) this.activeSlot = this.party.length - 1;
                    Battle.animateSwap(releasedMon, this.party[this.activeSlot], () => { this.handleWin(true); });
                } else {
                    Battle.typeText(`Bye bye, ${releasedMon.name}!`, () => { this.handleWin(true); });
                }
            },

            applyItemToPokemon(index) {
                this.closeContext(); this.closeSummary();
                const p = this.party[index];
                const data = ITEMS[this.selectedItemKey];

                if (data.type === 'revive') {
                    if (p.currentHp > 0) { AudioEngine.playSfx('error'); return; }
                    p.currentHp = Math.floor(p.maxHp / 2);
                }
                else if (data.type === 'heal') {
                    if (p.currentHp <= 0 || p.currentHp >= p.maxHp) { AudioEngine.playSfx('error'); return; }
                    p.currentHp = Math.min(p.maxHp, p.currentHp + data.heal);
                }

                this.inventory[this.selectedItemKey]--; AudioEngine.playSfx('heal'); this.renderParty();
                if (index === this.activeSlot) Battle.updateHUD(p, 'player');
                document.getElementById('party-screen').classList.add('hidden'); document.getElementById('pack-screen').classList.add('hidden'); document.getElementById('action-menu').classList.add('hidden');
                this.state = 'BATTLE'; Battle.typeText(`Used ${data.name} on ${p.name}!`, () => { Battle.endTurnItem(); });
            },

            partySwitch() {
                const idx = this.selectedPartyIndex; const mon = this.party[idx];
                // Safety check: prevent picking fainted mon or self
                if (mon.currentHp <= 0 || idx === this.activeSlot) { AudioEngine.playSfx('error'); return; }

                // --- 1. BATON PASS / INTERRUPT HANDLER ---
                // If the Battle engine is paused waiting for input, we resolve that promise
                // and do NOT start a standard switch sequence.
                if (Battle.userInputPromise) {
                    this.closeContext();
                    this.closeSummary();
                    document.getElementById('party-screen').classList.add('hidden');

                    // Update global active slot state
                    this.activeSlot = idx;

                    // FIX 1: RESET STATE TO BATTLE
                    // This is crucial. If we don't do this, the runQueue loop sees 
                    // the state as 'PARTY' and aborts ('STOP_BATTLE'), causing the freeze.
                    this.state = 'BATTLE';

                    // RESUME THE BATTLE LOGIC with the chosen index
                    Battle.userInputPromise(idx);
                    return;
                }

                // --- 2. STANDARD SWITCH ---
                // Clear stats/volatiles for a normal switch
                this.party[this.activeSlot].rageLevel = 0;
                this.party[this.activeSlot].volatiles = {};
                this.party[this.activeSlot].stages = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, acc: 0, eva: 0 };

                this.closeContext(); this.closeSummary(); document.getElementById('party-screen').classList.add('hidden');
                this.activeSlot = idx; this.state = 'BATTLE';

                if (this.forcedSwitch) {
                    Battle.switchIn(mon, true);
                } else {
                    Battle.performSwitch(mon);
                }
            },

            partyStats() { this.closeContext(); this.openSummary(this.party[this.selectedPartyIndex], this.state); },

            async distributeExp(amount, targetIndices, isBossReward) {
                // 1. Global Message
                if (isBossReward) {
                    AudioEngine.playSfx('exp');
                    await Battle.typeText(`The team gained\n${amount} EXP. Points!`);
                }

                // 2. Loop through targets sequentially
                for (const index of targetIndices) {
                    const p = this.party[index];
                    if (!p || p.currentHp <= 0) continue;

                    // Visuals for the active Pokemon
                    if (index === this.activeSlot) {
                        if (!isBossReward) {
                            // If not boss, we show individual text per mon
                            await Battle.typeText(`${p.name} gained\n${amount} EXP. Points!`);
                        }
                        // Run the bar filling animation
                        await this.gainExpAnim(amount, p);
                    }
                    // Logic for background Pokemon
                    else {
                        if (!isBossReward) {
                            await Battle.typeText(`${p.name} gained\n${amount} EXP. Points!`);
                        }
                        p.exp += amount;
                        if (p.exp >= p.nextLvlExp) {
                            await this.processLevelUp(p);
                        }
                    }
                }

                // 3. Done
                this.finishWin();
            },

            gainExpAnim(amount, p) {
                p.exp += amount;
                Battle.updateHUD(p, 'player');
                const steps = 20; let i = 0;
                return new Promise(resolve => {
                    const loop = setInterval(() => { AudioEngine.playSfx('exp'); i++; if (i >= steps) { clearInterval(loop); check(); } }, 50);
                    const check = async () => {
                        if (p.exp >= p.nextLvlExp) {
                            await this.processLevelUp(p);
                            resolve();
                        } else { resolve(); }
                    }
                });
            },

            processLevelUp(p) {
                return new Promise(async (resolve) => {
                    const startLvl = p.level;

                    // 1. Math Phase
                    while (p.exp >= p.nextLvlExp) {
                        p.exp -= p.nextLvlExp;
                        p.level++;
                        p.nextLvlExp = Math.pow(p.level + 1, 3) - Math.pow(p.level, 3);
                    }

                    // 2. Stat Update Phase (Using the new helper)
                    StatCalc.recalculate(p);

                    // 3. Audio/Visual Phase
                    AudioEngine.playSfx('levelup');

                    if (this.activeSlot === this.party.indexOf(p)) {
                        const hud = document.getElementById('player-hud');
                        hud.classList.remove('hud-flash-blue');
                        void hud.offsetWidth;
                        hud.classList.add('hud-flash-blue');
                        Battle.updateHUD(p, 'player');
                    }

                    // 4. Text Phase
                    const levelsGained = p.level - startLvl;
                    const msg = (levelsGained > 1)
                        ? `${p.name} grew all the way\nto Level ${p.level}!`
                        : `${p.name} grew to Level ${p.level}!`;

                    await Battle.typeText(msg);
                    resolve();
                });
            },

            finishWin() {
                const p = this.party[this.activeSlot];

                // --- HEAL LOGIC ---
                const range = GAME_BALANCE.HEAL_WIN_MAX_PCT - GAME_BALANCE.HEAL_WIN_MIN_PCT;
                const healPct = GAME_BALANCE.HEAL_WIN_MIN_PCT + (Math.random() * range);
                const healAmt = Math.floor(p.maxHp * healPct);

                if (healAmt > 0) {
                    p.currentHp = Math.min(p.maxHp, p.currentHp + healAmt);
                    AudioEngine.playSfx('heal');
                    Battle.updateHUD(p, 'player');
                }

                // --- SEQUENCE CHAIN ---

                // 4. Finalize
                const finalize = () => {
                    this.save();
                    setTimeout(() => this.startNewBattle(false), 1000);
                };

                // 3. Transform Reset
                const checkTransformReset = async () => {
                    if (p.transformBackup) {
                        const sprite = document.getElementById('player-sprite');
                        AudioEngine.playSfx('swoosh');

                        // Flash White
                        sprite.style.transition = 'filter 0.2s';
                        sprite.style.filter = "brightness(10)";
                        await wait(200);

                        // Logic Revert
                        Battle.revertTransform(p);

                        // Update Sprite & HUD
                        sprite.src = p.backSprite;
                        sprite.classList.remove('transformed-sprite');
                        sprite.style.filter = "none";
                        Battle.updateHUD(p, 'player');

                        await Battle.typeText(`${p.name} transformed\nback!`);
                        finalize();
                    } else {
                        finalize();
                    }
                };

                // 2. Rage Reset
                const checkRageReset = () => {
                    if (p.rageLevel > 0) {
                        p.rageLevel = 0;
                        Battle.updateHUD(p, 'player');
                        Battle.typeText(`${p.name} became\ncalm again!`, checkTransformReset);
                    } else {
                        checkTransformReset();
                    }
                };

                // 1. SUBSTITUTE RESET (New)
                const checkSubReset = async () => {
                    if (p.volatiles.substituteHP > 0) {
                        // Visual Reset
                        const sprite = document.getElementById('player-sprite');
                        if (p.volatiles.originalSprite) sprite.src = p.volatiles.originalSprite;

                        p.volatiles.substituteHP = 0;
                        p.volatiles.originalSprite = null;

                        AudioEngine.playSfx('swoosh');
                        await Battle.typeText("The SUBSTITUTE\nfaded away!");

                        // Drop loot logic starts after this
                        checkLoot();
                    } else {
                        checkLoot();
                    }
                };

                // 0. Loot Logic (Moved inside function for cleaner chain)
                const checkLoot = () => {
                    const levelDiff = this.enemyMon.level - p.level;
                    let dropChance = this.enemyMon.isBoss ? LOOT_SYSTEM.DROP_RATE_BOSS : LOOT_SYSTEM.DROP_RATE_WILD;
                    if (levelDiff > 0) dropChance += (levelDiff * 0.05);

                    if (Math.random() < dropChance) {
                        const itemType = this.getLoot(this.enemyMon, levelDiff);
                        this.inventory[itemType]++;
                        AudioEngine.playSfx('funfair');
                        Battle.typeText(`Oh! ${this.enemyMon.name} dropped\na ${ITEMS[itemType].name}.`, checkRageReset);
                    } else {
                        checkRageReset();
                    }
                };

                // START THE CHAIN
                checkSubReset();
            },

            getLoot(enemy, levelDiff = 0) {
                // Debug Force Item
                if (typeof DEBUG !== 'undefined' && DEBUG.ENABLED && DEBUG.LOOT.FORCE_ITEM) {
                    return DEBUG.LOOT.FORCE_ITEM;
                }

                // 1. Calculate "Progress Score"
                const bst = Object.values(enemy.baseStats).reduce((a, b) => a + b, 0);

                // --- NEW: UNDERDOG SCALING ---
                // If levelDiff is positive (e.g. +3 levels), we add a huge bonus to the score.
                // A +3 level difference adds +75 score, which is like having 50 extra wins.
                const underdogBonus = Math.max(0, levelDiff) * 25;

                const score = (enemy.level * 1.5) + (bst / 10) + (this.wins * 1.5) + underdogBonus;

                // 2. Build Weighted Pool
                let totalWeight = 0;
                const pool = LOOT_SYSTEM.TABLE.map(item => {
                    // Weight = Base + (Score * Scaling)
                    let weight = item.base + (score * item.scaling);
                    weight = Math.max(0, weight);
                    totalWeight += weight;
                    return { key: item.key, weight: weight };
                });

                // 3. Roulette Selection
                let random = Math.random() * totalWeight;
                for (let item of pool) {
                    if (random < item.weight) return item.key;
                    random -= item.weight;
                }

                return 'potion';
            },

            // IN: Game object
            async tryMidBattleDrop(enemy) {
                let chance = LOOT_SYSTEM.DROP_RATE_MID_BATTLE;
                if (typeof DEBUG !== 'undefined' && DEBUG.ENABLED && DEBUG.LOOT.MID_BATTLE_RATE !== null) {
                    chance = DEBUG.LOOT.MID_BATTLE_RATE;
                }

                if (Math.random() < chance) {
                    const itemKey = this.getLoot(enemy, 0);
                    this.inventory[itemKey]++;

                    AudioEngine.playSfx('catch_success');

                    // STANDARD TEXT FORMAT
                    await Battle.typeText(`Oh! ${enemy.name} dropped\na ${ITEMS[itemKey].name}.`);
                }
            },

            handleWin(wasCaught) {
                Battle.cleanup(); // <--- FIX: Resets Sprites and Weather

                this.wins++;
                if (this.enemyMon.isBoss) this.bossesDefeated++;
                document.getElementById('streak-box').innerText = `WINS: ${this.wins}`;
                this.state = 'BATTLE';

                if (!wasCaught) {
                    this.enemyMon.currentHp = 0;
                }

                // Calculate Base EXP
                const enemy = this.enemyMon;
                const b = enemy.baseExp;
                const L = enemy.level;
                const Lp = this.party[this.activeSlot].level;

                let rawExp = (b * L) / 5;
                const scale = Math.pow((2 * L + 10) / (L + Lp + 10), 2.5);
                let xpGain = Math.floor(rawExp * scale) + 1;

                if (enemy.isBoss) xpGain = Math.floor(xpGain * 1.5);

                // Apply Catch Penalty
                if (wasCaught) {
                    xpGain = Math.floor(xpGain * 0.8);
                }

                // EXP DISTRIBUTION LOGIC
                let targets, amountPerMon;

                if (enemy.isBoss) {
                    targets = this.party
                        .map((p, index) => ({ p, index }))
                        .filter(item => item.p.currentHp > 0)
                        .map(item => item.index);
                    amountPerMon = xpGain;
                } else {
                    targets = Array.from(Battle.participants);
                    amountPerMon = Math.floor(xpGain / Math.max(1, targets.length));
                }

                Game.distributeExp(amountPerMon, targets, enemy.isBoss);
            },

            handleLoss() {
                // FIX: Do NOT call Battle.cleanup() here if we have survivors.
                // Calling it prematurely resets weather, removes the enemy sprite,
                // and causes the fainted player sprite to pop back up because it 
                // strips the 'anim-faint' class.

                // Ensure Text Box resets from full-width
                const textEl = document.getElementById('text-content');
                textEl.classList.remove('full-width');

                if (this.party.some(p => p.currentHp > 0)) {
                    // Survivors exist: Open party menu directly.
                    // The fainted sprite stays hidden (via anim-faint) until processSwitch handles it.
                    this.openParty(true);
                } else {
                    // Total Defeat: NOW we clean up.
                    Battle.cleanup();

                    document.getElementById('game-boy').style.animation = "flashWhite 0.5s";
                    AudioEngine.playCry(this.party[this.activeSlot].cry);

                    Battle.typeText(`Player is out of Pokemon...`, () => setTimeout(() => {
                        document.getElementById('game-boy').style.animation = "";
                        localStorage.removeItem('gs_battler_save');
                        this.party = [];
                        this.inventory = { potion: 1, superpotion: 0, hyperpotion: 0, maxpotion: 0, revive: 0, pokeball: 1, greatball: 0, ultraball: 0, masterball: 0 };
                        this.showSelectionScreen();
                    }, 2500));
                }
            },
        };

        const Battle = {
            p: null, e: null, textEl: document.getElementById('text-content'), uiLocked: true, typeInterval: null,
            participants: new Set(),
            userInputPromise: null,

            // --- HELPER: FORCE REFLOW ---
            forceReflow(el) { void el.offsetWidth; },



            // --- NEW HELPERS TO PASTE INSIDE Battle { ... } ---

            // 1. Standardized Visual Hit (Handles sprites, sounds, invisible checks, and sub flipping)
            async triggerHitAnim(target, moveType = 'normal') {
                const isPlayer = (target === this.p);
                const sprite = isPlayer ? document.getElementById('player-sprite') : document.getElementById('enemy-sprite');
                const isInvisible = !!target.volatiles.invulnerable;

                // 1. Audio
                // Map specific status types to sounds, default to damage
                const sfx = (moveType === 'paralysis') ? 'electric' : (['burn', 'poison'].includes(moveType) ? 'damage' : moveType);
                // If it's a move type (fire/water), play that, otherwise default damage
                if (SFX_LIB[sfx] || ['fire', 'water', 'ice', 'grass', 'electric', 'psychic'].includes(sfx)) AudioEngine.playSfx(sfx);
                else AudioEngine.playSfx('damage');

                // 2. Screen Flash (Type specific)
                if (['fire', 'water', 'ice', 'grass', 'electric', 'psychic'].includes(moveType)) {
                    const scene = document.getElementById('scene');
                    scene.classList.remove(`fx-${moveType}`);
                    this.forceReflow(scene);
                    scene.classList.add(`fx-${moveType}`);
                    // We don't await the screen flash here, we let it play in parallel with the hit
                    setTimeout(() => scene.classList.remove(`fx-${moveType}`), 600);
                }

                // 3. Sprite Shake (Skip if Digging/Flying)
                if (!isInvisible) {
                    // Check if it is a Substitute (Doll) on the player side to flip the shake animation
                    const isFlipped = sprite.classList.contains('sub-back');
                    const hitClass = isFlipped ? 'anim-hit-flipped' : 'anim-hit';

                    sprite.classList.remove('anim-hit', 'anim-hit-flipped');
                    this.forceReflow(sprite);
                    sprite.classList.add(hitClass);

                    await wait(400); // Wait for shake to finish
                    sprite.classList.remove(hitClass);
                } else {
                    await wait(200); // Small delay even if invisible
                }
            },

            // 2. Standardized Damage Application
            async applyDamage(target, amount, type = 'normal') {
                // A. Handle Substitute
                if (target.volatiles.substituteHP > 0 && type !== 'recoil' && type !== 'poison' && type !== 'burn') {
                    target.volatiles.substituteHP -= amount;
                    await this.triggerHitAnim(target, type); // Hit the doll
                    await this.typeText("The SUBSTITUTE took\ndamage for it!");

                    // Check Break
                    if (target.volatiles.substituteHP <= 0) {
                        target.volatiles.substituteHP = 0;
                        AudioEngine.playSfx('damage');

                        // Poof back logic
                        const isPlayer = (target === this.p);
                        const realSrc = target.volatiles.originalSprite || (isPlayer ? target.backSprite : target.frontSprite);
                        const animPromise = this.performVisualSwap(target, realSrc, false, isPlayer);
                        const textPromise = this.typeText("The SUBSTITUTE\nfaded!");
                        target.volatiles.originalSprite = null;
                        await Promise.all([animPromise, textPromise]);
                    }
                    return;
                }

                // B. Handle Real HP
                await this.triggerHitAnim(target, type); // Visuals
                target.currentHp -= amount; // Math
                this.updateHUD(target, target === this.p ? 'player' : 'enemy'); // UI
            },


            // Standardized Healing Logic
            async applyHeal(target, amount, messageOverride = null) {
                if (target.currentHp >= target.maxHp) return false;

                const oldHp = target.currentHp;
                target.currentHp = Math.min(target.maxHp, target.currentHp + amount);
                const healedAmt = target.currentHp - oldHp;

                // Visuals
                AudioEngine.playSfx('heal');
                this.updateHUD(target, target === this.p ? 'player' : 'enemy');

                // Text
                // Pass 'false' as messageOverride to skip text (for silent heals)
                if (messageOverride !== false) {
                    const msg = messageOverride || `${target.name} regained\nhealth!`;
                    await this.typeText(msg);
                }

                return healedAmt;
            },

            // --- VISUALS ---
            spawnSmoke(x, y) {
                const count = 12;
                for (let i = 0; i < count; i++) {
                    const s = document.createElement('div'); s.className = 'smoke-particle';
                    const angle = (i / count) * 2 * Math.PI;
                    const velocity = 40 + Math.random() * 15;
                    const tx = Math.cos(angle) * velocity;
                    const ty = Math.sin(angle) * velocity;
                    s.style.left = x + 'px'; s.style.top = y + 'px';
                    s.style.setProperty('--tx', tx + 'px'); s.style.setProperty('--ty', ty + 'px');
                    document.getElementById('scene').appendChild(s);
                    setTimeout(() => s.remove(), 600);
                }
            },

            // --- VISUAL SWAP HELPER (Fixed) ---
            // --- NEW HELPER: Handles "Poof" Swaps ---
            async performVisualSwap(mon, targetSrc, isDoll, isPlayerOverride = null) {
                const isPlayer = (isPlayerOverride !== null) ? isPlayerOverride : (mon === this.p);
                const sprite = isPlayer ? document.getElementById('player-sprite') : document.getElementById('enemy-sprite');

                const x = isPlayer ? 60 : 230;
                const y = isPlayer ? 150 : 70;

                AudioEngine.playSfx('ball');
                this.spawnSmoke(x, y);

                sprite.style.opacity = 0;
                await wait(100);

                sprite.src = targetSrc;

                if (isPlayer && isDoll) sprite.classList.add('sub-back');
                else sprite.classList.remove('sub-back');

                sprite.style.opacity = 1;

                // Reset animation class
                sprite.classList.remove('anim-enter');
                this.forceReflow(sprite);
                sprite.classList.add('anim-enter');

                // FIX: Remove the animation class after it finishes
                // This prevents the "Growing" animation from playing again when hit
                setTimeout(() => {
                    sprite.classList.remove('anim-enter');
                }, 600);

                await wait(200);
            },

            async triggerRageAnim(cry) {
                document.getElementById('scene').classList.add('anim-violent');
                if (cry) AudioEngine.playCry(cry);
                AudioEngine.playSfx('rumble');
                await wait(500);
                document.getElementById('scene').classList.remove('anim-violent');
            },

            resetSprite(el) {
                el.classList.remove('anim-faint', 'anim-enter', 'anim-return', 'anim-hit', 'anim-deflect');
                el.style.transform = "scale(1)"; el.style.filter = "none";
                void el.offsetWidth; el.style.opacity = 1;
            },

            // IN: Battle object
            updateHUD(mon, side) {
                const nameSpan = document.getElementById(`${side}-name`);

                // Handle Boss Name Line Breaks
                if (mon.name.startsWith("BOSS ")) nameSpan.innerHTML = mon.name.replace("BOSS ", "BOSS<br>");
                else nameSpan.innerText = mon.name;

                document.getElementById(`${side}-lvl`).innerText = `Lv${mon.level}`;

                const nameContainer = nameSpan.parentElement;

                // --- 1. MANAGE STATUS ICON (PAR, BRN, SLP) ---
                let statusEl = document.getElementById(`${side}-status-icon`);
                if (!statusEl) {
                    statusEl = document.createElement('span');
                    statusEl.id = `${side}-status-icon`;
                    // Style to match the retro look
                    statusEl.style.marginLeft = "4px";
                    statusEl.style.fontSize = "8px";
                    statusEl.style.fontWeight = "bold";
                    statusEl.style.textShadow = "1px 1px 0 #fff";
                    nameContainer.appendChild(statusEl);
                }

                if (mon.status && STATUS_DATA[mon.status]) {
                    statusEl.innerText = STATUS_DATA[mon.status].name;
                    statusEl.style.color = STATUS_DATA[mon.status].color;
                    statusEl.style.display = "inline-block";
                } else {
                    statusEl.style.display = "none";
                }

                // --- 2. MANAGE RAGE ICON (!, !!, 💢) ---
                let rageEl = document.getElementById(`${side}-rage-icon`);
                if (!rageEl) {
                    rageEl = document.createElement('span');
                    rageEl.id = `${side}-rage-icon`;
                    rageEl.className = 'aggro-icon'; // Keep existing animation class
                    nameContainer.appendChild(rageEl);
                }

                // Reset class list to base, then re-add specific rage class
                rageEl.className = 'aggro-icon';
                rageEl.innerText = '';

                if (mon.rageLevel > 0) {
                    if (mon.rageLevel === 1) { rageEl.innerText = '!'; rageEl.classList.add('aggro-1'); }
                    else if (mon.rageLevel === 2) { rageEl.innerText = '!!'; rageEl.classList.add('aggro-2'); }
                    else if (mon.rageLevel >= 3) { rageEl.innerText = '💢'; rageEl.classList.add('aggro-3'); }
                    rageEl.style.display = "inline-block";
                } else {
                    rageEl.style.display = "none";
                }

                // --- 3. HP BARS ---
                const pct = (Math.max(0, mon.currentHp) / mon.maxHp) * 100;
                const bar = document.getElementById(`${side}-hp-bar`);
                bar.style.width = Math.max(0, pct) + "%";
                bar.style.backgroundColor = pct > 50 ? "#48c050" : pct > 20 ? "#d8b030" : "#c83828";

                if (side === 'player') {
                    document.getElementById('player-hp-text').innerText = `${Math.floor(Math.max(0, mon.currentHp))}/${mon.maxHp}`;
                    const expPct = (mon.exp / mon.nextLvlExp) * 100;
                    document.getElementById('player-exp-bar').style.width = Math.min(100, expPct) + "%";
                }
            },

            // --- TEXT ENGINE ---
            typeText(text, cb, fast = false) {
                return new Promise(resolve => {
                    const el = this.textEl;
                    clearInterval(this.typeInterval);
                    el.innerHTML = "";
                    if (document.getElementById('action-menu').classList.contains('hidden')) el.classList.add('full-width');
                    else el.classList.remove('full-width');

                    let i = 0;
                    this.typeInterval = setInterval(() => {
                        const char = text.charAt(i);
                        if (char === '\n') el.innerHTML += '<br>'; else el.innerHTML += char;
                        i++;
                        if (i >= text.length) {
                            clearInterval(this.typeInterval);
                            setTimeout(() => {
                                if (cb && typeof cb === 'function') cb();
                                resolve();
                            }, 1000);
                        }
                    }, fast ? 10 : 20);
                });
            },

            revertTransform(mon) {
                if (mon && mon.transformBackup) {
                    // Restore Data
                    mon.moves = mon.transformBackup.moves;
                    mon.stats = mon.transformBackup.stats;
                    mon.types = mon.transformBackup.types;
                    mon.stages = mon.transformBackup.stages; // Usually stages reset on switch anyway, but good for safety
                    mon.frontSprite = mon.transformBackup.frontSprite;
                    mon.backSprite = mon.transformBackup.backSprite;

                    // Clear Backup
                    mon.transformBackup = null;
                }
            },

            // --- Weather ---
            weather: { type: 'none', turns: 0 },

            // 1. The New "Nuclear" Reset (Clears everything)
            resetScene() {
                clearInterval(this.typeInterval);
                this.typeInterval = null;

                const pSprite = document.getElementById('player-sprite');
                const eSprite = document.getElementById('enemy-sprite');
                const scene = document.getElementById('scene');
                const textEl = document.getElementById('text-content');

                const isTransformed = pSprite.classList.contains('transformed-sprite');

                // Cleanup Classes
                pSprite.className = 'sprite';
                eSprite.className = 'sprite';
                scene.className = 'scene';

                // FIX: Remove Substitute Flip
                pSprite.classList.remove('sub-back');

                if (isTransformed) pSprite.classList.add('transformed-sprite');

                // Reset Styles
                pSprite.style = "transition: none;";
                eSprite.style = "opacity: 0; transition: none;";

                scene.style = "";
                textEl.innerHTML = "";
                textEl.classList.remove('full-width');

                void pSprite.offsetWidth;
                void eSprite.offsetWidth;

                this.weather = { type: 'none', turns: 0 };
                this.delayedMoves = [];
                this.uiLocked = false;

                // FIX: Clear Input Promise if resetting to avoid stuck menus
                this.userInputPromise = null;
            },

            // 2. The Legacy Wrapper (Keeps existing calls working)
            cleanup() {
                this.resetScene();
            },

            setWeather(type) {
                this.weather = { type: type, turns: 5 };
                const overlay = document.getElementById('scene');
                if (WEATHER_FX[type]) {
                    overlay.style.backgroundColor = WEATHER_FX[type].color;
                    this.typeText(WEATHER_FX[type].msg);
                } else {
                    overlay.style.backgroundColor = "";
                    this.typeText("The skies cleared.");
                }
            },

            // --- SETUP ---
            setup(player, enemy, playIntro, skipPlayerAnim) {
                this.p = player; this.e = enemy;
                this.participants.clear(); this.participants.add(Game.activeSlot);

                // Only reset delayed moves if we are NOT resuming (playIntro = true usually implies new battle)
                if (playIntro) this.delayedMoves = [];

                const pSprite = document.getElementById('player-sprite');
                const eSprite = document.getElementById('enemy-sprite');

                pSprite.style.transition = 'none';
                eSprite.style.transition = 'none';

                this.resetSprite(eSprite);

                // RESUME FIX: If not playing intro, keep opacity 1
                if (!playIntro) eSprite.style.opacity = 1;
                else eSprite.style.opacity = 0;

                pSprite.src = player.backSprite;

                if (!playIntro || skipPlayerAnim) pSprite.style.opacity = 1; else pSprite.style.opacity = 0;

                this.forceReflow(pSprite);
                this.forceReflow(eSprite);

                pSprite.style.transition = 'opacity 0.2s, transform 0.4s, filter 0.4s';
                eSprite.style.transition = 'opacity 0.2s, transform 0.4s, filter 0.4s';

                if (!skipPlayerAnim) document.getElementById('player-hud').classList.remove('hud-active');
                document.getElementById('enemy-hud').classList.remove('hud-active');

                this.updateHUD(player, 'player'); this.updateHUD(enemy, 'enemy');

                const nameEl = document.getElementById('enemy-name');
                if (enemy.isBoss) nameEl.classList.add('boss-name'); else nameEl.classList.remove('boss-name');

                ['opt-fight', 'opt-pkmn', 'opt-pack', 'opt-run'].forEach((id, i) => {
                    document.getElementById(id).onmouseenter = () => { if (!this.uiLocked) { Input.focus = i; Input.updateVisuals(); } };
                });

                // Only run the sequence if it's a new encounter
                if (playIntro) {
                    this.startEncounterSequence(player, enemy, playIntro, skipPlayerAnim, eSprite);
                }
            },

            async startEncounterSequence(player, enemy, playIntro, skipPlayerAnim, eSprite) {
                this.buildMoveMenu(); clearInterval(this.typeInterval); this.textEl.innerHTML = "";

                if (playIntro) {
                    // Setup instant invisibility
                    eSprite.style.transition = 'none';
                    eSprite.style.filter = 'brightness(0)';
                    this.forceReflow(eSprite);
                    eSprite.style.transition = 'opacity 0.2s, transform 0.4s, filter 0.4s';

                    await sleep(500); // Hardcoded small buffer for browser render

                    // 1. Appear as Silhouette
                    eSprite.style.opacity = 1;

                    const introText = enemy.isBoss ? `The ${enemy.name}\nappeared!` : `Wild ${enemy.name}\nappeared!`;
                    const textAnim = this.typeText(introText);

                    // 2. Wait (Controlled by Constant)
                    await sleep(ANIM.INTRO_SILHOUETTE);

                    // 3. Reveal
                    eSprite.style.filter = 'none';

                    if (enemy.isBoss) {
                        if (enemy.cry) AudioEngine.playCry(enemy.cry);
                        AudioEngine.playSfx('rumble');
                        document.getElementById('scene').classList.add('boss-intro');
                        await sleep(ANIM.INTRO_BOSS_RUMBLE);
                        document.getElementById('scene').classList.remove('boss-intro');
                    } else {
                        if (enemy.cry) AudioEngine.playCry(enemy.cry);
                    }

                    await sleep(ANIM.INTRO_REVEAL_DELAY);

                    // 5. Enemy HUD In
                    AudioEngine.playSfx('swoosh');
                    document.getElementById('enemy-hud').classList.add('hud-active');

                    await textAnim; // Ensure text finishes

                    if (enemy.isShiny) { this.playSparkle('enemy'); await sleep(1000); }

                    await sleep(ANIM.INTRO_PLAYER_WAIT);

                    if (skipPlayerAnim) {
                        AudioEngine.playSfx('swoosh');
                        document.getElementById('player-hud').classList.add('hud-active');
                        this.uiLocked = false; this.uiToMenu();
                    } else {
                        await this.typeText(`Go! ${player.name}!`);

                        AudioEngine.playSfx('swoosh');
                        await this.triggerPlayerEntry(player);

                        // 6. Player HUD In
                        AudioEngine.playSfx('swoosh');
                        document.getElementById('player-hud').classList.add('hud-active');

                        if (player.isShiny) { this.playSparkle('player'); await sleep(1200); }
                        this.uiLocked = false; this.uiToMenu();
                    }
                } else {
                    // Resume Game
                    eSprite.style.filter = 'none';
                    eSprite.style.opacity = 1;
                    this.uiLocked = false; this.uiToMenu();
                }
            },

            async triggerPlayerEntry(mon) {
                AudioEngine.playSfx('ball');
                const sprite = document.getElementById('player-sprite');

                sprite.style.transition = 'none';
                this.resetSprite(sprite);
                sprite.style.opacity = 0;
                this.forceReflow(sprite);

                sprite.style.transition = 'opacity 0.2s, transform 0.4s, filter 0.4s';
                sprite.classList.add('anim-enter');
                this.spawnSmoke(60, 150);

                await wait(200);

                // Only play cry if not a doll (Optional polish, but playing cry is usually fine)
                if (mon.cry) AudioEngine.playCry(mon.cry);

                await wait(1000);

                sprite.classList.remove('anim-enter');
                sprite.style.opacity = 1;
            },

            endTurnItem() {
                this.uiLocked = true;
                document.getElementById('action-menu').classList.add('hidden');

                let eMove;
                if (this.e.moves && this.e.moves.length > 0) {
                    eMove = this.e.moves[Math.floor(Math.random() * this.e.moves.length)];
                } else {
                    eMove = { name: "STRUGGLE", type: "normal", power: 50, accuracy: 100, priority: 0 };
                }

                const eAction = {
                    type: 'ATTACK', user: this.e, target: this.p, move: eMove,
                    speed: this.e.stats.spe, priority: 0, isPlayer: false
                };
                this.runQueue([eAction]).then((res) => {
                    if (res === 'STOP_BATTLE') return;
                    this.uiLocked = false;
                    this.uiToMenu();
                });
            },

            // --- TURN EXECUTION ---


            // IN: Battle object (Add these as new methods)

            // 1. Check if Pokemon can move (Sleep, Freeze, Para, Confusion)
            async checkCanMove(mon, isPlayer) {
                // 0. FLINCH (Volatile - resets immediately)
                if (mon.volatiles.flinch) {
                    mon.volatiles.flinch = false;
                    await this.typeText(`${mon.name} flinched!`);
                    return false;
                }

                // 1. FREEZE
                if (mon.status === 'frz') {
                    if (Math.random() < 0.2) {
                        mon.status = null;
                        this.updateHUD(mon, isPlayer ? 'player' : 'enemy');
                        await this.typeText(`${mon.name} thawed out!`);
                        return true;
                    }
                    await this.typeText(`${mon.name} is\nfrozen solid!`);
                    return false;
                }

                // 2. SLEEP
                if (mon.status === 'slp') {
                    mon.volatiles.sleepTurns = (mon.volatiles.sleepTurns || Math.floor(Math.random() * 3) + 1) - 1;
                    if (mon.volatiles.sleepTurns <= 0) {
                        mon.status = null;
                        this.updateHUD(mon, isPlayer ? 'player' : 'enemy');
                        await this.typeText(`${mon.name} woke up!`);
                        return true;
                    }
                    await this.typeText(`${mon.name} is\nfast asleep!`);
                    return false;
                }

                // 3. PARALYSIS
                if (mon.status === 'par' && Math.random() < 0.25) {
                    await this.typeText(`${mon.name} is paralyzed!\nIt can't move!`);
                    return false;
                }

                // 4. CONFUSION
                if (mon.volatiles.confused > 0) {
                    mon.volatiles.confused--;
                    if (mon.volatiles.confused === 0) {
                        this.updateHUD(mon, isPlayer ? 'player' : 'enemy');
                        await this.typeText(`${mon.name} snapped\nout of confusion!`);
                        return true;
                    }

                    await this.typeText(`${mon.name} is\nconfused!`);

                    // 33% chance to hit self
                    if (Math.random() < 0.33) {
                        await this.typeText("It hurt itself in\nits confusion!");

                        // Standard Gen 2 Confusion Damage Formula (Power 40)
                        const dmg = Math.floor((((2 * mon.level / 5 + 2) * 40 * mon.stats.atk / mon.stats.def) / 50) + 2);

                        // USE HELPER: This handles sound, shake, HP update, and HUD flash
                        await this.applyDamage(mon, dmg, 'normal');

                        return false;
                    }
                }

                return true;
            },

            // 2. Apply End of Turn Damage (Burn/Poison/Weather effects)
            async processEndTurnEffects(mon, isPlayer) {
                if (mon.currentHp <= 0) return;
                const isInvisible = !!mon.volatiles.invulnerable;

                // 1. WEATHER DAMAGE
                if (this.weather.type === 'sand' || this.weather.type === 'hail') {
                    let takesDamage = true;
                    // Immunity checks
                    if (this.weather.type === 'sand' && (mon.types.includes('rock') || mon.types.includes('ground') || mon.types.includes('steel'))) takesDamage = false;
                    if (this.weather.type === 'hail' && mon.types.includes('ice')) takesDamage = false;

                    if (takesDamage) {
                        await wait(400);
                        const msg = this.weather.type === 'sand' ? "is buffeted\nby the sandstorm!" : "is pelted\nby hail!";
                        await this.typeText(`${mon.name} ${msg}`);

                        const dmg = Math.max(1, Math.floor(mon.maxHp / 16));
                        // Use Helper (weather type triggers standard damage sound)
                        await this.applyDamage(mon, dmg, 'normal');
                        if (mon.currentHp <= 0) return;
                    }
                }

                // 2. STATUS DAMAGE
                if (mon.status === 'brn' || mon.status === 'psn') {
                    await wait(400);

                    // Visual Status Flash (Purple/Red silhouette)
                    if (!isInvisible) {
                        const animClass = mon.status === 'brn' ? 'status-anim-brn' : 'status-anim-psn';
                        const sprite = isPlayer ? document.getElementById('player-sprite') : document.getElementById('enemy-sprite');
                        sprite.classList.add(animClass);
                        await wait(600);
                        sprite.classList.remove(animClass);
                    }

                    await this.typeText(`${mon.name} ${STATUS_DATA[mon.status].msg}`);

                    const dmg = Math.floor(mon.maxHp / 8);
                    // Use Helper (pass 'burn' or 'poison' to trigger specific logic/sounds if needed)
                    await this.applyDamage(mon, Math.max(1, dmg), mon.status === 'brn' ? 'burn' : 'poison');
                }
            },

            // 3. Apply Stat Changes (Buffs/Debuffs)
            async applyStatChanges(target, changes, isPlayer) {
                const sprite = isPlayer ? document.getElementById('player-sprite') : document.getElementById('enemy-sprite');

                // --- SUBSTITUTE IMMUNITY ---
                // Substitute blocks NEGATIVE stat changes from sources other than self.
                const hasSub = target.volatiles.substituteHP > 0;

                for (let c of changes) {
                    // If Substitute exists and it's a debuff (change < 0), ignore it.
                    // (Exceptions exist in newer gens like Intimidate, but for moves this is accurate)
                    if (hasSub && c.change < 0) {
                        await this.typeText(`${target.name} is protected\nby the SUBSTITUTE!`);
                        continue;
                    }

                    const stat = c.stat.name.replace('special-attack', 'spa').replace('special-defense', 'spd').replace('attack', 'atk').replace('defense', 'def').replace('speed', 'spe');
                    const change = c.change;

                    if (target.stages[stat] === 6 && change > 0) {
                        await this.typeText(`${target.name}'s ${stat.toUpperCase()}\nwon't go higher!`);
                        continue;
                    }
                    if (target.stages[stat] === -6 && change < 0) {
                        await this.typeText(`${target.name}'s ${stat.toUpperCase()}\nwon't go lower!`);
                        continue;
                    }

                    target.stages[stat] = Math.min(6, Math.max(-6, target.stages[stat] + change));

                    const dir = change > 0 ? "rose!" : "fell!";
                    const deg = Math.abs(change) > 1 ? "sharply " : "";

                    const animClass = change > 0 ? 'anim-stat-up' : 'anim-stat-down';

                    sprite.classList.add(animClass);

                    if (change > 0) AudioEngine.playSfx('heal');
                    else AudioEngine.playSfx('damage');

                    await wait(800);
                    sprite.classList.remove(animClass);

                    await this.typeText(`${target.name}'s ${stat.toUpperCase()}\n${deg}${dir}`);
                }
            },

            // 4. Apply Status Ailment
            async applyStatus(target, ailment, isPlayerTarget) {
                // 1. Substitute Block
                // Substitute blocks status unless it's sound-based (ignored for simplicity) or generated by the user
                if (target.volatiles.substituteHP > 0 && ailment !== 'confusion') {
                    await this.typeText("But it failed!");
                    return false;
                }

                // 2. Handle Volatiles (Confusion)
                if (ailment === 'confusion') {
                    if (target.volatiles.confused) {
                        await this.typeText(`${target.name} is\nalready confused!`);
                        return false;
                    }
                    const scene = document.getElementById('scene');
                    scene.classList.add('fx-psychic');
                    await wait(400);
                    scene.classList.remove('fx-psychic');

                    target.volatiles.confused = Math.floor(Math.random() * 3) + 2;
                    await this.typeText(`${target.name} became\nconfused!`);
                    return true;
                }

                // 3. Handle Major Statuses
                if (target.status) return false;

                if (['burn', 'poison', 'paralysis', 'freeze', 'sleep'].includes(ailment)) {
                    const map = { 'burn': 'brn', 'poison': 'psn', 'paralysis': 'par', 'freeze': 'frz', 'sleep': 'slp' };

                    const sprite = isPlayerTarget ? document.getElementById('player-sprite') : document.getElementById('enemy-sprite');

                    let animClass = '';
                    if (ailment === 'burn') animClass = 'status-anim-brn';
                    else if (ailment === 'poison') animClass = 'status-anim-psn';
                    else if (ailment === 'freeze') animClass = 'status-anim-frz';
                    else if (ailment === 'paralysis') animClass = 'status-anim-par';
                    else if (ailment === 'sleep') animClass = 'status-anim-slp';

                    if (animClass) {
                        sprite.classList.add(animClass);
                        AudioEngine.playSfx(ailment === 'paralysis' ? 'electric' : 'damage');
                        await wait(600);
                        sprite.classList.remove(animClass);
                    }

                    target.status = map[ailment];
                    this.updateHUD(target, isPlayerTarget ? 'player' : 'enemy');

                    let msg = `${target.name} was\n${ailment}ed!`;
                    if (ailment === 'sleep') msg = `${target.name} fell\nasleep!`;
                    if (ailment === 'freeze') msg = `${target.name} was\nfrozen solid!`;
                    if (ailment === 'paralysis') msg = `${target.name} is\nparalyzed!`;

                    AudioEngine.playSfx('clank');
                    await this.typeText(msg);
                    return true;
                }
                return false;
            },

            async processDelayedMoves() {
                if (this.delayedMoves.length === 0) return;

                // Filter out moves that are finished
                const activeMoves = [];

                for (const item of this.delayedMoves) {
                    item.turns--;
                    if (item.turns > 0) {
                        activeMoves.push(item);
                    } else {
                        // IT'S TIME!
                        await this.typeText(`${item.user.name} foresaw\nan attack!`);

                        // Execute damage phase
                        // We force the move type to 'typeless' logic for Gen 2 Future Sight if desired, 
                        // or just run standard damage logic.
                        await this.executeDamagePhase(item.user, item.target, item.moveData, item.isPlayer);
                    }
                }

                this.delayedMoves = activeMoves;
            },

            async performTurn(playerMove) {
                if (this.uiLocked) return;

                // Safety: If charging, force the queued move
                if (this.p.volatiles.charging && this.p.volatiles.queuedMove) {
                    playerMove = this.p.volatiles.queuedMove;
                }

                // 1. INSTANT UI FEEDBACK
                // Hide menus immediately so the selection box doesn't linger
                this.uiLocked = true;
                document.getElementById('action-menu').classList.add('hidden');
                document.getElementById('move-menu').classList.add('hidden');
                Input.setMode('NONE');

                // 2. BUILD QUEUE (No text here)
                try {
                    const pAction = {
                        type: 'ATTACK', user: this.p, target: this.e, move: playerMove,
                        speed: this.p.stats.spe, priority: playerMove.priority || 0, isPlayer: true
                    };

                    // --- ENEMY AI ---
                    let enemyMove;
                    if (this.e.volatiles.recharging) {
                        enemyMove = { name: "Recharging", priority: 0 };
                    }
                    else if (this.e.volatiles.charging && this.e.volatiles.queuedMove) {
                        enemyMove = this.e.volatiles.queuedMove;
                    }
                    else if (this.e.moves && this.e.moves.length > 0) {
                        enemyMove = this.e.moves[Math.floor(Math.random() * this.e.moves.length)];
                    } else {
                        enemyMove = { name: "STRUGGLE", type: "normal", power: 50, accuracy: 100, priority: 0 };
                    }

                    const eAction = {
                        type: 'ATTACK', user: this.e, target: this.p, move: enemyMove,
                        speed: this.e.stats.spe, priority: enemyMove.priority || 0, isPlayer: false
                    };

                    // Speed Tie / Priority Sorting
                    const queue = [pAction, eAction].sort((a, b) => {
                        if (a.priority !== b.priority) return b.priority - a.priority;
                        if (a.speed !== b.speed) return b.speed - a.speed;
                        return Math.random() - 0.5;
                    });

                    const result = await this.runQueue(queue);
                    if (result === 'STOP_BATTLE') return;

                    if (Game.state === 'BATTLE' && this.p.currentHp > 0 && this.e.currentHp > 0) {
                        this.uiLocked = false; this.uiToMenu();
                    }
                } catch (err) {
                    console.error("Battle Error:", err);
                    this.cleanup();
                    this.uiLocked = false;
                    this.uiToMenu();
                }
            },

            async performSwitch(newMon) {
                // FIX: Prevent double-clicks
                if (this.uiLocked) return;

                try {
                    this.uiLocked = true;
                    document.getElementById('action-menu').classList.add('hidden');

                    const swapAction = { type: 'SWITCH', user: this.p, newMon: newMon, priority: 6, isPlayer: true };

                    let eMove;
                    if (this.e.moves && this.e.moves.length > 0) {
                        eMove = this.e.moves[Math.floor(Math.random() * this.e.moves.length)];
                    } else {
                        eMove = { name: "STRUGGLE", type: "normal", power: 50, accuracy: 100, priority: 0 };
                    }

                    const eAction = {
                        type: 'ATTACK', user: this.e, target: this.p, move: eMove,
                        speed: this.e.stats.spe, priority: 0, isPlayer: false
                    };

                    const result = await this.runQueue([swapAction, eAction]);
                    if (result === 'STOP_BATTLE') return;

                    if (Game.state === 'BATTLE' && this.p.currentHp > 0 && this.e.currentHp > 0) {
                        this.uiLocked = false; this.uiToMenu();
                    }
                } catch (err) {
                    console.error("Switch Error:", err);
                    this.uiLocked = false;
                    this.uiToMenu();
                }
            },

            async performItem(itemKey) {
                // FIX: Prevent double-clicks
                if (this.uiLocked) return;

                try {
                    this.uiLocked = true;
                    Input.setMode('NONE');
                    document.getElementById('pack-screen').classList.add('hidden');
                    document.getElementById('action-menu').classList.add('hidden');

                    const itemAction = { type: 'ITEM', user: this.p, item: itemKey, priority: 6, isPlayer: true };

                    let eMove;
                    if (this.e.moves && this.e.moves.length > 0) {
                        eMove = this.e.moves[Math.floor(Math.random() * this.e.moves.length)];
                    } else {
                        eMove = { name: "STRUGGLE", type: "normal", power: 50, accuracy: 100, priority: 0 };
                    }

                    const eAction = {
                        type: 'ATTACK', user: this.e, target: this.p, move: eMove,
                        speed: this.e.stats.spe, priority: 0, isPlayer: false
                    };

                    const result = await this.runQueue([itemAction, eAction]);

                    if (result === 'STOP_BATTLE') return;

                    if (Game.state === 'BATTLE' && this.p.currentHp > 0 && this.e.currentHp > 0) {
                        this.uiLocked = false; this.uiToMenu();
                    }
                } catch (err) {
                    console.error("Item Error:", err);
                    this.uiLocked = false;
                    this.uiToMenu();
                }
            },

            async performRun() {
                this.uiLocked = true;
                document.getElementById('action-menu').classList.add('hidden');

                // Play Sound
                AudioEngine.playSfx('run');

                // Updated Text
                await this.typeText("Got away safely!");

                // 1. SAVE FIRST (Suspend State)
                Game.save();

                // 2. STOP ENGINE
                Game.state = 'START';

                await wait(500);

                // 3. EXIT TO TITLE
                Game.returnToTitle();
            },

            // --- QUEUE EXECUTION ---
            async runQueue(queue) {
                // 1. PROCESS ACTIONS
                for (const action of queue) {
                    if (Game.state !== 'BATTLE') return 'STOP_BATTLE';
                    if (action.type !== 'SWITCH' && action.user.currentHp <= 0) continue;
                    if (action.type === 'ATTACK') action.target = action.isPlayer ? this.e : this.p;

                    const result = await this.executeAction(action);
                    if (result === 'STOP_BATTLE') return 'STOP_BATTLE';

                    if (this.p.currentHp <= 0) { await this.handleFaint(this.p, true); return; }
                    if (this.e.currentHp <= 0) { await this.handleFaint(this.e, false); return; }
                }

                // 2. END OF TURN SEQUENCE
                if (Game.state === 'BATTLE') {
                    // A. Delayed Moves (Future Sight / Wish / Yawn)
                    await this.processDelayedMoves();
                    if (this.p.currentHp <= 0) { await this.handleFaint(this.p, true); return; }
                    if (this.e.currentHp <= 0) { await this.handleFaint(this.e, false); return; }

                    // B. Status Effects
                    await this.processEndTurnEffects(this.p, true);
                    if (this.p.currentHp <= 0) { await this.handleFaint(this.p, true); return; }

                    await this.processEndTurnEffects(this.e, false);
                    if (this.e.currentHp <= 0) { await this.handleFaint(this.e, false); return; }

                    // C. Weather
                    if (this.weather.type !== 'none') {
                        this.weather.turns--;
                        if (this.weather.turns <= 0) {
                            await this.typeText("The weather cleared.");
                            this.setWeather('none');
                        } else {
                            const fx = WEATHER_FX[this.weather.type];
                            if (fx && fx.continue) await this.typeText(fx.continue);
                        }
                    }
                }
            },

            async executeAction(action) {
                switch (action.type) {
                    case 'ATTACK': await this.processAttack(action.user, action.target, action.move); break;
                    case 'SWITCH': await this.processSwitch(action.newMon); break;
                    case 'ITEM': return await this.processItem(action.item);
                }
            },

            async processSwitch(newMon, isFaintSwap = false) {
                document.getElementById('action-menu').classList.add('hidden');
                const eSprite = document.getElementById('enemy-sprite');
                eSprite.style.opacity = 1;

                await sleep(ANIM.SWITCH_STABILIZE);
                const sprite = document.getElementById('player-sprite');

                // --- BATON PASS LOGIC ---
                const isBP = this.batonPassActive;
                this.batonPassActive = false;

                // 1. Save/Reset Data
                if (this.p.transformBackup && !isBP) {
                    this.revertTransform(this.p);
                }

                if (!isFaintSwap) {
                    let msg = `Come back,\n${this.p.name}!`;
                    if (isBP) msg = `${this.p.name} passed\nthe baton!`;

                    await this.typeText(msg);
                    await sleep(ANIM.TEXT_READ_PAUSE);

                    AudioEngine.playSfx('swoosh');
                    document.getElementById('player-hud').classList.remove('hud-active');

                    AudioEngine.playSfx('ball');
                    sprite.classList.add('anim-return');
                    this.spawnSmoke(60, 150);
                    await sleep(ANIM.SWITCH_RETURN_ANIM);
                } else {
                    sprite.style.transition = 'none';
                    sprite.style.opacity = 0;
                    sprite.classList.remove('anim-faint');
                    this.forceReflow(sprite);
                }

                sprite.classList.remove('transformed-sprite');
                sprite.classList.remove('sub-back');

                // 2. Apply New Pokemon Data
                if (isBP) {
                    newMon.stages = { ...this.p.stages };
                    if (this.p.volatiles.substituteHP > 0) {
                        newMon.volatiles.substituteHP = this.p.volatiles.substituteHP;
                        newMon.volatiles.originalSprite = newMon.backSprite;
                    }
                    newMon.volatiles.focusEnergy = this.p.volatiles.focusEnergy;
                } else {
                    newMon.volatiles = {};
                    newMon.stages = { atk: 0, def: 0, spa: 0, spd: 0, spe: 0, acc: 0, eva: 0 };
                }

                this.p = newMon;
                this.participants.add(Game.activeSlot);

                this.updateHUD(newMon, 'player'); this.buildMoveMenu();

                // --- HIDE BEFORE SOURCE CHANGE (ANTI-FLICKER) ---
                sprite.style.transition = 'none';
                sprite.style.opacity = 0;
                sprite.classList.remove('anim-return');
                this.forceReflow(sprite);

                // --- 3. SHOW REAL POKEMON FIRST ---
                sprite.src = newMon.backSprite;

                await this.typeText(`Go! ${newMon.name}!`);

                AudioEngine.playSfx('swoosh');
                await this.triggerPlayerEntry(newMon);

                AudioEngine.playSfx('swoosh');
                document.getElementById('player-hud').classList.add('hud-active');

                if (newMon.isShiny) { this.playSparkle('player'); await sleep(1000); }

                // --- BATON PASS: LATE SUBSTITUTE ARRIVAL ---
                if (newMon.volatiles.substituteHP > 0) {
                    await wait(500);
                    const dollSrc = "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/substitute.png";
                    await this.performVisualSwap(newMon, dollSrc, true, true);
                }
            },

            async processItem(itemKey) {
                const data = ITEMS[itemKey];

                // 1. Decrement Inventory
                if (Game.inventory[itemKey] > 0) {
                    Game.inventory[itemKey]--;
                } else {
                    // Safety catch if UI didn't block it
                    await this.typeText("You don't have any!");
                    return 'CONTINUE';
                }

                // 2. Logic Switch based on Item Type

                // --- POKEBALLS ---
                if (data.type === 'ball') {
                    await this.typeText(`You threw a\n${data.name}!`);
                    return await this.attemptCatch(itemKey);
                }

                // --- HEALING ITEMS (Potions) ---
                else if (data.type === 'heal') {
                    await this.typeText(`You used a\n${data.name}!`);
                    await this.applyHeal(this.p, data.heal);
                }

                // --- STATUS HEALS (Future Proofing for Full Heals/Antidotes) ---
                // You can add { type: 'status_heal', condition: 'psn' } to your ITEMS list later
                else if (data.type === 'status_heal') {
                    await this.typeText(`You used a\n${data.name}!`);
                    if (this.p.status === data.condition || data.condition === 'all') {
                        this.p.status = null;
                        this.updateHUD(this.p, 'player');
                        AudioEngine.playSfx('heal');
                        await this.typeText(`${this.p.name} was\ncured!`);
                    } else {
                        await this.typeText("It had no effect.");
                    }
                }

                // --- BATTLE STAT BOOSTERS (Future Proofing for X Attack, etc) ---
                // You can add { type: 'buff', stat: 'atk', val: 1 } to your ITEMS list later
                else if (data.type === 'buff') {
                    await this.typeText(`You used an\n${data.name}!`);
                    await this.applyStatChanges(this.p, [{ stat: { name: data.stat }, change: data.val }], true);
                }

                // --- REVIVES (Fails on active Pokemon) ---
                else if (data.type === 'revive') {
                    await this.typeText(`You used a\n${data.name}!`);
                    await this.typeText("But it failed!");
                    // Optional: Refund item if failed
                    Game.inventory[itemKey]++;
                }

                return 'CONTINUE';
            },


            getTypeEffectiveness(moveType, targetTypes) {
                let mod = 1;
                targetTypes.forEach(t => {
                    // Safe check for the type chart
                    if (TYPE_CHART[moveType] && TYPE_CHART[moveType][t] !== undefined) {
                        mod *= TYPE_CHART[moveType][t];
                    }
                });
                return mod;
            },

            async attemptCatch(ballKey) {
                const ballData = ITEMS[ballKey];

                // 1. CHECK BOSS/RAGE DEFLECTION
                if (this.e.isBoss && ballKey !== 'masterball') {
                    let deflectChance = (this.e.rageLevel || 0) * GAME_BALANCE.RAGE_DEFLECT_CHANCE;

                    if (this.e.rageLevel > 0 && Math.random() < deflectChance) {
                        // REMOVED DUPLICATE TEXT HERE
                        AudioEngine.playSfx('throw');

                        // Short deflect animation
                        await sleep(500);
                        AudioEngine.playSfx('clank');
                        document.getElementById('enemy-sprite').classList.add('anim-deflect');
                        await sleep(300);
                        document.getElementById('enemy-sprite').classList.remove('anim-deflect');

                        await this.typeText("The BOSS deflected\nthe Ball!");
                        return 'CONTINUE';
                    }
                }

                // REMOVED DUPLICATE TEXT HERE
                AudioEngine.playSfx('throw');

                const ball = document.createElement('div'); ball.className = `pokeball-anim ${ballData.css}`;
                ball.style.animation = "captureThrow 0.6s ease-out forwards";
                document.getElementById('scene').appendChild(ball);

                await sleep(ANIM.THROW_ANIM);

                const eSprite = document.getElementById('enemy-sprite');
                eSprite.style.transition = 'transform 0.4s, filter 0.4s';
                eSprite.style.filter = 'brightness(0) invert(1)';
                eSprite.style.transform = 'scale(0)';

                this.spawnSmoke(230, 70);
                AudioEngine.playSfx('catch_success');
                ball.style.animation = "captureShake 1.0s ease-in-out infinite";

                const catchRate = ballData.rate * GAME_BALANCE.CATCH_RATE_MODIFIER;
                let catchProb = ((3 * this.e.maxHp - 2 * this.e.currentHp) / (3 * this.e.maxHp)) * catchRate;
                if (ballKey === 'pokeball') catchProb *= 0.5;
                const isCaught = Math.random() < catchProb;

                let shakes = 0;
                const maxShakes = 3;

                while (shakes < maxShakes) {
                    await sleep(ANIM.CATCH_SHAKE_DELAY);
                    shakes++;
                    AudioEngine.playSfx('catch_click');
                    if (!isCaught && Math.random() > 0.5) break;
                }

                if (isCaught && shakes === maxShakes) {
                    AudioEngine.playSfx('swoosh');
                    document.getElementById('enemy-hud').classList.remove('hud-active');

                    AudioEngine.playSfx('heal');

                    ball.style.animation = 'none';
                    ball.style.transform = 'translate(215px, -100px)';
                    ball.classList.add('pokeball-caught');

                    Game.state = 'CAUGHT_ANIM';
                    await this.typeText(`Gotcha! ${this.e.name} was caught!`);
                    document.getElementById('scene').removeChild(ball);

                    this.e.rageLevel = 0;
                    this.e.failedCatches = 0;
                    this.e.currentHp = Math.min(this.e.maxHp, this.e.currentHp + Math.floor(this.e.maxHp * 0.2));

                    Game.party.push(this.e);

                    if (Game.party.length > 6) {
                        Game.state = 'OVERFLOW';
                        await this.typeText(`Party is full!\nSelect PKMN to release.`);
                        await sleep(ANIM.OVERFLOW_WARNING);
                        Game.openParty(true);
                    }
                    else {
                        await this.typeText(`${this.e.name} was added\nto the party!`);
                        Game.handleWin(true);
                    }
                    return 'STOP_BATTLE';
                } else {
                    ball.style.display = 'none';
                    eSprite.style.filter = 'none';
                    eSprite.style.transform = 'scale(1)';

                    this.spawnSmoke(230, 70);
                    AudioEngine.playSfx('ball');

                    if (this.e.cry) AudioEngine.playCry(this.e.cry);

                    this.e.failedCatches++;
                    let gainedRage = false;

                    const rageProb = GAME_BALANCE.RAGE_TRIGGER_CHANCE + (this.e.failedCatches * 0.1);

                    if (Math.random() < rageProb) {
                        this.e.rageLevel = Math.min(3, (this.e.rageLevel || 0) + 1);
                        this.updateHUD(this.e, 'enemy');
                        gainedRage = true;
                    }

                    await this.typeText(`Shoot! It was so close!`);
                    document.getElementById('scene').removeChild(ball);

                    if (gainedRage) {
                        await this.triggerRageAnim(this.e.cry);
                        await this.typeText("It's getting aggressive!");
                    }
                    return 'CONTINUE';
                }
            },

            async processAttack(attacker, defender, move) {
                const isPlayer = (attacker === this.p);
                const logic = MOVE_LOGIC[move.id] || {};
                const sprite = isPlayer ? document.getElementById('player-sprite') : document.getElementById('enemy-sprite');

                // 1. RECHARGE CHECK
                if (attacker.volatiles.recharging) {
                    attacker.volatiles.recharging = false;
                    await this.typeText(`${attacker.name} must\nrecharge!`);
                    return;
                }

                // 2. CAN MOVE CHECK
                const canMove = await this.checkCanMove(attacker, isPlayer);
                if (!canMove) {
                    if (attacker.volatiles.charging) {
                        attacker.volatiles.charging = false;
                        attacker.volatiles.queuedMove = null;
                        attacker.volatiles.invulnerable = null;
                        sprite.style.opacity = 1;
                        if (logic.invuln) await this.typeText(`${attacker.name} crashed\ndown!`);
                    }
                    return;
                }

                // 3. PROTECT RESET
                if (logic.type !== 'protect') {
                    attacker.volatiles.protected = false;
                }

                // --- SUBSTITUTE ATTACK SEQUENCE (POOF OUT) ---
                const hasSub = attacker.volatiles.substituteHP > 0;

                // FIX: Removed "move.category !== 'status'"
                // Now ANY move that targets the opponent (or field) will make the Pokemon pop out
                if (hasSub && move.target !== 'user') {
                    const realSrc = isPlayer ? attacker.backSprite : attacker.frontSprite;
                    await this.performVisualSwap(attacker, realSrc, false, isPlayer);
                }
                // -------------------------------------------

                // 4. STANDARD MOVE TEXT
                await this.typeText(`${attacker.name} used\n${move.name}!`);

                const checkInvulnHit = async () => {
                    if (move.target === 'user' || move.target === 'users-field') return true;
                    if (defender.volatiles.invulnerable) {
                        const inv = defender.volatiles.invulnerable;
                        let hits = false;
                        if (inv === 'digging' && (move.name === 'EARTHQUAKE' || move.name === 'MAGNITUDE' || move.name === 'FISSURE')) hits = true;
                        if (inv === 'flying' && (move.name === 'THUNDER' || move.name === 'GUST' || move.name === 'TWISTER' || move.name === 'SKY UPPERCUT')) hits = true;
                        if (inv === 'diving' && (move.name === 'SURF' || move.name === 'WHIRLPOOL')) hits = true;
                        if (!hits) {
                            await this.typeText(`${defender.name} avoided\nthe attack!`);
                            return false;
                        }
                    }
                    return true;
                };

                // Helper to put the doll back
                const restoreSub = async () => {
                    const currentMon = isPlayer ? this.p : this.e;

                    if (currentMon.volatiles.substituteHP > 0) {
                        const dollSrc = "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/substitute.png";

                        if (sprite.src === dollSrc) return;

                        await this.performVisualSwap(currentMon, dollSrc, true, isPlayer);
                    }
                };

                // 5. CHARGE EXECUTION (Turn 2)
                if (attacker.volatiles.charging) {
                    attacker.volatiles.charging = false;
                    attacker.volatiles.invulnerable = null;
                    sprite.style.opacity = 1;

                    if (await checkInvulnHit() === false) { await restoreSub(); return; }

                    if (defender.volatiles.protected && move.target !== 'user') {
                        await this.typeText(`${defender.name} protected\nitself!`);
                        await restoreSub();
                        return;
                    }

                    await this.executeDamagePhase(attacker, defender, move, isPlayer);
                    await restoreSub();
                    return;
                }

                // 6. START NEW MOVE (Logic)
                if (logic.type === 'protect') {
                    if (attacker.volatiles.protected) {
                        await this.typeText("But it failed!");
                        attacker.volatiles.protected = false;
                    } else {
                        attacker.volatiles.protected = true;
                        await this.typeText(`${attacker.name} protected\nitself!`);
                        AudioEngine.playSfx('clank');
                    }
                    await restoreSub();
                    return;
                }

                if (logic.type === 'charge') {
                    if (logic.weatherSkip && this.weather.type === logic.weatherSkip) {
                        // Continue
                    } else {
                        attacker.volatiles.charging = true;
                        attacker.volatiles.queuedMove = move;
                        if (logic.invuln) attacker.volatiles.invulnerable = logic.invuln;

                        await wait(400);
                        if (logic.hide) { AudioEngine.playSfx('swoosh'); sprite.style.opacity = 0; await wait(250); }

                        await this.typeText(`${attacker.name}\n${logic.msg}`);
                        if (logic.buff) await this.applyStatChanges(attacker, [{ stat: { name: logic.buff.stat }, change: logic.buff.val }], isPlayer);
                        await restoreSub();
                        return;
                    }
                }

                // 7. DEFENDER PROTECT
                if (defender.volatiles.protected && move.target !== 'user') {
                    await this.typeText(`${defender.name} protected\nitself!`);
                    await restoreSub();
                    return;
                }

                // 8. INVULNERABILITY
                if (await checkInvulnHit() === false) {
                    if (move.name === 'SELF-DESTRUCT' || move.name === 'EXPLOSION') {
                        await this.handleMoveSideEffects(attacker, defender, move, isPlayer, false);
                    }
                    await restoreSub();
                    return;
                }

                // 9. ACCURACY
                let acc = move.accuracy;
                if (attacker.stages.acc) acc *= STAGE_MULT[attacker.stages.acc];
                if (defender.stages.eva) acc /= STAGE_MULT[defender.stages.eva];

                if (move.target !== 'user' && acc !== null && move.accuracy !== 0 && Math.random() * 100 > acc) {
                    AudioEngine.playSfx('miss');
                    await this.typeText(`${attacker.name}'s attack\nmissed!`);

                    if (Math.random() < GAME_BALANCE.RAGE_TRIGGER_CHANCE) {
                        attacker.rageLevel = Math.min(3, (attacker.rageLevel || 0) + 1);
                        this.updateHUD(attacker, isPlayer ? 'player' : 'enemy');
                        await this.triggerRageAnim(attacker.cry);
                        await this.typeText(`${attacker.name}'s RAGE\nis building!`);
                    }
                    if (move.name === 'SELF-DESTRUCT' || move.name === 'EXPLOSION') await this.handleMoveSideEffects(attacker, defender, move, isPlayer, false);

                    await restoreSub();
                    return;
                }

                // 10. EXECUTE
                await this.executeDamagePhase(attacker, defender, move, isPlayer);

                // 11. RECHARGE FLAG
                if (logic.type === 'recharge') attacker.volatiles.recharging = true;

                // --- SUBSTITUTE ATTACK SEQUENCE (POOF IN) ---
                await restoreSub();
            },

            // 1. THE DIRECTOR: Decides what logic to run based on move type
            async executeDamagePhase(attacker, defender, move, isPlayer) {
                let didSomething = false;
                let moveImmune = false;
                let explicitlyFailed = false;

                // Setup Weather Modifier
                let weatherMod = 1;
                if (this.weather.type === 'sun' && (move.type === 'fire' || move.type === 'water')) weatherMod = (move.type === 'fire' ? 1.5 : 0.5);
                if (this.weather.type === 'rain' && (move.type === 'water' || move.type === 'fire')) weatherMod = (move.type === 'water' ? 1.5 : 0.5);

                // 1. CHECK MOVE_DEX CONDITIONS
                const special = MOVE_DEX[move.name];
                if (special && special.condition) {
                    if (!special.condition(defender)) {
                        await this.typeText("But it failed!");
                        return;
                    }
                }

                // 2. EXECUTE MAIN LOGIC
                let allowSideEffects = false;

                if (move.category !== 'status') {
                    // --- DAMAGING MOVES ---
                    const result = await this.handleDamageSequence(attacker, defender, move, isPlayer, weatherMod);
                    didSomething = result.success;
                    moveImmune = result.immune;
                    // Only run side effects (e.g. Ancient Power stats) if damage landed
                    allowSideEffects = didSomething && !moveImmune;
                } else {
                    // --- STATUS MOVES ---
                    // We check Type Immunity here (e.g. Thunder Wave vs Ground)
                    const result = await this.handleStatusMove(attacker, defender, move);

                    if (result === 'IMMUNE') {
                        moveImmune = true;
                        didSomething = false;
                    } else if (result === 'FAIL') {
                        explicitlyFailed = true;
                        didSomething = false;
                    } else if (result === true) {
                        didSomething = true; // Weather or Unique Move handled itself (e.g. Rest)
                    } else {
                        // Result is false. This means it's a standard Status Move (Thunder Wave/Growl).
                        // It passed immunity checks, so we MUST allow side effects to attempt to run.
                        allowSideEffects = true;
                    }
                }

                // 3. SIDE EFFECTS (The actual Status Application)
                // We pass 'allowSideEffects'. If true, it attempts to apply Paralysis/Poison/Etc.
                const sideEffectsHappened = await this.handleMoveSideEffects(attacker, defender, move, isPlayer, allowSideEffects);

                if (sideEffectsHappened) didSomething = true;

                // 4. FAILURE MESSAGE
                // If nothing happened, and it wasn't immune (already printed "No effect"), print "But it failed!"
                if (!didSomething && !moveImmune && !explicitlyFailed) {
                    await this.typeText("But it failed!");
                }
            },

            // 2. THE COMBO HANDLER: Manages Multi-hits, Drop RNG, and Attacker Rage
            async handleDamageSequence(attacker, defender, move, isPlayer, weatherMod) {
                let didSomething = false;
                // Removed "isImmune" variable as it wasn't being used effectively in the return,
                // but we keep the logic consistent with your previous version.

                let hitCount = 1;

                if (move.min_hits && move.max_hits) {
                    hitCount = Math.floor(Math.random() * (move.max_hits - move.min_hits + 1)) + move.min_hits;
                } else if (move.min_hits) hitCount = move.min_hits;

                let hitsLanded = 0;
                let lastHitDamage = 0;
                let storedText = null;

                for (let i = 0; i < hitCount; i++) {
                    if (defender.currentHp <= 0 || attacker.currentHp <= 0) break;

                    const result = this.calcDamage(attacker, defender, move);
                    result.damage = Math.floor(result.damage * weatherMod);
                    if (result.damage > 0) lastHitDamage = result.damage;

                    if (i === 0) {
                        if (result.desc === 'failed') return { success: false, immune: false };

                        // TYPE IMMUNITY CHECK
                        if (result.eff === 0) {
                            await this.typeText("It had no effect!");
                            return { success: false, immune: true };
                        }

                        if (result.isCrit) storedText = "A critical hit!";
                        else if (result.desc) storedText = result.desc; // e.g. "It's super effective!"
                    }

                    if (result.damage > 0) {
                        didSomething = true;
                        await this.resolveSingleHit(attacker, defender, move, result.damage, isPlayer, i === 0, result);
                        hitsLanded++;
                    }
                }

                if (hitsLanded > 1) { await this.typeText(`Hit ${hitsLanded} time(s)!`); await wait(500); }

                // 1. Show Effectiveness / Crit Text FIRST
                if (storedText) await this.typeText(storedText);

                // 2. Check for Loot Drop
                if (hitsLanded > 0 && isPlayer && defender.currentHp > 0) await Game.tryMidBattleDrop(defender);

                // 3. NEW LOCATION: Check Defender Rage (Now happens after text)
                if (hitsLanded > 0 && defender.currentHp > 0 && defender.rageLevel !== undefined && defender.rageLevel < 3) {
                    let chance = GAME_BALANCE.RAGE_TRIGGER_CHANCE;
                    if ((defender.currentHp / defender.maxHp) < 0.5) chance += 0.25;

                    if (Math.random() < chance) {
                        defender.rageLevel++;
                        this.updateHUD(defender, isPlayer ? 'enemy' : 'player');

                        // Full Animation
                        await this.triggerRageAnim(defender.cry);
                        await this.typeText(`${defender.name}'s RAGE\nis building!`);
                    }
                }

                // 4. Check Attacker Rage (Multi-hit fury)
                if (didSomething) await this.handleAttackerRage(attacker, defender, move, lastHitDamage, isPlayer);

                return { success: didSomething, immune: false };
            },

            // 3. THE BRAWLER: Handles Visuals, Audio, and HP for ONE hit
            async resolveSingleHit(attacker, defender, move, damage, isPlayer, isFirstHit, result) {
                // 1. Initial Audio Cues (Crit/Super Effective)
                if (isFirstHit) {
                    if (result.isCrit) AudioEngine.playSfx('crit');
                    else if (result.eff > 1) AudioEngine.playSfx('super_effective');
                    else if (result.eff < 1) AudioEngine.playSfx('not_very_effective');
                }

                // 2. Apply the Damage (Handles Sprite Shake, Substitute, HP Update, HUD)
                await this.applyDamage(defender, damage, move.type);

                // 3. Handle Rage Building
                if (defender.currentHp > 0 && defender.rageLevel !== undefined && defender.rageLevel < 3) {
                    let chance = GAME_BALANCE.RAGE_TRIGGER_CHANCE;
                    if ((defender.currentHp / defender.maxHp) < 0.5) chance += 0.25;

                    if (Math.random() < chance) {
                        defender.rageLevel++;
                        this.updateHUD(defender, isPlayer ? 'enemy' : 'player');
                        await this.triggerRageAnim(defender.cry);
                        await this.typeText(`${defender.name}'s RAGE\nis building!`);
                    }
                }

                // 4. Handle Draining / Recoil
                if (move.meta && move.meta.drain) {
                    await wait(500);
                    const amount = Math.max(1, Math.floor(damage * (Math.abs(move.meta.drain) / 100)));

                    if (move.meta.drain < 0) {
                        // Recoil
                        await this.typeText(`${attacker.name} is hit\nwith recoil!`);
                        await this.applyDamage(attacker, amount, 'recoil'); // Use helper!
                    } else {
                        // Drain Heal
                        // We pass the custom text as the 3rd argument
                        await this.applyHeal(attacker, amount, `${defender.name} had its\nenergy drained!`);
                    }
                }
            },



            // 4. THE RAGE HANDLER: Handles angry Pokemon attacking again
            async handleAttackerRage(attacker, defender, move, baseDmg, isPlayer) {
                const rage = attacker.rageLevel || 0;
                if (attacker.currentHp <= 0 || rage === 0) return;

                // Determine bonus hits based on Rage Level
                let extraHits = 0;
                if (Math.random() < (rage * GAME_BALANCE.RAGE_MULTIHIT_BASE)) {
                    extraHits = (rage === 3 && Math.random() < 0.5) ? 2 : 1;
                }

                if (extraHits > 0) {
                    for (let j = 0; j < extraHits; j++) {
                        if (defender.currentHp <= 0 || attacker.currentHp <= 0) break;

                        await this.triggerRageAnim(attacker.cry);
                        let msg = j === 1 ? "ULTRA ANGRY!" : "FULL OF RAGE!";
                        await this.typeText(`${attacker.name} is\n${msg}`);
                        await this.typeText(`${attacker.name} used\n${move.name} again!`);

                        // Calculate reduced damage for extra hits
                        const dmgMod = (j === 0) ? 0.8 : 0.5;
                        const extraDmg = Math.max(1, Math.floor(baseDmg * dmgMod));

                        // USE HELPER: Handles the hit on the defender
                        await this.applyDamage(defender, extraDmg, move.type);

                        // Rage Recoil Check
                        if (Math.random() < GAME_BALANCE.RAGE_RECOIL_CHANCE) {
                            await wait(500);
                            await this.typeText(`${attacker.name} is hit\nwith recoil!`);
                            const recoil = Math.max(1, Math.floor(baseDmg * GAME_BALANCE.RAGE_RECOIL_DMG));

                            // USE HELPER: Handles the recoil on the attacker
                            await this.applyDamage(attacker, recoil, 'recoil');
                        }
                    }
                }
            },

            // 5. THE SIDE-EFFECTS HANDLER: Stats, Status, and Weather

            async handleStatusMove(attacker, defender, move) {
                // 1. TYPE IMMUNITY CHECK (Use new Helper)
                // Example: Thunder Wave (Electric) vs Ground type = 0 effectiveness
                const typeMod = this.getTypeEffectiveness(move.type, defender.types);

                if (typeMod === 0) {
                    await this.typeText("It had no effect!");
                    return 'IMMUNE';
                }

                // 2. CHECK MOVE_DEX (Unique Logic)
                // Handles specific script logic for Transform, Substitute, Rest, etc.
                const special = MOVE_DEX[move.name];
                if (special && special.isUnique) {
                    // Run the custom function. If it returns true, success.
                    // If it returns false (e.g. Yawn when already asleep), return 'FAIL'.
                    return await special.onHit(this, attacker, defender) ? true : 'FAIL';
                }

                // 3. WEATHER MOVES
                const wMoves = { 'SUNNY DAY': 'sun', 'RAIN DANCE': 'rain', 'SANDSTORM': 'sand', 'HAIL': 'hail' };
                if (wMoves[move.name]) {
                    AudioEngine.playSfx('swoosh');
                    await wait(300);
                    this.setWeather(wMoves[move.name]);
                    await wait(1500);
                    return true; // Success (did something)
                }

                // 4. FALLTHROUGH
                // If we reach here, it's a standard status move (like Growl or Poison Powder).
                // Returning false tells the engine: "Go ahead and check handleMoveSideEffects to apply the stats/status."
                return false;
            },

            async handleMoveSideEffects(attacker, defender, move, isPlayer, prevActionSuccess) {
                // 1. SELF-DESTRUCT / EXPLOSION (Priority Check)
                // FIX: Check 'move.id' (raw API name) to avoid dash/space formatting issues.
                // 'self-destruct' matches regardless of how we display it in text.
                if (move.id === 'self-destruct' || move.id === 'explosion') {
                    // Explicitly set HP to 0
                    attacker.currentHp = 0;
                    this.updateHUD(attacker, isPlayer ? 'player' : 'enemy');

                    const sprite = isPlayer ? document.getElementById('player-sprite') : document.getElementById('enemy-sprite');

                    // Force faint animation immediately so visual feedback is instant
                    sprite.classList.add('anim-faint');

                    // We manually add the faint message here or let handleFaint do it?
                    // handleFaint handles the text/logic. We just update the visual state here.
                    // We can add flavor text though.
                    // (Wait for move text to finish reading in processAttack before this runs)

                    return true;
                }

                // CRITICAL CHECK: For all other effects, stop if move failed
                if (!prevActionSuccess) return false;

                let didSomething = false;

                // 2. Stat Changes
                if (move.stat_changes && move.stat_changes.length > 0) {
                    let chance = move.stat_chance === 0 ? 100 : move.stat_chance;
                    if (Math.random() * 100 < chance) {
                        let target = (move.target === 'user' || move.target === 'users-field') ? attacker : defender;
                        if (move.category !== 'status') {
                            const first = move.stat_changes[0];
                            if (first && first.change > 0) target = attacker; else target = defender;
                        }
                        if (target.currentHp > 0) {
                            await this.applyStatChanges(target, move.stat_changes, target === this.p);
                            didSomething = true;
                        }
                    }
                }

                // 3. Status & Flinch
                if (move.meta) {
                    if (defender.currentHp > 0 && move.meta.flinch_chance > 0) {
                        if (Math.random() * 100 < move.meta.flinch_chance) {
                            defender.volatiles.flinch = true;
                        }
                    }
                    if (defender.currentHp > 0 && move.meta.ailment && move.meta.ailment.name !== 'none') {
                        let chance = move.meta.ailment_chance === 0 ? 100 : move.meta.ailment_chance;
                        if (Math.random() * 100 < chance) {
                            let success = false;
                            if (move.meta.ailment.name === 'confusion') success = await this.applyStatus(defender, 'confusion', !isPlayer);
                            else success = await this.applyStatus(defender, move.meta.ailment.name, !isPlayer);
                            if (success) didSomething = true;
                        }
                    }
                }

                return didSomething;
            },

            async handleFaint(mon, isPlayer) {
                mon.currentHp = 0;
                mon.rageLevel = 0;

                const sprite = isPlayer ? document.getElementById('player-sprite') : document.getElementById('enemy-sprite');
                const hud = document.getElementById(isPlayer ? 'player-hud' : 'enemy-hud');

                if (mon.cry) AudioEngine.playCry(mon.cry);

                await sleep(ANIM.FAINT_PRE_DELAY);

                sprite.style.opacity = 1;
                sprite.classList.add('anim-faint');
                AudioEngine.playSfx('swoosh');

                setTimeout(() => {
                    AudioEngine.playSfx('swoosh');
                    hud.classList.remove('hud-active');
                }, ANIM.HUD_SLIDE_DELAY);

                // Logic Revert (Data only)
                const name = mon.transformBackup ? mon.transformBackup.name : mon.name;
                this.revertTransform(mon);

                // NOTE: We removed the line `sprite.classList.remove('transformed-sprite')`
                // The sprite now stays gray while fainting.

                await this.typeText(`${name}\nfainted!`);
                await sleep(ANIM.FAINT_POST_DELAY);

                const textEl = document.getElementById('text-content');
                textEl.classList.remove('full-width');

                if (isPlayer) Game.handleLoss();
                else Game.handleWin(false);
            },


            calcDamage(attacker, defender, move) {
                // 1. TYPE EFFECTIVENESS (Use new Helper)
                const typeMod = this.getTypeEffectiveness(move.type, defender.types);
                if (typeMod === 0) return { damage: 0, desc: null, eff: 0 };

                // 2. SPECIAL MOVE LOGIC (Fixed Damage, OHKO, etc from MOVE_DEX)
                const special = MOVE_DEX[move.name];
                if (special) {
                    if (special.fixedDamage) return { damage: special.fixedDamage, desc: null, eff: 1, isCrit: false };
                    if (special.damageCallback) return { damage: special.damageCallback(attacker, defender), desc: null, eff: 1, isCrit: false };
                    if (special.ohko) {
                        if (defender.level > attacker.level) return { damage: 0, desc: "failed", eff: 0 };
                        return { damage: defender.currentHp, desc: "It's a One-Hit KO!", eff: 1, isCrit: false };
                    }
                }

                // 3. BASE POWER CHECK
                if (!move.power) return { damage: 0, desc: "failed", eff: typeMod };

                // 4. STAT CALCULATION (Attacker vs Defender)
                const isSpecial = move.category === 'special';

                // Select correct stats
                let A = isSpecial ? attacker.stats.spa : attacker.stats.atk;
                let D = isSpecial ? defender.stats.spd : defender.stats.def;

                // Select correct stages
                const atkStage = isSpecial ? attacker.stages.spa : attacker.stages.atk;
                const defStage = isSpecial ? defender.stages.spd : defender.stages.def;

                // Apply Stage Multipliers
                A = Math.floor(A * STAGE_MULT[atkStage]);
                D = Math.floor(D * STAGE_MULT[defStage]);

                // Burn Check (Halves physical attack)
                if (attacker.status === 'brn' && !isSpecial) A = Math.floor(A * 0.5);

                // 5. THE DAMAGE FORMULA (Gen 2 Approximation)
                let dmg = Math.floor(Math.floor(Math.floor(2 * attacker.level / 5 + 2) * move.power * A / D) / 50) + 2;

                // 6. MODIFIERS
                // STAB
                if (attacker.types.includes(move.type)) dmg = Math.floor(dmg * 1.5);

                // Type Effectiveness
                dmg = Math.floor(dmg * typeMod);

                // Critical Hit
                let isCrit = false;
                let critChance = 0.0625; // 1/16
                if (move.meta && move.meta.crit_rate >= 1) critChance = 0.125;
                if (move.meta && move.meta.crit_rate >= 2) critChance = 0.50;
                if (attacker.isBoss) critChance = Math.max(critChance, GAME_BALANCE.CRIT_CHANCE_BOSS);

                if (Math.random() < critChance) { isCrit = true; dmg *= 2; }

                // Random Variance (0.85 to 1.0)
                const variance = GAME_BALANCE.DAMAGE_VARIANCE_MIN + Math.random() * (GAME_BALANCE.DAMAGE_VARIANCE_MAX - GAME_BALANCE.DAMAGE_VARIANCE_MIN);
                dmg = Math.floor(dmg * variance);

                // Ensure at least 1 dmg if effective
                if (typeMod > 0 && dmg < 1) dmg = 1;

                // 7. BUILD RESULT
                let msg = null;
                if (typeMod > 1) msg = "It's super\neffective!";
                else if (typeMod < 1) msg = "It's not very\neffective...";

                return { damage: dmg, desc: msg, eff: typeMod, isCrit: isCrit };
            },

            // --- UTILS ---
            lastMenuIndex: 0,

            playSparkle(side) {
                AudioEngine.playSfx('shiny');
                const container = document.getElementById('fx-container'); const rect = side === 'enemy' ? { x: 239, y: 61 } : { x: 80, y: 130 }; const spread = side === 'enemy' ? 30 : 60;
                for (let i = 0; i < 5; i++) { const star = document.createElement('div'); star.className = 'shiny-star'; star.style.left = (rect.x - spread + Math.random() * (spread * 2)) + 'px'; star.style.top = (rect.y - spread + Math.random() * (spread * 2)) + 'px'; star.style.animation = `sparkle 0.6s ease-out ${i * 0.15}s forwards`; container.appendChild(star); setTimeout(() => star.remove(), 1500); }
            },

            uiToMoves() {
                if (this.uiLocked) return;

                this.lastMenuIndex = Input.focus;

                // Rebuild menu to account for Transform/Metronome/etc changes
                this.buildMoveMenu();

                document.getElementById('action-menu').classList.add('hidden');
                document.getElementById('move-menu').classList.remove('hidden');
                this.textEl.innerHTML = "Select a move.";

                Input.setMode('MOVES');

                // --- FIX: Prevent Instant Double-Input ---
                // Locks the UI for 200ms. This stops the 'Enter' key press from the 
                // main menu from bleeding over and selecting the first move instantly.
                this.uiLocked = true;
                setTimeout(() => { this.uiLocked = false; }, 200);
            },

            // IN: Battle object
            uiToMenu() {
                // 1. CHECK RECHARGE (Hyper Beam, Giga Impact)
                // If recharging, player cannot select a move. Force a dummy "Recharging" turn.
                if (this.p.volatiles.recharging) {
                    this.performTurn({ name: 'Recharging', priority: 0 });
                    return;
                }

                // 2. CHECK CHARGE (Fly, Dig, Solar Beam)
                // If mid-air or underground, player cannot select a move. Force the Saved Move.
                if (this.p.volatiles.charging && this.p.volatiles.queuedMove) {
                    this.performTurn(this.p.volatiles.queuedMove);
                    return;
                }

                // 3. NORMAL STATE: Show Menu
                Game.state = 'BATTLE';
                document.getElementById('move-menu').classList.add('hidden');
                document.getElementById('pack-screen').classList.add('hidden');
                document.getElementById('party-screen').classList.add('hidden');
                document.getElementById('action-menu').classList.remove('hidden');
                this.textEl.innerHTML = `What will<br>${this.p.name} do?`;

                // Restore cursor position
                Input.setMode('BATTLE', this.lastMenuIndex);
            },

            askRun() {
                if (this.e.isBoss) { this.typeText("Can't escape a BOSS!"); setTimeout(() => this.uiToMenu(), 1000); return; }
                // SAVE CURSOR
                this.lastMenuIndex = Input.focus;
                const menu = document.getElementById('action-menu');
                // Added onmouseenter to these generated buttons so they highlight with mouse
                menu.innerHTML = `<div class="menu-item centered" id="run-yes" onclick="Battle.performRun()" onmouseenter="Input.focus=0;Input.updateVisuals()">YES</div><div class="menu-item centered" id="run-no" onclick="Battle.uiToMenu()" onmouseenter="Input.focus=1;Input.updateVisuals()">NO</div>`;
                this.textEl.innerHTML = "Give up and\nrestart?";
                Input.setMode('CONFIRM_RUN');
            },

            openPack() {
                if (this.uiLocked) return;
                // SAVE CURSOR
                this.lastMenuIndex = Input.focus;
                document.getElementById('pack-screen').classList.remove('hidden');
                document.querySelector('.bag-icon').style.backgroundImage = "url('https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/backpack.png')";
                this.renderPackList();
                Input.setMode('BAG');
            },
            renderPackList() {
                const list = document.getElementById('pack-list'); list.innerHTML = "";
                let idxCounter = 0;

                // Render Items
                Object.keys(Game.inventory).forEach((key) => {
                    const count = Game.inventory[key];
                    if (count > 0) {
                        const data = ITEMS[key];
                        const div = document.createElement('div'); div.className = 'pack-item';
                        div.innerHTML = `<span>${data.name}</span> <span>x${count}</span>`;

                        const showDesc = () => { document.getElementById('pack-desc').innerText = data.desc; if (data.img) { document.querySelector('.bag-icon').style.backgroundImage = `url('${data.img}')`; } };
                        const currentIdx = idxCounter;

                        div.onmouseover = () => showDesc();
                        div.onmouseenter = () => { Input.focus = currentIdx; Input.updateVisuals(); showDesc(); };
                        div.onclick = () => {
                            if (data.type === 'heal' || data.type === 'revive') { Game.selectedItemKey = key; Game.state = 'HEAL'; document.getElementById('pack-screen').classList.add('hidden'); Game.openParty(false); }
                            else { this.performItem(key); }
                        };
                        list.appendChild(div); idxCounter++;
                    }
                });

                // Render Cancel Button
                const cancelBtn = document.createElement('div');
                cancelBtn.className = 'pack-item cancel-btn';
                cancelBtn.innerText = "CANCEL";

                // --- FIX: ADD MOUSE TRACKING HERE ---
                cancelBtn.onmouseenter = () => { Input.focus = idxCounter; Input.updateVisuals(); };
                // ------------------------------------

                cancelBtn.onmouseover = () => { document.getElementById('pack-desc').innerText = "Close the Pack."; };
                cancelBtn.onclick = () => { this.uiToMenu(); };
                list.appendChild(cancelBtn);
            },

            buildMoveMenu() {
                const menu = document.getElementById('move-menu'); menu.innerHTML = '';
                const infoPanel = document.createElement('div'); infoPanel.id = 'move-info'; infoPanel.innerHTML = '<div>SELECT<br>A MOVE</div>';
                const grid = document.createElement('div'); grid.id = 'move-grid';

                this.p.moves.forEach((m, i) => {
                    const btn = document.createElement('div');
                    btn.className = 'move-btn';
                    btn.innerText = m.name;

                    // NEW: Attach data to the button for the keyboard to find
                    btn.dataset.type = m.type;
                    btn.dataset.power = m.power > 0 ? m.power : '-';
                    btn.dataset.accuracy = m.accuracy || '-';

                    btn.onclick = () => this.performTurn(m);

                    // Mouse logic (Kept for consistency)
                    const updateInfo = () => { infoPanel.innerHTML = `<div>TYPE/<br>${m.type.toUpperCase()}</div><div>PWR/${m.power > 0 ? m.power : '-'}</div><div>ACC/${m.accuracy || '-'}%</div>`; };
                    btn.onmouseover = updateInfo;
                    btn.onmouseenter = () => { Input.focus = i; Input.updateVisuals(); updateInfo(); };

                    grid.appendChild(btn);
                });

                const backBtn = document.createElement('div');
                backBtn.className = 'move-btn cancel';
                backBtn.innerText = 'BACK';
                backBtn.dataset.action = 'back'; // Mark this as the back button
                backBtn.onclick = () => this.uiToMenu();

                const idx = this.p.moves.length;
                backBtn.onmouseenter = () => { Input.focus = idx; Input.updateVisuals(); infoPanel.innerHTML = '<div>RETURN<br>TO MENU</div>'; };

                grid.appendChild(backBtn);
                menu.appendChild(infoPanel); menu.appendChild(grid);
            },
            switchIn(newMon, wasForced) {
                // We pass 'wasForced' as the second argument to processSwitch
                if (wasForced) {
                    this.processSwitch(newMon, true).then(() => {
                        this.uiLocked = false;
                        this.uiToMenu();
                    });
                } else {
                    this.performSwitch(newMon);
                }
            },



        };

        // Helper for Roar/Whirlwind/Dragon Tail
        async function _forceSwitchOrRun(battle, user, target) {
            if (target.isBoss) {
                await battle.typeText("But it failed!");
                return false;
            }

            // CASE 1: Player used Roar -> End Battle, Find New Enemy
            if (user === battle.p) {
                await battle.typeText(`${target.name} fled\nin fear!`);
                AudioEngine.playSfx('run');

                // Visual fade out of enemy
                const eSprite = document.getElementById('enemy-sprite');
                eSprite.style.transition = "opacity 0.5s";
                eSprite.style.opacity = 0;
                await wait(500);

                // Trigger the "Skip Battle" logic
                Game.skipBattle();
                return true;
            }

            // CASE 2: Enemy used Roar -> Force Player Switch
            else {
                // Filter: Must be alive, and must NOT be the current one
                const validIndices = Game.party
                    .map((p, index) => ({ p, index }))
                    .filter(item => item.p.currentHp > 0 && item.index !== Game.activeSlot)
                    .map(item => item.index);

                if (validIndices.length === 0) {
                    await battle.typeText("But it failed!");
                    return false;
                }

                // Pick Random
                const rndIndex = validIndices[Math.floor(Math.random() * validIndices.length)];
                const newMon = Game.party[rndIndex];

                await battle.typeText(`${target.name} was\ndragged out!`);

                // Update Game State Active Slot
                Game.activeSlot = rndIndex;

                // Perform the Switch (Force = true, so no menu)
                // Note: We set isFaintSwap=false because we want the animation of being dragged out
                await battle.processSwitch(newMon, false);
                return true;
            }
        }

        // --- FIX: INJECT CSS FOR FLIPPED DOLL ANIMATION ---
        const styleSheet = document.createElement("style");
        styleSheet.innerText = `
    /* Standard Shake (Already exists, listed for reference) */
    @keyframes shake { 0% { transform: translate(0, 0); } 25% { transform: translate(-6px, 0); } 75% { transform: translate(6px, 0); } 100% { transform: translate(0, 0); } }
    
    /* FLIPPED Shake (Combines ScaleX(-1) with Translate) */
    /* Note: Because of ScaleX(-1), left/right movements are visually inverted */
    @keyframes shakeFlipped { 
        0% { transform: scaleX(-1) translate(0, 0); } 
        25% { transform: scaleX(-1) translate(6px, 0); } 
        75% { transform: scaleX(-1) translate(-6px, 0); } 
        100% { transform: scaleX(-1) translate(0, 0); } 
    }
    
    /* Apply this class when hitting the Player's Doll */
    .anim-hit-flipped { animation: shakeFlipped 0.4s, flicker 0.4s; }
`;
        document.head.appendChild(styleSheet);


        // --- INITIALIZATION ---
        Input.init();

        Input.setMode('START');
    </script>
</body>

</html>