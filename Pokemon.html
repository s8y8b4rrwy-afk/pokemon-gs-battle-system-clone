<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G/S Battle Simulator: Enhanced</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --bg-color: #f8f8f8;
            --screen-bg: #ffffff;
            --ui-border: #202020;
            --hp-green: #48c050;
            --hp-yellow: #d8b030;
            --hp-red: #c83828;
            --xp-blue: #40a8c0;
            --gs-black: #181818;
            --gs-blue: #283048;
        }

        body {
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'Press Start 2P', cursive;
            user-select: none;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        #game-boy {
            width: 320px;
            height: 288px;
            background-color: var(--screen-bg);
            border: 4px solid #888;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            image-rendering: pixelated;
        }

        /* --- LCD FILTER --- */
        #lcd-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 999;
            background: 
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), 
                linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 2px 100%;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
            opacity: 0;
            transition: opacity 0.5s;
        }
        #lcd-overlay.active { opacity: 1; }

        /* --- START SCREEN --- */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--gs-black); color: white; z-index: 1000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            text-align: center; gap: 20px;
        }
        .start-title { color: #d8b030; font-size: 16px; line-height: 24px; text-shadow: 2px 2px 0 #000; margin-bottom: 20px; }
        .start-btn { 
            background: white; color: black; border: 2px solid #888; padding: 10px; 
            font-size: 8px; font-family: 'Press Start 2P'; cursor: pointer; 
        }
        .start-btn:hover { background: #eee; }
        .toggle-box { font-size: 8px; display: flex; align-items: center; gap: 8px; cursor: pointer; }
        .checkbox { width: 10px; height: 10px; border: 2px solid white; display: inline-block; position: relative; }
        .checkbox.checked::after { content: ''; position: absolute; top: 2px; left: 2px; width: 6px; height: 6px; background: #d8b030; }

        /* --- NAME ENTRY SCREEN --- */
        #name-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--gs-blue); color: white; z-index: 950;
            display: flex; flex-direction: column; align-items: center; padding-top: 40px;
        }
        #name-input {
            background: white; color: black; border: 2px solid #888;
            padding: 5px; font-family: 'Press Start 2P'; font-size: 12px; text-transform: uppercase;
            width: 150px; text-align: center; outline: none; margin-bottom: 20px;
        }

        /* --- CONTINUE SCREEN (GS STYLE) --- */
        #continue-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--gs-blue); color: white; z-index: 900;
            display: flex; flex-direction: column; padding: 20px; box-sizing: border-box;
        }
        .cont-menu-box {
            background: #fff; color: black; border: 4px solid #202020; border-radius: 4px;
            margin-bottom: 10px; padding: 10px; display: flex; flex-direction: column; gap: 10px;
        }
        .cont-opt { font-size: 10px; cursor: pointer; display: flex; align-items: center; }
        .cont-opt::before { content: ' '; width: 10px; display: inline-block; }
        .cont-opt.focused::before { content: '▶'; }
        
        .save-info-box {
            background: var(--gs-blue); border: 2px solid white; border-radius: 4px;
            padding: 10px; flex-grow: 1; display: flex; flex-direction: column; gap: 8px;
        }
        .save-row { font-size: 8px; display: flex; justify-content: space-between; }
        .party-preview-row {
            display: flex; gap: 4px; margin-top: 10px; background: rgba(0,0,0,0.3);
            padding: 4px; border-radius: 4px; overflow-x: auto;
        }
        .mini-icon { width: 32px; height: 24px; image-rendering: pixelated; cursor: pointer; }
        .mini-icon.fainted { filter: grayscale(100%) brightness(0.7); opacity: 0.8; }
        .mini-icon:hover { transform: translateY(-2px); }

        /* --- UTILS --- */
        .hidden { display: none !important; }
        .btn-bar { background:#ddd; text-align:center; padding:6px; font-size:8px; cursor:pointer; border-top:2px solid #999; margin-top:auto;}
        .btn-bar:hover, .btn-bar.focused { background: #ccc; }

        /* --- FOCUS / HOVER STATES --- */
        .menu-item:hover, .menu-item.focused { background-color: #eee; }
        .menu-item:hover::before, .menu-item.focused::before { opacity: 1; }
        .move-btn:hover, .move-btn.focused { background: #e0e0e0; border-color: #202020; }
        .party-slot:hover, .party-slot.focused { background: #eee; border-color: #000; }
        .pack-item:hover, .pack-item.focused { background: #eee; border: 1px solid #ccc; }
        .ctx-btn:hover, .ctx-btn.focused { background: #eee; }
        .confirm-btn:hover, .confirm-btn.focused { background: #000; }

        /* --- SELECTION SCREEN --- */
        #selection-screen { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: #202020; z-index: 100; display: flex; flex-direction: column; 
        }
        .sel-preview-box { height: 110px; margin: 10px 10px 0 10px; background: #fff; border: 4px solid #444; border-radius: 4px; display: flex; align-items: center; justify-content: center; position: relative; }
        .preview-sprite { width: 96px; height: 96px; image-rendering: pixelated; }
        .shiny-mark { position: absolute; top: 5px; right: 5px; color: gold; font-size: 12px; display: none; }
        .lab-table-area { flex-grow: 1; display: flex; justify-content: center; align-items: center; background: #202020; position: relative; }
        .table-graphic { width: 200px; height: 60px; background: #fff; border: 2px solid #888; display: flex; justify-content: space-around; align-items: center; border-radius: 4px; position: relative; }
        .pokeball-select { width: 20px; height: 20px; background: radial-gradient(circle at 35% 35%, white 10%, red 11%, red 50%, black 51%, black 60%, white 61%); border-radius: 50%; border: 1px solid black; position: relative; cursor: pointer; box-shadow: 0 2px 2px rgba(0,0,0,0.4); }
        .pokeball-select.focused { transform: scale(1.1); box-shadow: 0 0 5px gold; }
        .sel-cursor { position: absolute; top: -20px; left: 0; width: 20px; height: 20px; transition: left 0.1s steps(1); pointer-events: none; }
        .sel-cursor::after { content: "▼"; color: #d8b030; font-size: 12px; position: absolute; left: 4px; animation: bounceCursor 0.6s infinite; }
        @keyframes bounceCursor { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-3px); } }
        .sel-desc-box { height: 60px; background: white; border-top: 4px solid #888; padding: 8px; font-size: 8px; line-height: 12px; text-transform: uppercase; display: flex; flex-direction: column; justify-content: center; }

        /* --- SUMMARY SCREEN (FIXED Z-INDEX) --- */
        #summary-panel { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: white; z-index: 950; 
            display: flex; flex-direction: column; padding: 8px; box-sizing: border-box; 
        }
        .sum-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid #444; padding-bottom: 4px; margin-bottom: 4px; }
        .sum-body { display: flex; gap: 8px; margin-bottom: 8px; }
        .sum-sprite { width: 96px; height: 96px; border: 1px solid #ccc; background: #f8f8f8; display: flex; align-items: center; justify-content: center; }
        .sum-sprite img { width: 96px; height: 96px; image-rendering: pixelated; }
        .sum-data { flex-grow: 1; display: flex; flex-direction: column; gap: 2px; font-size: 8px; justify-content: center; }
        
        /* New Summary Bars */
        .sum-stat-bar { width: 100%; height: 6px; background: #ddd; border: 1px solid #000; border-radius: 2px; margin-bottom: 2px; position: relative; }
        .sum-stat-fill { height: 100%; display: block; transition: width 0.3s; }
        .sum-divider { width: 100%; height: 2px; background: #444; margin: 4px 0; }

        .sum-moves { border-top: 2px solid #444; padding-top: 6px; display: flex; flex-direction: column; gap: 6px; }
        .move-row { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px dotted #ccc; padding-bottom: 2px; }
        .move-name { color: #000; text-transform: uppercase; font-size: 6px; }
        .move-info-grp { display:flex; gap:6px; align-items:center; }
        .move-pwr { font-size: 6px; color: #444; }
        .move-type { color: #666; text-transform: uppercase; font-size: 6px; background: #eee; padding: 1px 3px; border-radius: 2px; }
        .type-tag { background: #333; color: white; padding: 2px 4px; display: inline-block; margin-right: 4px; border-radius: 2px; }
        .sum-buttons { margin-top: auto; display: flex; gap: 5px; }
        .confirm-btn { flex: 1; background: #444; color: white; border: none; padding: 8px; font-family: 'Press Start 2P'; font-size: 7px; cursor: pointer; text-align: center; }
        .confirm-btn:disabled { background: #bbb; color: #eee; pointer-events: none; }
        .confirm-btn.secondary { background: #888; }
        .confirm-btn.nav-btn { flex: 0 0 20px; }
        .confirm-btn.danger { background: #c83828; }

        /* Party and Pack Screens */
        #party-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #f8f8f8; z-index: 300; display: flex; flex-direction: column; }
        #pack-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #f8f8f8; z-index: 250; display: flex; flex-direction: column; }
        
        .party-header, .pack-header { background: #282828; color: white; padding: 8px; font-size: 10px; border-bottom: 2px solid #a0a0a0; }
        .party-list, .pack-list { flex-grow: 1; overflow-y: auto; padding: 4px; }
        .party-slot { display: flex; align-items: center; background: white; border: 2px solid #ccc; margin-bottom: 4px; padding: 2px; cursor: pointer; height: 40px; position: relative; }
        .party-slot.fainted { opacity: 0.6; background: #ddd; }
        .party-slot.fainted .slot-icon { filter: grayscale(100%); }
        .party-slot.active-mon { border: 2px solid #d8b030; background: #fffbe0; }
        .party-slot.new-catch { border: 2px dashed #40a8c0; background: #e0f8ff; }
        .slot-icon { width: 40px; height: 30px; image-rendering: pixelated; margin-right: 5px; }
        .party-slot:hover .slot-icon, .party-slot.focused .slot-icon { animation: jump 0.3s infinite; }
        .slot-info { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; font-size: 8px; }
        .slot-row { display: flex; justify-content: space-between; width: 100%; margin-bottom: 2px; }
        .mini-hp-bg { width: 60px; height: 4px; background: #ccc; border: 1px solid #000; border-radius: 2px; }
        .mini-hp-fill { height: 100%; background: var(--hp-green); width: 100%; }
        #party-context { position: absolute; bottom: 10px; right: 10px; width: 90px; background: white; border: 2px solid #202020; z-index: 350; box-shadow: 4px 4px 0 rgba(0,0,0,0.3); display: flex; flex-direction: column; }
        .ctx-btn { padding: 10px; font-size: 8px; cursor: pointer; border-bottom: 1px solid #eee; background: white; }
        .ctx-btn.warn { color: #c83828; font-weight: bold; }
        .pack-body { display: flex; flex-grow: 1; }
        .pack-graphic { width: 40%; background: #e0e0e0; border-right: 2px solid #a0a0a0; display: flex; align-items: center; justify-content: center; }
        .bag-icon { width: 64px; height: 64px; image-rendering: pixelated; background-image: url('https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/backpack.png'); background-size: contain; background-repeat: no-repeat; transition: background-image 0.1s; }
        .pack-list { width: 60%; background: white; padding: 10px; display: flex; flex-direction: column; gap: 8px; }
        .pack-item { font-size: 8px; cursor: pointer; display: flex; justify-content: space-between; padding: 4px; border: 1px solid transparent; }
        .pack-item.disabled { color: #aaa; pointer-events: none; }
        .pack-desc-box { height: 60px; background: #282828; color: white; border-top: 4px solid #a0a0a0; padding: 8px; font-size: 8px; line-height: 12px; }

        /* --- BATTLE SCENE --- */
        .scene { height: 200px; position: relative; background: linear-gradient(to bottom, #f8f8f8 0%, #e0e0e0 100%); transform-origin: center center; }
        .sprite { position: absolute; image-rendering: pixelated; z-index: 5; transition: opacity 0.2s; }
        #enemy-sprite { width: 112px; height: 112px; top: 5px; right: 20px; }
        
        /* PLAYER SPRITE LEFT OFFSET */
        #player-sprite { width: 224px; height: 224px; bottom: -40px; left: -30px; transform-origin: bottom left; }
        
        .hud { position: absolute; background: white; border: 2px solid var(--ui-border); border-radius: 2px; padding: 4px; width: 130px; z-index: 10; box-shadow: 2px 2px 0px rgba(0,0,0,0.2); }
        #enemy-hud { top: 10px; left: 10px; }
        #player-hud { bottom: 25px; right: 10px; }
        .name { font-size: 10px; margin-bottom: 4px; text-transform: uppercase; display: flex; align-items: center; }
        .level { font-size: 10px; float: right; }
        .hp-box { display: flex; align-items: center; font-size: 8px; font-weight: bold; }
        .hp-bar-bg { width: 90px; height: 6px; background: #f0f0f0; border: 1px solid #000; border-radius: 2px; position: relative; }
        .hp-fill { height: 100%; background-color: var(--hp-green); width: 100%; transition: width 0.5s ease; border-right: 1px solid black; }
        #player-hp-text { font-size: 10px; text-align: right; margin-top: 4px; letter-spacing: 1px; }
        .exp-box { display: flex; align-items: center; margin-top: 2px; justify-content: flex-end; }
        .exp-bar-bg { width: 80px; height: 2px; background: #ccc; border: 1px solid #444; border-radius: 2px; margin-left: 4px; }
        .exp-fill { height: 100%; width: 0%; background: var(--xp-blue); transition: width 0.5s ease; }
        
        /* RAGE & STREAK VISUALS */
        .aggro-icon { font-size: 10px; margin-left: 4px; font-weight: bold; text-shadow: 1px 1px 0 #fff; }
        .aggro-1 { color: #d8b030; } 
        .aggro-2 { color: #c86028; }
        .aggro-3 { color: #c83828; animation: pulseAggro 0.5s infinite; }
        @keyframes pulseAggro { 0% { transform: scale(1); } 50% { transform: scale(1.3); } 100% { transform: scale(1); } }
        #streak-box { position: absolute; top: 8px; right: 8px; background: white; border: 2px solid #202020; padding: 4px 6px; font-size: 8px; z-index: 50; box-shadow: 2px 2px 0px rgba(0,0,0,0.2); color: black; }

        .smoke-particle { 
            position: absolute; width: 12px; height: 12px; 
            background: white; border: 1px solid #000; border-radius: 50%; 
            pointer-events: none; z-index: 25; opacity: 1; 
            box-shadow: inset -2px -2px 0 #ccc;
            animation: smokePop 0.4s ease-out forwards; 
        }
        @keyframes smokePop { 
            0% { transform: translate(0,0) scale(0.5); opacity: 1; } 
            100% { transform: translate(var(--tx), var(--ty)) scale(1.5); opacity: 0; } 
        }

        #dialog-box { height: 88px; background-color: #282828; color: white; border-top: 4px solid #a0a0a0; padding: 10px; box-sizing: border-box; display: flex; position: relative; z-index: 20; }
        #text-content { width: 60%; font-size: 12px; line-height: 18px; text-transform: uppercase; white-space: pre-wrap; }
        #text-content.full-width { width: 292px; } 

        #action-menu { width: 45%; background: white; color: black; border-left: 4px solid #a0a0a0; display: grid; grid-template-columns: 1fr 1fr; padding: 5px; position: absolute; right: 0; top: 0; height: 100%; box-sizing: border-box; cursor: pointer; z-index: 20; }
        #move-menu { width: 100%; height: 100%; top: 0; left: 0; position: absolute; background: white; z-index: 25; display: flex; }
        #move-info { width: 35%; background: #282828; color: white; padding: 8px; font-size: 8px; display: flex; flex-direction: column; justify-content: center; gap: 6px; border-right: 2px solid #a0a0a0; box-sizing: border-box; }
        #move-grid { width: 65%; display: grid; grid-template-columns: 1fr 1fr; grid-auto-rows: 1fr; gap: 2px; padding: 4px; box-sizing: border-box; }
        .move-btn { background: #fff; border: 2px solid #ccc; display: flex; align-items: center; justify-content: center; font-size: 8px; cursor: pointer; text-transform: uppercase; text-align: center; padding: 2px; color: #000; }
        .move-btn.cancel { grid-column: span 2; border-color: #a0a0a0; background: #f0f0f0; color: #444; font-weight:bold; }
        .menu-item { font-size: 10px; display: flex; align-items: center; padding-left: 4px; text-transform: uppercase; white-space: nowrap; overflow: hidden; }
        .menu-item::before { content: "▸"; opacity: 0; margin-right: 2px; }
        .menu-item.centered { justify-content: center; padding-left: 0; }

        /* --- ANIMATIONS --- */
        @keyframes spawn { 0% { transform: scale(0); filter: brightness(10); opacity: 0; } 60% { opacity: 1; } 100% { transform: scale(1); filter: brightness(1); opacity: 1; } }
        .anim-enter { animation: spawn 0.6s ease-out forwards; }
        @keyframes withdraw { 0% { transform: scale(1); opacity: 1; filter: brightness(1); } 100% { transform: scale(0); opacity: 0; filter: brightness(5); } }
        .anim-return { animation: withdraw 0.4s ease-in forwards; }
        @keyframes faint { 0% { transform: translateY(0); opacity: 1; } 100% { transform: translateY(40px); opacity: 0; } }
        .anim-faint { animation: faint 0.6s ease-out forwards; }
        @keyframes captureThrow { 0% { transform: translate(0, 0) rotate(0deg); } 25% { transform: translate(60px, -140px) rotate(180deg); } 50% { transform: translate(140px, -180px) rotate(360deg); } 75% { transform: translate(180px, -140px) rotate(540deg); } 100% { transform: translate(215px, -100px) rotate(720deg); } }
        @keyframes captureShake { 0%, 100% { transform: translate(215px, -100px) rotate(0deg); } 25% { transform: translate(215px, -100px) rotate(-15deg); } 75% { transform: translate(215px, -100px) rotate(15deg); } }
        .pokeball-anim { position: absolute; bottom: 40px; left: 20px; width: 16px; height: 16px; background: radial-gradient(circle at 35% 35%, white 10%, red 11%, red 50%, black 51%, black 60%, white 61%); border-radius: 50%; border: 1px solid black; z-index: 50; }
        .pokeball-anim.great { background: radial-gradient(circle at 35% 35%, white 10%, #3b82c4 11%, #3b82c4 50%, black 51%, black 60%, white 61%); }
        .pokeball-anim.ultra { background: radial-gradient(circle at 35% 35%, white 10%, #333 11%, #333 50%, gold 51%, gold 60%, white 61%); }
        .pokeball-anim.master { background: radial-gradient(circle at 35% 35%, white 10%, #7e30cc 11%, #7e30cc 50%, pink 51%, pink 60%, white 61%); }
        .pokeball-caught { position: absolute; width: 16px; height: 16px; background: radial-gradient(circle at 35% 35%, white 10%, #555 11%, #555 50%, black 51%, black 60%, white 61%); border-radius: 50%; border: 1px solid black; z-index: 40; filter: grayscale(1); }
        @keyframes deflectAnim { 0% { transform: translateX(0); } 20% { transform: translateX(15px); } 40% { transform: translateX(-10px); } 60% { transform: translateX(5px); } 100% { transform: translateX(0); } }
        .anim-deflect { animation: deflectAnim 0.3s ease-out; }
        @keyframes sparkle { 0% { transform: scale(0) rotate(0deg); opacity: 1; } 50% { transform: scale(1) rotate(180deg); opacity: 1; } 100% { transform: scale(0) rotate(360deg); opacity: 0; } }
        .shiny-star { position: absolute; width: 10px; height: 10px; background: transparent; pointer-events: none; z-index: 20; }
        .shiny-star::before { content: "✦"; color: gold; font-size: 16px; position: absolute; }
        @keyframes shake { 0% { transform: translate(0, 0); } 25% { transform: translate(-6px, 0); } 75% { transform: translate(6px, 0); } 100% { transform: translate(0, 0); } }
        @keyframes flicker { 0% { opacity: 1; } 25% { opacity: 0; } 50% { opacity: 1; } 75% { opacity: 0; } 100% { opacity: 1; } }
        .anim-hit { animation: shake 0.4s, flicker 0.4s; }
        @keyframes bossIntroSequence { 0% { filter: brightness(10); transform: translate(0,0); } 10% { filter: brightness(1); transform: translate(-8px, 8px); } 20% { transform: translate(8px, -8px); } 30% { transform: translate(-8px, -8px); } 40% { transform: translate(8px, 8px); } 50% { transform: translate(-8px, 0); } 60% { transform: translate(8px, 0); } 100% { filter: brightness(1); transform: translate(0,0); } }
        @keyframes violentShake { 0% { transform: translate(0,0) rotate(0deg); } 25% { transform: translate(-10px, 5px) rotate(-5deg); } 50% { transform: translate(10px, -5px) rotate(5deg); } 75% { transform: translate(-10px, -5px) rotate(-5deg); } 100% { transform: translate(0,0) rotate(0deg); } }
        .boss-intro { animation: bossIntroSequence 1.0s ease-out forwards; }
        .anim-violent { animation: violentShake 0.5s ease-in-out; }
        /* FX */
        @keyframes flashRed { 0% { box-shadow: inset 0 0 0 red; } 50% { box-shadow: inset 0 0 150px red; } 100% { box-shadow: inset 0 0 0 red; } }
        @keyframes flashBlue { 0% { box-shadow: inset 0 0 0 cyan; } 50% { box-shadow: inset 0 0 150px cyan; } 100% { box-shadow: inset 0 0 0 cyan; } }
        @keyframes flashGreen { 0% { box-shadow: inset 0 0 0 lime; } 50% { box-shadow: inset 0 0 150px lime; } 100% { box-shadow: inset 0 0 0 lime; } }
        @keyframes flashWhite { 0% { filter: brightness(1); } 20% { filter: brightness(10); } 40% { filter: brightness(10); } 60% { filter: brightness(10); } 100% { filter: brightness(1); } }
        @keyframes wobble { 0% { filter: hue-rotate(0deg); transform: skew(0) rotate(0); } 25% { transform: skew(10deg) rotate(5deg); } 75% { transform: skew(-10deg) rotate(-5deg); } 100% { filter: hue-rotate(0deg); transform: skew(0) rotate(0); } }
        @keyframes impact { 0% { transform: translate(0,0); } 20% { transform: translate(-10px, 10px) rotate(5deg); } 100% { transform: translate(0,0); } }
        @keyframes brownQuake { 0% { transform: translateY(0); } 25% { transform: translateY(-10px); } 75% { transform: translateY(10px); } 100% { transform: translateY(0); } }
        .fx-fire { animation: flashRed 0.5s; } .fx-water { animation: flashBlue 0.5s; } .fx-ice { animation: flashBlue 0.5s; }
        .fx-grass { animation: flashGreen 0.5s; } .fx-electric { animation: flashWhite 0.4s; }
        .fx-psychic, .fx-dragon { animation: wobble 0.6s ease-in-out; } 
        .fx-ground, .fx-rock { animation: brownQuake 0.4s; } 
        .fx-normal, .fx-fighting, .fx-flying { animation: impact 0.3s; }
        .boss-name { color: #c83828; text-shadow: 1px 0px 0px black; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="game-boy">
        <div id="lcd-overlay"></div>
        <div id="streak-box" class="hidden">WINS: 0</div>

        <!-- Start Screen -->
        <div id="start-screen">
            <div class="start-title">POKEMON<br>GOLD & SILVER<br>SIMULATION</div>
            <div class="start-btn" onclick="Game.checkSave()">CLICK TO START</div>
            <div class="toggle-box" onclick="Game.toggleLcd()">
                <div class="checkbox" id="lcd-check"></div>
                <span>RETRO FILTER</span>
            </div>
            <div style="font-size: 6px; color: #888; margin-top: 20px;">Z: CONFIRM | X: BACK | ARROWS: MOVE</div>
        </div>

        <!-- Name Input Screen -->
        <div id="name-screen" class="hidden">
            <div style="margin-bottom: 10px;">REGISTRATION</div>
            <div style="font-size: 8px; margin-bottom: 20px;">PLEASE ENTER YOUR NAME</div>
            <input type="text" id="name-input" maxlength="8" placeholder="NAME">
            <div class="start-btn" onclick="Game.confirmName()">CONFIRM</div>
        </div>

        <!-- CONTINUE SCREEN (GS STYLE) -->
        <div id="continue-screen" class="hidden">
            <div class="cont-menu-box">
                <div class="cont-opt" id="opt-continue" onclick="Game.loadGame()">CONTINUE</div>
                <div class="cont-opt" id="opt-newgame" onclick="Game.startNameInput()">NEW GAME</div>
            </div>
            <div class="save-info-box">
                <div class="save-row" style="color:yellow" id="save-name">PLAYER</div>
                <div class="save-row"><span>WINS</span> <span id="save-wins">0</span></div>
                <div class="save-row"><span>BOSSES</span> <span id="save-bosses">0</span></div>
                <div class="save-row" style="margin-top:4px;">PARTY</div>
                <div class="party-preview-row" id="save-preview"></div>
                <div style="font-size:6px; text-align:center; color:#888;">CLICK PKMN FOR INFO</div>
            </div>
        </div>

        <!-- Summary Screen -->
        <div id="summary-panel" class="hidden">
            <div class="sum-header">
                <div style="font-weight: bold; font-size: 10px;" id="sum-name">NAME</div>
                <div id="sum-shiny-icon" style="color:gold; font-size:10px; display:none;">✦</div>
                <div id="sum-status-text" style="font-size:8px;">STATUS/OK</div>
            </div>
            <div class="sum-body">
                <div class="sum-sprite"><img id="sum-sprite-img" src=""></div>
                <div class="sum-data">
                    <div id="sum-types"></div>
                    <div style="margin-top:4px;">HP <span id="sum-hp-txt"></span></div>
                    <div class="sum-stat-bar"><div class="sum-stat-fill" id="sum-hp-bar" style="background:var(--hp-green);"></div></div>
                    <div>EXP <span id="sum-exp-txt"></span></div>
                    <div class="sum-stat-bar"><div class="sum-stat-fill" id="sum-exp-bar" style="background:var(--xp-blue);"></div></div>
                    
                    <div class="sum-divider"></div>
                    
                    <div id="summary-stats"></div>
                </div>
            </div>
            <div style="font-size:8px; font-weight:bold; margin-bottom:2px;">MOVES:</div>
            <div id="summary-moves" class="sum-moves"></div>
            <div class="sum-buttons">
                <button class="confirm-btn nav-btn" id="btn-prev" onclick="Game.navSummary(-1)">&lt;</button>
                <button class="confirm-btn" id="btn-action">ACTION</button>
                <button class="confirm-btn secondary" id="btn-back-sum" onclick="Game.closeSummary()">CLOSE</button>
                <button class="confirm-btn nav-btn" id="btn-next" onclick="Game.navSummary(1)">&gt;</button>
            </div>
        </div>

        <!-- Party Screen -->
        <div id="party-screen" class="hidden">
            <div class="party-header" id="party-header-text">POKEMON PARTY</div><div id="party-list" class="party-list"></div>
            <div id="party-context" class="hidden"></div>
            <div class="btn-bar" id="party-close-btn" onclick="Battle.uiToMenu()">CLOSE</div>
        </div>

        <!-- Pack Screen -->
        <div id="pack-screen" class="hidden">
            <div class="pack-header">ITEM POCKET</div>
            <div class="pack-body"><div class="pack-graphic"><div class="bag-icon"></div></div><div class="pack-list" id="pack-list"></div></div>
            <div class="pack-desc-box" id="pack-desc">Choose an item.</div><div class="btn-bar" id="pack-close-btn" onclick="Battle.uiToMenu()">CLOSE BAG</div>
        </div>

        <!-- RETRO SELECTION SCREEN -->
        <div id="selection-screen" class="hidden">
            <div class="sel-preview-box">
                <img id="sel-preview-img" class="preview-sprite" src="" style="display:none">
                <div id="sel-preview-shiny" class="shiny-mark">✦</div>
            </div>
            <div class="lab-table-area">
                <div class="table-graphic" id="lab-table">
                    <div class="sel-cursor" id="sel-cursor"></div>
                </div>
            </div>
            <div class="sel-desc-box" id="sel-text-box">SELECT A POKEMON</div>
        </div>

        <!-- Battle Scene -->
        <div class="scene hidden" id="scene">
            <div id="fx-container" style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none;"></div>
            <div class="hud" id="enemy-hud">
                <div class="name"><span id="enemy-name">LOADING...</span><span id="aggro-icon" class="aggro-icon"></span></div>
                <div class="level" id="enemy-lvl">Lv15</div><div class="hp-box"><span style="margin-right:2px; color:#e6ae27;">HP</span><div class="hp-bar-bg"><div id="enemy-hp-bar" class="hp-fill"></div></div></div>
            </div>
            <img id="enemy-sprite" class="sprite" src="" alt="Enemy">
            <img id="player-sprite" class="sprite" src="" alt="Player">
            <div class="hud" id="player-hud">
                <div class="name"><span id="player-name">LOADING...</span></div>
                <div class="level" id="player-lvl">Lv15</div>
                <div class="hp-box"><span style="margin-right:2px; color:#e6ae27;">HP</span><div class="hp-bar-bg"><div id="player-hp-bar" class="hp-fill"></div></div></div>
                <div id="player-hp-text">--/--</div>
                <div class="exp-box"><span style="font-size:6px; margin-right:1px;">EXP</span><div class="exp-bar-bg"><div id="player-exp-bar" class="exp-fill"></div></div></div>
            </div>
        </div>

        <!-- Dialog Box -->
        <div id="dialog-box" class="hidden">
            <div id="text-content">...</div>
            <div id="action-menu" class="hidden">
                <div class="menu-item" id="opt-fight" onclick="Battle.uiToMoves()">FIGHT</div>
                <div class="menu-item" id="opt-pkmn" onclick="Game.openParty(false)">PKMN</div>
                <div class="menu-item" id="opt-pack" onclick="Battle.openPack()">PACK</div>
                <div class="menu-item" id="opt-run" onclick="Battle.askRun()">RUN</div>
            </div>
            <div id="move-menu" class="hidden"></div>
        </div>
    </div>
</div>

<script>
// --- 1. ITEMS ---
const ITEMS = { 
    potion: { name: "POTION", heal: 20, type:'heal', desc: "Restores Pokemon HP by 20.", img: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/potion.png" },
    superpotion: { name: "SUPER POTION", heal: 50, type:'heal', desc: "Restores Pokemon HP by 50.", img: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/super-potion.png" },
    hyperpotion: { name: "HYPER POTION", heal: 200, type:'heal', desc: "Restores Pokemon HP by 200.", img: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/hyper-potion.png" },
    maxpotion: { name: "MAX POTION", heal: 9999, type:'heal', desc: "Fully restores Pokemon HP.", img: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/max-potion.png" },
    revive: { name: "REVIVE", type:'revive', desc: "Restores a fainted Pokemon to 50% HP.", img: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/revive.png" },
    pokeball: { name: "POKE BALL", type:'ball', rate: 1, desc: "A device for catching wild Pokemon.", css:'', img: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/poke-ball.png" },
    greatball: { name: "GREAT BALL", type:'ball', rate: 1.5, desc: "A good Ball with a higher catch rate.", css:'great', img: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/great-ball.png" },
    ultraball: { name: "ULTRA BALL", type:'ball', rate: 2, desc: "A better Ball with a high catch rate.", css:'ultra', img: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/ultra-ball.png" },
    masterball: { name: "MASTER BALL", type:'ball', rate: 255, desc: "The best Ball. It catches without fail.", css:'master', img: "https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/master-ball.png" }
};

// --- 2. AUDIO ENGINE ---
const AudioEngine = {
    ctx: null,
    lastCryTimeout: null,
    init() { if (!this.ctx) { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); } if (this.ctx.state === 'suspended') this.ctx.resume(); },
    playCry(url) { 
        if (!url) return; 
        if(this.lastCryTimeout) clearTimeout(this.lastCryTimeout);
        this.init(); 
        const a = new Audio(url); a.volume = 0.4; a.play().catch(()=>{}); 
    },
    playTone(freq, type, dur, vol, delay) {
        const t = this.ctx.currentTime + delay; const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
        o.type = type; o.frequency.value = freq; o.connect(g); g.connect(this.ctx.destination);
        g.gain.setValueAtTime(vol, t); g.gain.linearRampToValueAtTime(0, t+dur); o.start(t); o.stop(t+dur);
    },
    playNoise(dur) {
        const t = this.ctx.currentTime; const bufSize = this.ctx.sampleRate * dur; const buf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = buf.getChannelData(0); for (let i=0; i<bufSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource(); noise.buffer = buf; 
        const gain = this.ctx.createGain(); gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t+dur);
        noise.connect(gain); gain.connect(this.ctx.destination); noise.start(t);
    },
    playSfx(type) {
        this.init(); const now = this.ctx.currentTime; const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
        osc.connect(gain); gain.connect(this.ctx.destination);
        switch (type) {
            case 'select': this.playTone(1200, 'square', 0.05, 0.05, 0); break;
            case 'ball': this.playNoise(0.3); break;
            case 'exp': this.playTone(800, 'square', 0.05, 0.1, 0); break;
            case 'rumble': this.playNoise(0.5); break;
            case 'shiny': this.playTone(1396.91, 'sine', 0.1, 0.1, 0); this.playTone(1760.00, 'sine', 0.2, 0.1, 0.1); return;
            case 'error': osc.type='sawtooth'; osc.frequency.setValueAtTime(100,now); gain.gain.setValueAtTime(0.3,now); gain.gain.linearRampToValueAtTime(0,now+0.2); osc.start(now); osc.stop(now+0.2); break;
            case 'crit': osc.type='square'; osc.frequency.setValueAtTime(80,now); gain.gain.setValueAtTime(0.5,now); gain.gain.exponentialRampToValueAtTime(0.01,now+0.3); osc.start(now); osc.stop(now+0.3); break;
            case 'miss': osc.type='square'; osc.frequency.setValueAtTime(500,now); gain.gain.setValueAtTime(0.2,now); gain.gain.linearRampToValueAtTime(0,now+0.1); osc.start(now); osc.stop(now+0.1); break;
            case 'damage': osc.type='square'; osc.frequency.setValueAtTime(200,now); osc.frequency.exponentialRampToValueAtTime(50,now+0.2); gain.gain.setValueAtTime(0.2,now); gain.gain.linearRampToValueAtTime(0,now+0.2); osc.start(now); osc.stop(now+0.2); break;
            case 'funfair': this.playTone(523.25,'square',0.1,0.1,0); this.playTone(659.25,'square',0.1,0.1,0.1); this.playTone(783.99,'square',0.1,0.1,0.2); this.playTone(1046.50,'square',0.2,0.1,0.3); return;
            case 'levelup': this.playTone(1046.50,'square',0.1,0.1,0); this.playTone(1318.51,'square',0.1,0.1,0.15); this.playTone(1567.98,'square',0.1,0.1,0.3); this.playTone(2093.00,'square',0.4,0.1,0.45); return;
            case 'heal': this.playTone(523.25,'sine',0.1,0.1,0); this.playTone(659.25,'sine',0.1,0.1,0.1); this.playTone(783.99,'sine',0.1,0.1,0.2); this.playTone(1046.50,'sine',0.3,0.1,0.3); return;
            case 'throw': osc.type='sawtooth'; osc.frequency.setValueAtTime(300,now); osc.frequency.linearRampToValueAtTime(100,now+0.3); gain.gain.setValueAtTime(0.1,now); gain.gain.linearRampToValueAtTime(0,now+0.3); osc.start(now); osc.stop(now+0.3); break;
            case 'catch_click': osc.type='square'; osc.frequency.setValueAtTime(800,now); gain.gain.setValueAtTime(0.1,now); gain.gain.exponentialRampToValueAtTime(0.01,now+0.05); osc.start(now); osc.stop(now+0.05); break;
            case 'catch_success': this.playNoise(0.2); break;
            case 'clank': this.playTone(2000, 'square', 0.05, 0.1, 0); break; 
            default: osc.type='square'; osc.frequency.setValueAtTime(150,now); osc.frequency.exponentialRampToValueAtTime(40,now+0.1); gain.gain.setValueAtTime(0.1,now); gain.gain.exponentialRampToValueAtTime(0.01,now+0.1); osc.start(now); osc.stop(now+0.1); break;
        }
    }
};

// --- 3. API ---
const API = {
    base: 'https://pokeapi.co/api/v2',
    async getPokemon(id, level) {
        try {
            const res = await fetch(`${this.base}/pokemon/${id}`); const data = await res.json();
            const getStat = (n) => data.stats.find(s => s.stat.name === n).base_stat;
            const isShiny = Math.random() < 0.05; 
            const calcStat = (base, lvl) => Math.floor((2 * base * lvl) / 100 + 5);
            const calcHp = (base, lvl) => Math.floor((2 * base * lvl) / 100 + lvl + 10);
            const stats = { hp: calcHp(getStat('hp'), level), atk: calcStat(getStat('attack'), level), def: calcStat(getStat('defense'), level), spa: calcStat(getStat('special-attack'), level), spd: calcStat(getStat('special-defense'), level), spe: calcStat(getStat('speed'), level) };
            let availableMoves = data.moves.map(m => m.move.name).sort(() => 0.5 - Math.random());
            const moves = [];
            for (let name of availableMoves.slice(0, 4)) {
                const mRes = await fetch(`${this.base}/move/${name}`); const mData = await mRes.json();
                moves.push({ name: mData.name.replace('-', ' ').toUpperCase(), type: mData.type.name, power: mData.power || 0, accuracy: mData.accuracy });
            }
            const vCrystal = data.sprites.versions['generation-ii']['crystal'];
            const baseExp = data.base_experience || 64;
            const nextLvlExp = Math.pow(level + 1, 3);
            const bst = getStat('hp') + getStat('attack') + getStat('defense') + getStat('special-attack') + getStat('special-defense') + getStat('speed');
            const highTier = bst > 480;

            return {
                id: data.id, name: data.name.toUpperCase(), level: level, 
                maxHp: stats.hp, currentHp: stats.hp, stats: stats, 
                baseStats: { hp: getStat('hp'), atk: getStat('attack'), def: getStat('defense'), spa: getStat('special-attack'), spd: getStat('special-defense'), spe: getStat('speed') },
                exp: 0, nextLvlExp: nextLvlExp, baseExp: baseExp,
                stages: { atk:0, def:0, spa:0, spd:0, spe:0 },
                types: data.types.map(t => t.type.name), moves: moves, isShiny: isShiny,
                frontSprite: isShiny ? vCrystal.front_shiny_transparent : vCrystal.front_transparent,
                backSprite: isShiny ? vCrystal.back_shiny_transparent : vCrystal.back_transparent,
                icon: data.sprites.versions['generation-vii']['icons'].front_default, cry: data.cries.latest, isBoss: false, 
                failedCatches: 0, rageLevel: 0, isHighTier: highTier
            };
        } catch (e) { return null; }
    }
};

// --- 4. INPUT ---
const Input = {
    focus: 0, mode: 'NONE', lcdEnabled: false,
    init() { document.addEventListener('keydown', (e) => this.handleKey(e)); },
    setMode(m, resetIndex = 0) { this.mode = m; this.focus = resetIndex; this.updateVisuals(); },
    updateVisuals() {
        document.querySelectorAll('.focused').forEach(el => el.classList.remove('focused'));
        let target = null;
        if (this.mode === 'BATTLE') {
            const opts = ['opt-fight', 'opt-pkmn', 'opt-pack', 'opt-run'];
            target = document.getElementById(opts[this.focus]);
        } else if (this.mode === 'CONTINUE') {
            const opts = ['opt-continue', 'opt-newgame'];
            target = document.getElementById(opts[this.focus]);
        } else if (this.mode === 'CONFIRM_RUN') {
            const opts = document.querySelectorAll('#action-menu .menu-item');
            target = opts[this.focus];
        } else if (this.mode === 'MOVES') {
            const opts = document.querySelectorAll('#move-grid .move-btn');
            target = opts[this.focus];
        } else if (this.mode === 'SELECTION') {
            target = document.getElementById(`ball-${this.focus}`);
            const cursor = document.getElementById('sel-cursor');
            const positions = [25, 90, 155];
            cursor.style.left = positions[this.focus] + 'px';
            const p = Game.tempSelectionList[this.focus];
            if(p && this.lastFocus !== this.focus) {
                this.lastFocus = this.focus;
                AudioEngine.playCry(p.cry);
                const prevImg = document.getElementById('sel-preview-img');
                const prevShiny = document.getElementById('sel-preview-shiny');
                prevImg.src = p.frontSprite;
                prevImg.style.display = 'block';
                prevShiny.style.display = p.isShiny ? 'block' : 'none';
                Battle.typeText(`Will you choose\n${p.name}?`, null, true, 'sel-text-box');
            }
        } else if (this.mode === 'PARTY') {
            const opts = document.querySelectorAll('.party-slot');
            target = opts[this.focus];
            if(this.focus === opts.length) target = document.getElementById('party-close-btn');
        } else if (this.mode === 'CONTEXT') {
            const opts = document.querySelectorAll('#party-context .ctx-btn');
            target = opts[this.focus];
        } else if (this.mode === 'BAG') {
            const opts = document.querySelectorAll('.pack-item');
            if(this.focus < opts.length) target = opts[this.focus];
            else target = document.getElementById('pack-close-btn');
        } else if (this.mode === 'SUMMARY') {
            const opts = document.querySelectorAll('.sum-buttons .confirm-btn');
            target = opts[this.focus];
        }

        if (target) {
            target.classList.add('focused');
            if(target.scrollIntoViewIfNeeded) target.scrollIntoViewIfNeeded(false);
            else target.scrollIntoView({block: 'nearest'});
            if (this.mode === 'BAG' && target.classList.contains('pack-item')) target.onmouseover();
        }
    },
    lastFocus: -1,

    handleKey(e) {
        if(Battle.uiLocked && this.mode !== 'START' && this.mode !== 'CONTINUE' && this.mode !== 'NAME') return;
        const k = e.key;
        if (this.mode === 'START') {
            if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(k)) { Game.toggleLcd(); AudioEngine.playSfx('select'); }
            if (k === 'z' || k === 'Z' || k === 'Enter') Game.checkSave();
            return;
        }
        if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(k) && this.mode !== 'NAME') AudioEngine.playSfx('select');

        if (this.mode === 'NAME') {
            if (k === 'Enter') Game.confirmName();
            return; 
        }

        if (this.mode === 'CONTINUE') {
            if (k === 'ArrowUp' || k === 'ArrowDown') this.focus = this.focus === 0 ? 1 : 0;
            if (k === 'z' || k === 'Z' || k === 'Enter') document.getElementById(['opt-continue', 'opt-newgame'][this.focus]).click();
        } else if (this.mode === 'BATTLE') {
            if (k === 'ArrowRight' && this.focus % 2 === 0) this.focus++;
            if (k === 'ArrowLeft' && this.focus % 2 !== 0) this.focus--;
            if (k === 'ArrowDown' && this.focus < 2) this.focus += 2;
            if (k === 'ArrowUp' && this.focus > 1) this.focus -= 2;
            if (k === 'z' || k === 'Z') document.getElementById(['opt-fight', 'opt-pkmn', 'opt-pack', 'opt-run'][this.focus]).click();
        } else if (this.mode === 'CONFIRM_RUN') {
            if (k === 'ArrowRight' || k === 'ArrowDown') this.focus = 1;
            if (k === 'ArrowLeft' || k === 'ArrowUp') this.focus = 0;
            if (k === 'z' || k === 'Z') document.querySelectorAll('#action-menu .menu-item')[this.focus].click();
            if (k === 'x' || k === 'X') Battle.uiToMenu();
        } else if (this.mode === 'MOVES') {
            const len = document.querySelectorAll('.move-btn').length;
            if (k === 'ArrowRight' && this.focus % 2 === 0) this.focus++;
            if (k === 'ArrowLeft' && this.focus % 2 !== 0) this.focus--;
            if (k === 'ArrowDown' && this.focus < len - 2) this.focus += 2;
            if (k === 'ArrowUp' && this.focus > 1) this.focus -= 2;
            if (k === 'ArrowDown' && this.focus >= len - 2 && this.focus < len - 1) this.focus = len - 1;
            if (this.focus >= len) this.focus = len - 1;
            if (k === 'z' || k === 'Z') document.querySelectorAll('.move-btn')[this.focus].click();
            if (k === 'x' || k === 'X') Battle.uiToMenu();
        } else if (this.mode === 'SELECTION') {
            if (k === 'ArrowRight') this.focus = Math.min(2, this.focus + 1);
            if (k === 'ArrowLeft') this.focus = Math.max(0, this.focus - 1);
            if (k === 'z' || k === 'Z') document.getElementById(`ball-${this.focus}`).click();
        } else if (this.mode === 'BAG') {
            const len = document.querySelectorAll('.pack-item').length;
            if (k === 'ArrowDown') this.focus = Math.min(len, this.focus + 1);
            if (k === 'ArrowUp') this.focus = Math.max(0, this.focus - 1);
            if (k === 'z' || k === 'Z') { if(this.focus === len) document.getElementById('pack-close-btn').click(); else document.querySelectorAll('.pack-item')[this.focus].click(); }
            if (k === 'x' || k === 'X') Battle.uiToMenu();
        } else if (this.mode === 'PARTY') {
            const len = Game.party.length;
            if (k === 'ArrowDown') this.focus = Math.min(len, this.focus + 1);
            if (k === 'ArrowUp') this.focus = Math.max(0, this.focus - 1);
            if (k === 'z' || k === 'Z') { if(this.focus === len) document.getElementById('party-close-btn').click(); else document.querySelectorAll('.party-slot')[this.focus].click(); }
            if (k === 'x' || k === 'X') { if(document.getElementById('party-close-btn').innerText !== "CHOOSE A POKEMON") Battle.uiToMenu(); }
        } else if (this.mode === 'CONTEXT') {
            const len = document.querySelectorAll('#party-context .ctx-btn').length;
            if (k === 'ArrowDown') this.focus = Math.min(len - 1, this.focus + 1);
            if (k === 'ArrowUp') this.focus = Math.max(0, this.focus - 1);
            if (k === 'z' || k === 'Z') document.querySelectorAll('#party-context .ctx-btn')[this.focus].click();
            if (k === 'x' || k === 'X') Game.closeContext();
        } else if (this.mode === 'SUMMARY') {
            if (k === 'ArrowRight') {
                if (this.focus < 3) this.focus++;
                else Game.navSummary(1); 
            }
            if (k === 'ArrowLeft') {
                if (this.focus > 0) this.focus--;
                else Game.navSummary(-1); 
            }
            if (k === 'z' || k === 'Z') document.querySelectorAll('.sum-buttons .confirm-btn')[this.focus].click();
            if (k === 'x' || k === 'X') Game.closeSummary();
        }
        this.updateVisuals();
    }
};

// --- 5. GAME LOGIC ---
const Game = {
    tempSelection: null, tempSelectionList: [], party: [], activeSlot: 0, enemyMon: null, selectedItemKey: null,
    inventory: { potion: 1, superpotion: 0, hyperpotion: 0, maxpotion: 0, revive: 0, pokeball: 1, greatball: 0, ultraball: 0, masterball: 0 },
    state: 'START', selectedPartyIndex: -1, forcedSwitch: false, previousState: 'SELECTION', wins: 0, bossesDefeated: 0,
    playerName: 'PLAYER', currentSummaryIndex: 0,

    toggleLcd() {
        Input.lcdEnabled = !Input.lcdEnabled;
        const el = document.getElementById('lcd-check');
        const overlay = document.getElementById('lcd-overlay');
        if(Input.lcdEnabled) { el.classList.add('checked'); overlay.classList.add('active'); } else { el.classList.remove('checked'); overlay.classList.remove('active'); }
    },
    
    checkSave() {
        const saved = localStorage.getItem('gs_battler_save');
        if(saved) {
            const data = JSON.parse(saved);
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('continue-screen').classList.remove('hidden');
            document.getElementById('save-wins').innerText = data.wins || 0;
            document.getElementById('save-bosses').innerText = data.bossesDefeated || 0;
            document.getElementById('save-name').innerText = data.playerName || 'PLAYER';
            
            const prevRow = document.getElementById('save-preview');
            prevRow.innerHTML = '';
            data.party.forEach((p, i) => {
                const img = document.createElement('img'); img.src = p.icon; img.className = 'mini-icon';
                if(p.currentHp <= 0) img.classList.add('fainted');
                img.onclick = () => this.openSummary(p, 'READ_ONLY');
                prevRow.appendChild(img);
            });
            
            Input.setMode('CONTINUE');
        } else {
            document.getElementById('start-screen').classList.add('hidden');
            this.startNameInput();
        }
    },
    
    startNameInput() {
        document.getElementById('continue-screen').classList.add('hidden');
        document.getElementById('name-screen').classList.remove('hidden');
        document.getElementById('name-input').focus();
        Input.setMode('NAME');
    },

    confirmName() {
        const val = document.getElementById('name-input').value.trim().toUpperCase();
        this.playerName = val || 'GOLD';
        document.getElementById('name-screen').classList.add('hidden');
        this.newGame();
    },

    loadGame() {
        document.getElementById('continue-screen').classList.add('hidden');
        if(this.load()) {
            document.getElementById('selection-screen').classList.add('hidden');
            document.getElementById('scene').classList.remove('hidden');
            document.getElementById('dialog-box').classList.remove('hidden');
            document.getElementById('streak-box').classList.remove('hidden');
            document.getElementById('streak-box').innerText = `WINS: ${this.wins}`;
            
            let found = false;
            if(this.party[this.activeSlot] && this.party[this.activeSlot].currentHp > 0) {
                found = true;
            } else {
                for(let i=0; i<this.party.length; i++) {
                    if(this.party[i].currentHp > 0) {
                        this.activeSlot = i;
                        found = true;
                        break;
                    }
                }
            }
            if(!found) {
                this.party.forEach(p => p.currentHp = p.maxHp);
                this.activeSlot = 0;
            }

            this.state = 'BATTLE'; Battle.uiLocked = true;
            
            if (this.enemyMon && this.enemyMon.currentHp > 0) {
                const eSprite = document.getElementById('enemy-sprite');
                eSprite.style.opacity = 1;
                eSprite.src = this.enemyMon.frontSprite;
                Battle.setup(this.party[this.activeSlot], this.enemyMon, false, false);
                Battle.typeText(`Resume battle against\n${this.enemyMon.name}!`, () => {
                    Battle.uiLocked = false;
                    Battle.uiToMenu();
                });
            } else {
                this.startNewBattle(true);
            }
        }
    },

    newGame() {
        localStorage.removeItem('gs_battler_save');
        this.party = [];
        this.wins = 0;
        this.bossesDefeated = 0;
        this.inventory = { potion: 1, superpotion: 0, hyperpotion: 0, maxpotion: 0, revive: 0, pokeball: 1, greatball: 0, ultraball: 0, masterball: 0 };
        this.showSelectionScreen();
    },

    save() { 
        const currentEnemy = (this.state === 'BATTLE' && Battle.e && Battle.e.currentHp > 0) ? Battle.e : null;
        localStorage.setItem('gs_battler_save', JSON.stringify({ 
            party: this.party, 
            inventory: this.inventory, 
            wins: this.wins, 
            bossesDefeated: this.bossesDefeated,
            activeSlot: this.activeSlot,
            playerName: this.playerName,
            enemyMon: currentEnemy
        })); 
    },
    
    load() {
        const saved = localStorage.getItem('gs_battler_save');
        if(saved) { 
            const data = JSON.parse(saved); 
            this.party = data.party; 
            this.inventory = data.inventory; 
            this.wins = data.wins || 0; 
            this.bossesDefeated = data.bossesDefeated || 0;
            this.activeSlot = data.activeSlot || 0;
            this.playerName = data.playerName || 'PLAYER';
            this.enemyMon = data.enemyMon || null;
            return true; 
        }
        return false;
    },

    async showSelectionScreen() {
        this.state = 'SELECTION'; Input.setMode('NONE'); 
        document.getElementById('selection-screen').classList.remove('hidden');
        document.getElementById('scene').classList.add('hidden');
        document.getElementById('dialog-box').classList.add('hidden');
        document.getElementById('summary-panel').classList.add('hidden');
        document.getElementById('streak-box').classList.add('hidden');
        
        const table = document.getElementById('lab-table'); 
        const oldBalls = document.querySelectorAll('.pokeball-select'); oldBalls.forEach(b => b.remove());
        const ids = []; while(ids.length < 3) { const r = Math.floor(Math.random() * 251) + 1; if(!ids.includes(r)) ids.push(r); }
        this.tempSelectionList = await Promise.all(ids.map(id => API.getPokemon(id, 15)));
        this.tempSelectionList.forEach((p, i) => {
            if(!p) return;
            const ball = document.createElement('div'); ball.className = 'pokeball-select'; ball.id = `ball-${i}`;
            ball.onmouseenter = () => { Input.focus = i; Input.updateVisuals(); };
            ball.onclick = () => { this.selectPokemon(p); };
            table.appendChild(ball);
        });
        setTimeout(() => Input.setMode('SELECTION', 0), 100);
    },

    selectPokemon(p) { this.tempSelection = p; this.openSummary(p, 'SELECTION'); },
    
    openSummary(p, mode) {
        this.previousState = this.state; 
        if(mode) this.state = mode; else this.state = 'SUMMARY';
        Input.setMode('SUMMARY', 1);

        if (mode === 'SELECTION') {
            this.currentSummaryIndex = -1; 
        } else {
            const foundIdx = this.party.findIndex(mon => mon.id === p.id && mon.exp === p.exp);
            this.currentSummaryIndex = foundIdx !== -1 ? foundIdx : 0;
        }

        document.getElementById('summary-panel').classList.remove('hidden');
        this.renderSummaryData(p);
        
        const btn = document.getElementById('btn-action'); 
        btn.onclick = null;
        const prevBtn = document.getElementById('btn-prev');
        const nextBtn = document.getElementById('btn-next');

        prevBtn.onmouseenter = () => { Input.focus = 0; Input.updateVisuals(); };
        btn.onmouseenter = () => { Input.focus = 1; Input.updateVisuals(); };
        document.getElementById('btn-back-sum').onmouseenter = () => { Input.focus = 2; Input.updateVisuals(); };
        nextBtn.onmouseenter = () => { Input.focus = 3; Input.updateVisuals(); };

        if (this.state === 'SELECTION') { 
            btn.innerText = "I CHOOSE YOU!"; btn.disabled = false;
            btn.onclick = () => this.confirmSelection(); 
            prevBtn.disabled = true; nextBtn.disabled = true;
        } 
        else if (this.state === 'OVERFLOW') { 
            btn.innerText = "RELEASE"; btn.className = "confirm-btn danger"; btn.disabled = false;
            btn.onclick = () => this.releasePokemon(this.selectedPartyIndex); 
            prevBtn.disabled = true; nextBtn.disabled = true;
        }
        else if (this.state === 'READ_ONLY') {
             btn.innerText = "ACTION"; btn.disabled = true; 
             btn.className = "confirm-btn";
             prevBtn.disabled = false; nextBtn.disabled = false;
        }
        else if (this.state === 'HEAL') { 
            btn.innerText = "USE"; btn.disabled = false; btn.className = "confirm-btn";
            btn.onclick = () => this.applyItemToPokemon(this.selectedPartyIndex); 
            prevBtn.disabled = true; nextBtn.disabled = true;
        } 
        else { 
            btn.innerText = "SHIFT"; btn.disabled = false; btn.className = "confirm-btn";
            btn.onclick = () => this.partySwitch(); 
            prevBtn.disabled = false; nextBtn.disabled = false;
        }
    },

    renderSummaryData(p) {
        AudioEngine.playCry(p.cry);
        const statusEl = document.getElementById('sum-status-text');
        if (p.currentHp <= 0) { statusEl.innerText = "STATUS/FNT"; statusEl.style.color = "#c83828"; } 
        else { statusEl.innerText = "STATUS/OK"; statusEl.style.color = "black"; }

        document.getElementById('sum-name').innerText = p.name; 
        document.getElementById('sum-name').style.color = p.isShiny ? "#d8b030" : "black";
        document.getElementById('sum-shiny-icon').style.display = p.isShiny ? "block" : "none";
        document.getElementById('sum-sprite-img').src = p.frontSprite;
        document.getElementById('sum-types').innerHTML = p.types.map(t => `<span class="type-tag">${t.toUpperCase()}</span>`).join('');
        
        document.getElementById('sum-hp-txt').innerText = `${Math.max(0, p.currentHp)}/${p.maxHp}`;
        const hpPct = Math.min(100, Math.max(0, (p.currentHp / p.maxHp) * 100));
        const hpBar = document.getElementById('sum-hp-bar');
        hpBar.style.width = `${hpPct}%`;
        hpBar.style.background = hpPct > 50 ? "var(--hp-green)" : hpPct > 20 ? "var(--hp-yellow)" : "var(--hp-red)";

        document.getElementById('sum-exp-txt').innerText = `${p.exp}/${p.nextLvlExp}`;
        const expPct = (p.exp / p.nextLvlExp) * 100;
        document.getElementById('sum-exp-bar').style.width = `${Math.min(100, expPct)}%`;

        document.getElementById('summary-stats').innerHTML = `
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:4px;">
                <div>ATK ${p.stats.atk}</div><div>DEF ${p.stats.def}</div>
                <div>SPA ${p.stats.spa}</div><div>SPD ${p.stats.spd}</div>
                <div>SPE ${p.stats.spe}</div>
            </div>
        `;
        document.getElementById('summary-moves').innerHTML = p.moves.map(m => `
            <div class="move-row">
                <span class="move-name">${m.name}</span>
                <div class="move-info-grp">
                    <span class="move-pwr">PWR ${m.power > 0 ? m.power : '-'}</span>
                    <span class="move-type">${m.type.toUpperCase()}</span>
                </div>
            </div>`).join('');
    },

    navSummary(dir) {
        if (this.state === 'SELECTION' || this.state === 'HEAL' || this.state === 'OVERFLOW') return;
        
        let nextIdx = this.currentSummaryIndex + dir;
        if (nextIdx < 0) nextIdx = this.party.length - 1;
        if (nextIdx >= this.party.length) nextIdx = 0;
        
        this.currentSummaryIndex = nextIdx;
        if (this.state === 'PARTY' || this.state === 'SUMMARY') {
            this.selectedPartyIndex = nextIdx;
        }
        
        this.renderSummaryData(this.party[nextIdx]);
    },

    closeSummary() { 
        document.getElementById('summary-panel').classList.add('hidden'); 
        this.state = this.previousState; 
        if (this.state === 'SELECTION') Input.setMode('SELECTION', Input.focus); 
        else if (this.state === 'PARTY') Input.setMode('CONTEXT'); 
        else if (this.state === 'HEAL') Input.setMode('CONTEXT');
        else if (this.state === 'READ_ONLY') Input.setMode('CONTINUE');
    },

    async confirmSelection() {
        if(!this.tempSelection) return;
        document.getElementById('summary-panel').classList.add('hidden'); 
        this.party = [this.tempSelection];
        this.activeSlot = 0; this.wins = 0; this.bossesDefeated = 0; this.save();
        document.getElementById('selection-screen').classList.add('hidden');
        document.getElementById('scene').classList.remove('hidden');
        document.getElementById('dialog-box').classList.remove('hidden');
        document.getElementById('streak-box').classList.remove('hidden');
        document.getElementById('streak-box').innerText = "WINS: 0";
        this.state = 'BATTLE'; this.startNewBattle(true);
    },

    // --- UPDATED: Pass !isFirst to Setup to skip player anim on consecutive battles ---
    async startNewBattle(isFirst = false) {
        Battle.uiLocked = true;
        this.enemyMon = null;
        const eSprite = document.getElementById('enemy-sprite'); eSprite.style.opacity = 0; eSprite.src = ""; 
        Battle.typeText("Searching for wild Pokemon...", null, true);
        const p = this.party[this.activeSlot];
        
        let minLvl = Math.max(1, p.level - 2); let maxLvl = p.level + 1;
        const bossChance = (this.wins > 0 && this.wins % 5 === 0) ? 0.95 : 0.05;
        const isBoss = Math.random() < bossChance; 
        if(isBoss) { minLvl = p.level + 2; maxLvl = p.level + 5; }
        
        const r = Math.floor(Math.random() * 251) + 1;
        const lvl = Math.floor(Math.random() * (maxLvl - minLvl + 1)) + minLvl;
        this.enemyMon = await API.getPokemon(r, lvl);
        
        if (isBoss) { 
            this.enemyMon.isBoss = true; 
            this.enemyMon.name = "BOSS " + this.enemyMon.name;
            this.enemyMon.isHighTier = true;
            this.enemyMon.rageLevel = 3;
            this.enemyMon.maxHp = Math.floor(this.enemyMon.maxHp * 1.5);
            this.enemyMon.currentHp = this.enemyMon.maxHp;
        }
        
        const img = new Image();
        img.onload = () => { 
            eSprite.src = this.enemyMon.frontSprite; 
            // PARAM 3: Force Intro Text (true)
            // PARAM 4: Skip Player Anim if NOT first battle (!isFirst)
            Battle.setup(this.party[this.activeSlot], this.enemyMon, true, !isFirst); 
        };
        img.src = this.enemyMon.frontSprite;
        
        this.save(); 
    },

    openParty(forced) {
        if(Battle.uiLocked && !forced && this.state !== 'OVERFLOW' && this.state !== 'HEAL') return;
        if(this.state !== 'OVERFLOW' && this.state !== 'HEAL') this.state = 'PARTY'; 
        this.forcedSwitch = forced;
        document.getElementById('party-screen').classList.remove('hidden');
        document.getElementById('party-context').classList.add('hidden'); 
        const closeBtn = document.getElementById('party-close-btn');
        const header = document.getElementById('party-header-text');
        closeBtn.onmouseenter = () => { Input.focus = this.party.length; Input.updateVisuals(); };
        if (this.state === 'OVERFLOW') { header.innerText = "PARTY FULL! RELEASE ONE."; closeBtn.innerText = "SELECT TO RELEASE"; closeBtn.style.pointerEvents = "none"; closeBtn.style.display = "block"; } 
        else if (this.state === 'HEAL') { 
            header.innerText = "USE ON WHICH PKMN?"; 
            closeBtn.innerText = "CANCEL"; 
            closeBtn.onclick = () => { 
                document.getElementById('party-screen').classList.add('hidden'); 
                Battle.openPack(); 
            }; 
            closeBtn.style.pointerEvents = "auto"; closeBtn.style.display = "block"; 
        } 
        else { header.innerText = "POKEMON PARTY"; closeBtn.innerText = forced ? "CHOOSE A POKEMON" : "CLOSE"; closeBtn.onclick = forced ? null : () => Battle.uiToMenu(); if (forced) { closeBtn.style.display = "none"; } else { closeBtn.style.display = "block"; closeBtn.style.pointerEvents = "auto"; } }
        this.renderParty(); Input.setMode('PARTY');
    },
    renderParty() {
        const list = document.getElementById('party-list'); list.innerHTML = "";
        this.party.forEach((p, i) => {
            const div = document.createElement('div'); div.className = 'party-slot';
            if(p.currentHp <= 0) div.classList.add('fainted');
            if(i === this.activeSlot && p.currentHp > 0) div.classList.add('active-mon');
            if(i === 6) div.classList.add('new-catch'); 
            const pct = (p.currentHp/p.maxHp)*100; const color = pct > 50 ? "#48c050" : pct > 20 ? "#d8b030" : "#c83828";
            div.innerHTML = `<img class="slot-icon" src="${p.icon}"><div class="slot-info"><div class="slot-row"><span>${p.name}</span><span>Lv${p.level}</span></div><div class="slot-row"><div class="mini-hp-bg"><div class="mini-hp-fill" style="width:${pct}%; background:${color}"></div></div><span>${Math.max(0,p.currentHp)}/${p.maxHp}</span></div></div>`;
            div.onmouseenter = () => { Input.focus = i; Input.updateVisuals(); };
            div.onclick = () => { if(this.state === 'HEAL') { this.selectedPartyIndex = i; this.openContext(i); } else { this.openContext(i); } };
            list.appendChild(div);
        });
    },
    openContext(index) { 
        this.selectedPartyIndex = index; const ctx = document.getElementById('party-context'); ctx.classList.remove('hidden'); ctx.innerHTML = "";
        const addBtn = (txt, fn, cls='') => { const b = document.createElement('div'); b.className = `ctx-btn ${cls}`; b.innerText = txt; b.onclick = fn; const idx = ctx.children.length; b.onmouseenter = () => { Input.focus = idx; Input.updateVisuals(); }; ctx.appendChild(b); };
        if (this.state === 'HEAL') { addBtn("USE", () => this.applyItemToPokemon(index)); addBtn("SUMMARY", () => this.partyStats()); addBtn("CLOSE", () => this.closeContext()); } 
        else if (this.state === 'OVERFLOW') { addBtn("RELEASE", () => this.releasePokemon(index), "warn"); addBtn("SUMMARY", () => this.partyStats()); addBtn("CLOSE", () => this.closeContext()); } 
        else { addBtn("SHIFT", () => this.partySwitch()); addBtn("SUMMARY", () => this.partyStats()); addBtn("CLOSE", () => this.closeContext()); }
        Input.setMode('CONTEXT');
    },
    closeContext() { document.getElementById('party-context').classList.add('hidden'); Input.setMode('PARTY', this.selectedPartyIndex); },
    
    releasePokemon(index) {
        this.closeContext(); this.closeSummary(); 
        const releasedMon = this.party[index]; 
        this.party.splice(index, 1); 
        document.getElementById('party-screen').classList.add('hidden');
        
        if (index < this.activeSlot) { this.activeSlot--; }

        if (index === this.activeSlot) {
             if(this.activeSlot >= this.party.length) this.activeSlot = this.party.length - 1;
             Battle.animateSwap(releasedMon, this.party[this.activeSlot], () => { this.handleWin(true); }); 
        } else { 
             Battle.typeText(`Bye bye, ${releasedMon.name}!`, () => { this.handleWin(true); }); 
        }
    },
    
    applyItemToPokemon(index) {
        this.closeContext(); this.closeSummary(); 
        const p = this.party[index]; 
        const data = ITEMS[this.selectedItemKey];
        
        if (data.type === 'revive') { 
            if (p.currentHp > 0) { AudioEngine.playSfx('error'); return; } 
            p.currentHp = Math.floor(p.maxHp / 2); 
        } 
        else if (data.type === 'heal') { 
            if (p.currentHp <= 0 || p.currentHp >= p.maxHp) { AudioEngine.playSfx('error'); return; } 
            p.currentHp = Math.min(p.maxHp, p.currentHp + data.heal); 
        }
        
        this.inventory[this.selectedItemKey]--; AudioEngine.playSfx('heal'); this.renderParty(); 
        if(index === this.activeSlot) Battle.updateHUD(p, 'player');
        document.getElementById('party-screen').classList.add('hidden'); document.getElementById('pack-screen').classList.add('hidden'); document.getElementById('action-menu').classList.add('hidden'); 
        this.state = 'BATTLE'; Battle.typeText(`Used ${data.name} on ${p.name}!`, () => { Battle.endTurnItem(); });
    },

    partySwitch() {
        const idx = this.selectedPartyIndex; const mon = this.party[idx];
        if(mon.currentHp <= 0 || idx === this.activeSlot) { AudioEngine.playSfx('error'); return; }
        this.closeContext(); this.closeSummary(); document.getElementById('party-screen').classList.add('hidden');
        this.activeSlot = idx; this.state = 'BATTLE'; Battle.switchIn(mon, this.forcedSwitch);
    },
    partyStats() { this.closeContext(); this.openSummary(this.party[this.selectedPartyIndex], this.state); },
    
    distributeExp(totalExp, participants) {
        const share = Math.floor(totalExp / Math.max(1, participants.size));
        const queue = Array.from(participants);
        
        const processNext = (index) => {
            if (index >= queue.length) { this.finishWin(); return; }

            const pIndex = queue[index];
            const p = this.party[pIndex];
            
            if(!p || p.currentHp <= 0) { processNext(index + 1); return; }
            
            Battle.typeText(`${p.name} gained\n${share} EXP. Points!`, async () => {
                if(pIndex === this.activeSlot) {
                    await this.gainExpAnim(share, p);
                } else {
                    p.exp += share;
                    if (p.exp >= p.nextLvlExp) {
                        await this.processLevelUp(p);
                    }
                }
                processNext(index + 1);
            });
        };
        processNext(0);
    },

    gainExpAnim(amount, p) {
        p.exp += amount; 
        Battle.updateHUD(p, 'player');
        const steps = 20; let i = 0;
        return new Promise(resolve => {
            const loop = setInterval(() => { AudioEngine.playSfx('exp'); i++; if(i >= steps) { clearInterval(loop); check(); } }, 50);
            const check = async () => {
                if (p.exp >= p.nextLvlExp) {
                    await this.processLevelUp(p);
                    resolve();
                } else { resolve(); }
            }
        });
    },

    processLevelUp(p) {
        return new Promise(resolve => {
            p.exp -= p.nextLvlExp; p.level++; p.nextLvlExp = Math.pow(p.level + 1, 3);
            const oldMax = p.maxHp;
            const calcStat = (base, lvl) => Math.floor((2 * base * lvl) / 100 + 5);
            const calcHp = (base, lvl) => Math.floor((2 * base * lvl) / 100 + lvl + 10);
            p.stats.atk = calcStat(p.baseStats.atk, p.level); 
            p.stats.def = calcStat(p.baseStats.def, p.level);
            p.stats.spa = calcStat(p.baseStats.spa, p.level); 
            p.stats.spd = calcStat(p.baseStats.spd, p.level);
            p.stats.spe = calcStat(p.baseStats.spe, p.level); 
            p.stats.hp = calcHp(p.baseStats.hp, p.level);
            p.maxHp = p.stats.hp; 
            p.currentHp += (p.maxHp - oldMax);
            
            AudioEngine.playSfx('levelup');
            Battle.typeText(`${p.name} grew to Level ${p.level}!`, () => { 
                if(this.activeSlot === this.party.indexOf(p)) Battle.updateHUD(p, 'player'); 
                resolve(); 
            });
        });
    },
    
    finishWin() {
        const p = this.party[this.activeSlot];
        // Healing after win
        const healPct = 0.15 + Math.random() * 0.20; 
        const healAmt = Math.floor(p.maxHp * healPct);
        if(healAmt > 0) { 
            p.currentHp = Math.min(p.maxHp, p.currentHp + healAmt); 
            AudioEngine.playSfx('heal');
            Battle.updateHUD(p, 'player'); 
        }
        const dropChance = this.enemyMon.isBoss ? 0.60 : 0.15; 
        if (Math.random() < dropChance) { 
            const itemType = this.getLoot(this.enemyMon.isBoss);
            this.inventory[itemType]++; 
            AudioEngine.playSfx('funfair'); 
            Battle.typeText(`${this.enemyMon.name} dropped a ${ITEMS[itemType].name}!`, () => { this.save(); setTimeout(() => this.startNewBattle(false), 2000); }); 
        } else { this.save(); setTimeout(() => this.startNewBattle(false), 1000); }
    },

    getLoot(isBoss) {
        const rand = Math.random();
        if (isBoss) {
            if(rand < 0.05) return 'masterball'; 
            if(rand < 0.15) return 'maxpotion'; 
            if(rand < 0.35) return 'hyperpotion'; 
            if(rand < 0.55) return 'ultraball';
            if(rand < 0.80) return 'greatball';
            return 'revive';
        } else {
            if(rand < 0.005) return 'masterball'; 
            if(rand < 0.03) return 'hyperpotion'; 
            if(rand < 0.10) return 'superpotion'; 
            if(rand < 0.15) return 'ultraball';
            if(rand < 0.40) return 'greatball';
            if(rand < 0.70) return 'pokeball';
            return 'potion';
        }
    },
    
    handleWin(wasCaught) {
        this.wins++;
        if (this.enemyMon.isBoss) this.bossesDefeated++; 
        document.getElementById('streak-box').innerText = `WINS: ${this.wins}`;
        this.state = 'BATTLE'; 
        
        if (!wasCaught) {
            this.enemyMon.currentHp = 0; 
        }
        
        if (wasCaught) { 
            this.save(); setTimeout(() => this.startNewBattle(false), 1500); 
        } 
        else {
            const enemy = this.enemyMon;
            const b = enemy.baseExp;
            const L = enemy.level;
            const Lp = this.party[this.activeSlot].level;
            
            let rawExp = (b * L) / 5;
            const scale = Math.pow((2 * L + 10) / (L + Lp + 10), 2.5);
            let xpGain = Math.floor(rawExp * scale) + 1;

            if (enemy.isBoss) xpGain = Math.floor(xpGain * 5);

            Game.distributeExp(xpGain, Battle.participants);
        }
    },
    
    handleLoss() {
        if(this.party.some(p => p.currentHp > 0)) { this.openParty(true); }
        else { 
            document.getElementById('game-boy').style.animation = "flashWhite 0.5s"; AudioEngine.playCry(this.party[this.activeSlot].cry); 
            Battle.typeText(`Player is out of Pokemon...`, () => setTimeout(() => { 
                document.getElementById('game-boy').style.animation = ""; localStorage.removeItem('gs_battler_save');
                this.party = []; 
                this.inventory = { potion: 1, superpotion: 0, hyperpotion: 0, maxpotion: 0, revive: 0, pokeball: 1, greatball: 0, ultraball: 0, masterball: 0 };
                this.showSelectionScreen();
            }, 2500)); 
        }
    }
};

// --- 6. BATTLE LOGIC ---
const Battle = {
    p: null, e: null, textEl: document.getElementById('text-content'), uiLocked: true, typeInterval: null,
    participants: new Set(),

    spawnSmoke(x, y) {
        const count = 12;
        for(let i=0; i<count; i++) {
            const s = document.createElement('div'); s.className = 'smoke-particle';
            const angle = (i / count) * 2 * Math.PI;
            const velocity = 40 + Math.random() * 15;
            const tx = Math.cos(angle) * velocity;
            const ty = Math.sin(angle) * velocity;
            s.style.left = x + 'px'; s.style.top = y + 'px'; 
            s.style.setProperty('--tx', tx + 'px'); s.style.setProperty('--ty', ty + 'px');
            document.getElementById('scene').appendChild(s);
            setTimeout(() => s.remove(), 600);
        }
    },
    
    triggerRageAnim() {
        document.getElementById('scene').classList.add('anim-violent');
        AudioEngine.playCry(this.e.cry); 
        AudioEngine.playSfx('rumble');
        setTimeout(() => document.getElementById('scene').classList.remove('anim-violent'), 500);
    },

    // UPDATED: setup now accepts skipPlayerAnim
    setup(player, enemy, playIntro, skipPlayerAnim) {
        this.p = player; this.e = enemy;
        this.participants.clear();
        this.participants.add(Game.activeSlot); 

        const pSprite = document.getElementById('player-sprite'); const eSprite = document.getElementById('enemy-sprite');
        this.resetSprite(eSprite); eSprite.style.opacity = 0; 
        
        // Logic for Player Sprite Visibility
        pSprite.src = player.backSprite; 
        if(!playIntro || skipPlayerAnim) pSprite.style.opacity = 1; else pSprite.style.opacity = 0;

        this.updateHUD(player, 'player'); this.updateHUD(enemy, 'enemy');
        const nameEl = document.getElementById('enemy-name');
        if(enemy.isBoss) { nameEl.classList.add('boss-name'); this.startBossEncounter(player, enemy, playIntro, skipPlayerAnim, eSprite); } 
        else { nameEl.classList.remove('boss-name'); this.startEncounter(player, enemy, playIntro, skipPlayerAnim, eSprite); }
        document.getElementById('opt-fight').onmouseenter = () => { if(!this.uiLocked) { Input.focus = 0; Input.updateVisuals(); }};
        document.getElementById('opt-pkmn').onmouseenter = () => { if(!this.uiLocked) { Input.focus = 1; Input.updateVisuals(); }};
        document.getElementById('opt-pack').onmouseenter = () => { if(!this.uiLocked) { Input.focus = 2; Input.updateVisuals(); }};
        document.getElementById('opt-run').onmouseenter = () => { if(!this.uiLocked) { Input.focus = 3; Input.updateVisuals(); }};
    },
    
    // UPDATED: Logic to skip Player Ball throw animation if already out
    startEncounter(player, enemy, playIntro, skipPlayerAnim, eSprite) {
        this.buildMoveMenu(); clearInterval(this.typeInterval); this.textEl.innerHTML = "";
        if(playIntro) {
            setTimeout(() => {
                eSprite.style.opacity = 1;
                this.typeText(`Wild ${enemy.name}\nappeared!`, () => {
                    AudioEngine.playCry(enemy.cry);
                    let sparkleDelay = 0; if(enemy.isShiny) { setTimeout(() => this.playSparkle('enemy'), 1200); sparkleDelay += 1500; }
                    setTimeout(() => {
                        if(skipPlayerAnim) {
                             this.uiLocked = false; 
                             this.uiToMenu();
                        } else {
                            this.triggerPlayerEntry(player); let pSparkleDelay = 0;
                            if(player.isShiny) { setTimeout(() => this.playSparkle('player'), 800); pSparkleDelay += 1500; }
                            setTimeout(() => { this.uiLocked = false; this.uiToMenu(); }, 1000 + pSparkleDelay);
                        }
                    }, 1200 + sparkleDelay);
                });
            }, 500);
        } else {
            eSprite.style.opacity = 1;
            this.uiLocked = false;
            this.uiToMenu();
        }
    },
    
    // UPDATED: Boss Version
    startBossEncounter(player, enemy, playIntro, skipPlayerAnim, eSprite) {
        this.buildMoveMenu(); clearInterval(this.typeInterval); this.textEl.innerHTML = "";
        if(playIntro) {
            setTimeout(() => {
                eSprite.style.opacity = 1;
                this.typeText(`The ${enemy.name}\nappeared!`, () => {
                    AudioEngine.playCry(enemy.cry); AudioEngine.playSfx('rumble'); document.getElementById('scene').classList.add('boss-intro');
                    setTimeout(() => {
                        document.getElementById('scene').classList.remove('boss-intro');
                        let sparkleDelay = 0; if(enemy.isShiny) { setTimeout(() => this.playSparkle('enemy'), 200); sparkleDelay += 1500; }
                        setTimeout(() => {
                            if(skipPlayerAnim) {
                                this.uiLocked = false; 
                                this.uiToMenu();
                            } else {
                                this.triggerPlayerEntry(player); let pSparkleDelay = 0;
                                if(player.isShiny) { setTimeout(() => this.playSparkle('player'), 800); pSparkleDelay += 1500; }
                                setTimeout(() => { this.uiLocked = false; this.uiToMenu(); }, 1000 + pSparkleDelay);
                            }
                        }, 500 + sparkleDelay);
                    }, 1000); 
                });
            }, 500);
        } else {
             eSprite.style.opacity = 1;
             this.uiLocked = false;
             this.uiToMenu();
        }
    },

    resetSprite(el) { el.classList.remove('anim-faint', 'anim-enter', 'anim-return', 'anim-hit', 'anim-deflect'); el.style.transform = "scale(1)"; el.style.filter = "none"; void el.offsetWidth; el.style.opacity = 1; },
    
    triggerPlayerEntry(mon) {
        AudioEngine.playSfx('ball'); 
        const sprite = document.getElementById('player-sprite'); this.resetSprite(sprite); sprite.style.opacity = 0; 
        sprite.classList.add('anim-enter'); 
        this.spawnSmoke(60, 150); 
        setTimeout(() => AudioEngine.playCry(mon.cry), 200); 
        setTimeout(() => { sprite.classList.remove('anim-enter'); sprite.style.opacity = 1; }, 600);
    },
    
    switchIn(newMon, wasForced) {
        const sprite = document.getElementById('player-sprite'); const oldMonFainted = this.p.currentHp <= 0;
        this.p = newMon; 
        this.participants.add(Game.activeSlot); 
        this.updateHUD(newMon, 'player'); this.buildMoveMenu();
        document.getElementById('action-menu').classList.add('hidden'); document.getElementById('move-menu').classList.add('hidden');
        const performSwitch = () => {
            sprite.classList.remove('anim-return'); 
            // UPDATED: Fix glitch where sprite appears full size before growing
            sprite.style.opacity = 0; 
            
            sprite.src = newMon.backSprite;
            this.typeText(`Go! ${newMon.name}!`, () => {
                this.triggerPlayerEntry(newMon); let delay = 1000; if(newMon.isShiny) { setTimeout(() => this.playSparkle('player'), 800); delay += 1200; }
                setTimeout(() => {
                    sprite.style.opacity = 1; 
                    if(wasForced) { this.uiLocked = false; this.uiToMenu(); }
                    else { setTimeout(() => { const enemyMove = this.e.moves[Math.floor(Math.random() * this.e.moves.length)]; this.processMove(this.e, this.p, enemyMove, false, () => { this.uiLocked = false; this.uiToMenu(); }); }, 500); }
                }, delay);
            });
        };
        if (oldMonFainted) { this.resetSprite(sprite); sprite.style.opacity = 0; performSwitch(); } 
        else { 
            AudioEngine.playSfx('ball'); 
            sprite.classList.add('anim-return'); 
            this.spawnSmoke(60, 150);
            setTimeout(() => performSwitch(), 400); 
        }
    },
    
    animateSwap(oldMon, newMon, cb) {
        const sprite = document.getElementById('player-sprite');
        this.typeText(`Bye bye, ${oldMon.name}!`, () => {
            AudioEngine.playSfx('ball'); 
            sprite.classList.add('anim-return');
            this.spawnSmoke(60, 150);
            setTimeout(() => {
                sprite.classList.remove('anim-return'); sprite.style.opacity = 0; sprite.src = newMon.backSprite;
                this.typeText(`${newMon.name} was sent out!`, () => {
                    this.triggerPlayerEntry(newMon); setTimeout(() => { sprite.style.opacity = 1; if(cb) setTimeout(cb, 1000); }, 1000);
                });
            }, 400);
        });
    },

    buildMoveMenu() {
        const menu = document.getElementById('move-menu'); menu.innerHTML = '';
        const infoPanel = document.createElement('div'); infoPanel.id = 'move-info'; infoPanel.innerHTML = '<div>SELECT<br>A MOVE</div>';
        const grid = document.createElement('div'); grid.id = 'move-grid';
        this.p.moves.forEach((m, i) => { 
            const btn = document.createElement('div'); btn.className = 'move-btn'; btn.innerText = m.name; btn.onclick = () => this.performTurn(m); 
            const updateInfo = () => { infoPanel.innerHTML = `<div>TYPE/<br>${m.type.toUpperCase()}</div><div>PWR/${m.power > 0 ? m.power : '-'}</div><div>ACC/${m.accuracy || '-'}%</div>`; };
            btn.onmouseover = () => { updateInfo(); }; btn.onmouseenter = () => { Input.focus = i; Input.updateVisuals(); updateInfo(); }; grid.appendChild(btn); 
        });
        const backBtn = document.createElement('div'); backBtn.className = 'move-btn cancel'; backBtn.innerText = 'BACK'; backBtn.onclick = () => this.uiToMenu();
        const idx = this.p.moves.length; backBtn.onmouseenter = () => { Input.focus = idx; Input.updateVisuals(); infoPanel.innerHTML = '<div>RETURN<br>TO MENU</div>'; }; grid.appendChild(backBtn);
        menu.appendChild(infoPanel); menu.appendChild(grid);
    },

    playSparkle(side) {
        AudioEngine.playSfx('shiny');
        const container = document.getElementById('fx-container'); const rect = side === 'enemy' ? {x:239, y:61} : {x:80, y:130}; const spread = side === 'enemy' ? 30 : 60;
        for(let i=0; i<5; i++) { const star = document.createElement('div'); star.className = 'shiny-star'; star.style.left = (rect.x - spread + Math.random()*(spread*2)) + 'px'; star.style.top = (rect.y - spread + Math.random()*(spread*2)) + 'px'; star.style.animation = `sparkle 0.6s ease-out ${i*0.15}s forwards`; container.appendChild(star); setTimeout(() => star.remove(), 1500); }
    },

    updateHUD(mon, side) {
        document.getElementById(`${side}-name`).innerText = mon.name; document.getElementById(`${side}-lvl`).innerText = `Lv${mon.level}`;
        const pct = (Math.max(0,mon.currentHp) / mon.maxHp) * 100;
        const bar = document.getElementById(`${side}-hp-bar`); bar.style.width = Math.max(0, pct) + "%";
        bar.style.backgroundColor = pct > 50 ? "#48c050" : pct > 20 ? "#d8b030" : "#c83828";
        if (side === 'player') {
            document.getElementById('player-hp-text').innerText = `${Math.floor(Math.max(0, mon.currentHp))}/${mon.maxHp}`;
            const expPct = (mon.exp / mon.nextLvlExp) * 100;
            document.getElementById('player-exp-bar').style.width = Math.min(100, expPct) + "%";
        } else {
            const aggroEl = document.getElementById('aggro-icon');
            aggroEl.className = 'aggro-icon'; aggroEl.innerText = '';
            if (mon.rageLevel === 1) { aggroEl.innerText = '!'; aggroEl.classList.add('aggro-1'); }
            else if (mon.rageLevel === 2) { aggroEl.innerText = '!!'; aggroEl.classList.add('aggro-2'); }
            else if (mon.rageLevel >= 3) { aggroEl.innerText = '💢'; aggroEl.classList.add('aggro-3'); }
        }
    },

    typeText(text, cb, fast=false, targetId = 'text-content') {
        const el = document.getElementById(targetId);
        clearInterval(this.typeInterval); 
        el.innerHTML = ""; 
        if(targetId === 'text-content') {
             if(document.getElementById('action-menu').classList.contains('hidden')) { el.classList.add('full-width'); } else { el.classList.remove('full-width'); }
        }
        let i = 0;
        this.typeInterval = setInterval(() => { 
            const char = text.charAt(i);
            if(char === '\n') el.innerHTML += '<br>';
            else el.innerHTML += char; 
            i++; 
            if (i >= text.length) { clearInterval(this.typeInterval); if (cb) setTimeout(cb, 1000); } 
        }, fast ? 10 : 20);
    },

    openPack() { 
        if(this.uiLocked) return; 
        document.getElementById('pack-screen').classList.remove('hidden'); 
        document.querySelector('.bag-icon').style.backgroundImage = "url('https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/backpack.png')";
        this.renderPackList(); Input.setMode('BAG');
        const closeBtn = document.getElementById('pack-close-btn'); closeBtn.onmouseenter = () => { Input.focus = Object.keys(Game.inventory).length; Input.updateVisuals(); };
    },
    renderPackList() {
        const list = document.getElementById('pack-list'); list.innerHTML = "";
        Object.keys(Game.inventory).forEach((key, i) => {
            const count = Game.inventory[key]; const data = ITEMS[key];
            const div = document.createElement('div'); div.className = 'pack-item'; if (count === 0) div.classList.add('disabled');
            div.innerHTML = `<span>${data.name}</span> <span>x${count}</span>`;
            const showDesc = () => { document.getElementById('pack-desc').innerText = data.desc; if(data.img) { document.querySelector('.bag-icon').style.backgroundImage = `url('${data.img}')`; } };
            div.onmouseover = () => showDesc(); div.onmouseenter = () => { Input.focus = i; Input.updateVisuals(); showDesc(); };
            div.onclick = () => { if (count > 0) this.useItem(key); }; list.appendChild(div);
        });
    },
    
    useItem(key) {
        const data = ITEMS[key];
        if(data.type === 'ball') this.typeText(`You threw a\n${data.name}!`);
        
        if (data.type === 'heal' || data.type === 'revive') { 
            Game.selectedItemKey = key; 
            Game.state = 'HEAL'; 
            document.getElementById('pack-screen').classList.add('hidden'); 
            Game.openParty(false); 
            return; 
        } 
        
        Game.inventory[key]--; document.getElementById('pack-screen').classList.add('hidden'); document.getElementById('action-menu').classList.add('hidden');
        Input.setMode('NONE'); 
        if (data.type === 'ball') {
            setTimeout(() => {
                if (this.e.isBoss && key !== 'masterball') { 
                    let deflectChance = 0;
                    if (this.e.rageLevel === 1) deflectChance = 0.15;
                    if (this.e.rageLevel === 2) deflectChance = 0.30;
                    if (this.e.rageLevel === 3) deflectChance = 0.60;

                    if (Math.random() < deflectChance) { 
                        AudioEngine.playSfx('clank');
                        document.getElementById('enemy-sprite').classList.add('anim-deflect');
                        setTimeout(() => document.getElementById('enemy-sprite').classList.remove('anim-deflect'), 300);
                        this.typeText("The BOSS deflected\nthe Ball!", () => this.endTurnItem()); 
                        return; 
                    } 
                }
                this.attemptCatch(key);
            }, 1000);
        }
    },
    
    attemptCatch(ballKey) {
        const ballData = ITEMS[ballKey];
        AudioEngine.playSfx('throw');
        const ball = document.createElement('div'); ball.className = `pokeball-anim ${ballData.css}`;
        ball.style.animation = "captureThrow 0.6s ease-out forwards";
        document.getElementById('scene').appendChild(ball);
        
        setTimeout(() => {
            const eSprite = document.getElementById('enemy-sprite'); eSprite.style.filter = 'brightness(5) grayscale(100%)'; eSprite.style.transform = 'scale(0)';
            this.spawnSmoke(230, 70); 
            AudioEngine.playSfx('catch_success'); 
            ball.style.animation = "captureShake 1.0s ease-in-out infinite";
            
            const catchRate = ballData.rate;
            let catchProb = ((3 * this.e.maxHp - 2 * this.e.currentHp) / (3 * this.e.maxHp)) * catchRate;
            if (ballKey === 'pokeball') catchProb = catchProb * 0.5;
            const rng = Math.random(); const isCaught = rng < catchProb;
            let shakes = 0; const maxShakes = 3;
            
            const shakeInterval = setInterval(() => {
                shakes++; AudioEngine.playSfx('catch_click');
                if (!isCaught && shakes > 0 && Math.random() > 0.5) { clearInterval(shakeInterval); fail(); } 
                else if (shakes >= maxShakes) { clearInterval(shakeInterval); if (isCaught) success(); else fail(); }
            }, 800);
            
            const success = () => {
                AudioEngine.playSfx('heal'); 
                const computedStyle = window.getComputedStyle(ball);
                const matrix = computedStyle.transform;
                ball.style.animation = 'none';
                ball.style.transform = matrix; 
                ball.classList.add('pokeball-caught'); 

                this.typeText(`Gotcha! ${this.e.name} was caught!`, () => {
                    document.getElementById('scene').removeChild(ball);
                    Game.party.push(this.e); 
                    if(Game.party.length > 6) { Game.state = 'OVERFLOW'; Game.openParty(true); } else { Game.handleWin(true); }
                });
            };
            
            const fail = () => {
                ball.style.display = 'none'; eSprite.style.filter = 'none'; eSprite.style.transform = 'scale(1)';
                this.spawnSmoke(230, 70); 
                this.e.failedCatches++;
                const rageChance = 0.25 + (this.e.failedCatches * 0.10);
                if(Math.random() < rageChance) { this.e.rageLevel = Math.min(3, (this.e.rageLevel || 0) + 1); }
                this.updateHUD(this.e, 'enemy'); 
                AudioEngine.playSfx('ball');
                this.typeText(`Shoot! It was so close!`, () => {
                     document.getElementById('scene').removeChild(ball);
                     const rageLevel = this.e.failedCatches;
                     const shakeClass = rageLevel > 2 ? 'anim-violent' : 'anim-hit';
                     const scene = document.getElementById('scene');
                     scene.classList.add(shakeClass); AudioEngine.playCry(this.e.cry); AudioEngine.playSfx('rumble');
                     setTimeout(() => scene.classList.remove(shakeClass), 500);
                     this.typeText(`It's getting aggressive!`, () => { this.endTurnItem(); });
                });
            };
        }, 600);
    },

    endTurnItem() {
        this.uiLocked = true; 
        setTimeout(() => { 
            const enemyMove = this.e.moves[Math.floor(Math.random() * this.e.moves.length)]; 
            this.processMove(this.e, this.p, enemyMove, false, () => { this.uiLocked = false; this.uiToMenu(); }); 
        }, 1000);
    },

    askRun() {
        if(this.uiLocked) return;
        if(this.e.isBoss) { this.typeText("Can't escape a BOSS!", () => setTimeout(() => this.uiToMenu(), 1000)); return; }
        const menu = document.getElementById('action-menu');
        menu.innerHTML = `
            <div class="menu-item centered" onclick="Battle.confirmRun(true)">YES</div>
            <div class="menu-item centered" onclick="Battle.confirmRun(false)">NO</div>
        `;
        this.textEl.innerHTML = "Give up and\nrestart?";
        Input.setMode('CONFIRM_RUN');
    },
    
    confirmRun(yes) {
        if(yes) { localStorage.removeItem('gs_battler_save'); location.reload(); } 
        else {
            const menu = document.getElementById('action-menu');
            menu.innerHTML = `<div class="menu-item" id="opt-fight" onclick="Battle.uiToMoves()">FIGHT</div><div class="menu-item" id="opt-pkmn" onclick="Game.openParty(false)">PKMN</div><div class="menu-item" id="opt-pack" onclick="Battle.openPack()">PACK</div><div class="menu-item" id="opt-run" onclick="Battle.askRun()">RUN</div>`;
            document.getElementById('opt-fight').onmouseenter = () => { if(!this.uiLocked) { Input.focus = 0; Input.updateVisuals(); }};
            document.getElementById('opt-pkmn').onmouseenter = () => { if(!this.uiLocked) { Input.focus = 1; Input.updateVisuals(); }};
            document.getElementById('opt-pack').onmouseenter = () => { if(!this.uiLocked) { Input.focus = 2; Input.updateVisuals(); }};
            document.getElementById('opt-run').onmouseenter = () => { if(!this.uiLocked) { Input.focus = 3; Input.updateVisuals(); }};
            this.uiToMenu();
        }
    },
    
    run() { this.askRun(); },
    uiToMoves() { if(this.uiLocked) return; document.getElementById('action-menu').classList.add('hidden'); document.getElementById('move-menu').classList.remove('hidden'); this.textEl.innerHTML = "Select a move."; Input.setMode('MOVES'); },
    uiToMenu() { document.getElementById('move-menu').classList.add('hidden'); document.getElementById('pack-screen').classList.add('hidden'); document.getElementById('party-screen').classList.add('hidden'); document.getElementById('action-menu').classList.remove('hidden'); this.textEl.innerHTML = `What will<br>${this.p.name} do?`; Input.setMode('BATTLE'); },
    
    calcDamage(attacker, defender, move) {
        if (move.power === 0) return { damage: 0, desc: "status", eff: 1 };
        const acc = move.accuracy || 100; if (Math.random() * 100 > acc) return { damage: 0, desc: "missed", eff: 0 };
        const typeChart = { normal: {rock:0.5, ghost:0, steel:0.5}, fire: {fire:0.5, water:0.5, grass:2, ice:2, bug:2, rock:0.5, dragon:0.5, steel:2}, water: {fire:2, water:0.5, grass:0.5, ground:2, rock:2, dragon:0.5}, electric: {water:2, electric:0.5, grass:0.5, ground:0, flying:2, dragon:0.5}, grass: {fire:0.5, water:2, grass:0.5, poison:0.5, ground:2, flying:0.5, bug:0.5, rock:2, dragon:0.5, steel:0.5}, ice: {fire:0.5, water:0.5, grass:2, ice:0.5, ground:2, flying:2, dragon:2, steel:0.5}, fighting: {normal:2, ice:2, poison:0.5, flying:0.5, psychic:0.5, bug:0.5, rock:2, ghost:0, dark:2, steel:2}, poison: {grass:2, poison:0.5, ground:0.5, bug:1, rock:0.5, ghost:0.5, steel:0}, ground: {fire:2, electric:2, grass:0.5, poison:2, flying:0, bug:0.5, rock:2, steel:2}, flying: {electric:0.5, grass:2, fighting:2, bug:2, rock:0.5, steel:0.5}, psychic: {fighting:2, poison:2, psychic:0.5, dark:0, steel:0.5}, bug: {fire:0.5, grass:2, fighting:0.5, poison:0.5, flying:0.5, psychic:2, ghost:0.5, dark:2, steel:0.5}, rock: {fire:2, ice:2, fighting:0.5, ground:0.5, flying:2, bug:2, steel:0.5}, ghost: {normal:0, psychic:2, ghost:2, dark:0.5, steel:0.5}, dragon: {dragon:2, steel:0.5}, dark: {fighting:0.5, psychic:2, ghost:2, dark:0.5, steel:0.5}, steel: {fire:0.5, water:0.5, electric:0.5, ice:2, rock:2, steel:0.5} };
        const isSpecial = ['water', 'grass', 'fire', 'ice', 'electric', 'psychic', 'dragon', 'dark'].includes(move.type);
        const A = isSpecial ? attacker.stats.spa : attacker.stats.atk; const D = isSpecial ? defender.stats.spd : defender.stats.def;
        let dmg = Math.floor( Math.floor( Math.floor(2 * attacker.level / 5 + 2) * move.power * A / D ) / 50 ) + 2;
        if (attacker.types.includes(move.type)) dmg = Math.floor(dmg * 1.5);
        let typeMod = 1; defender.types.forEach(defType => { if (typeChart[move.type] && typeChart[move.type][defType] !== undefined) typeMod *= typeChart[move.type][defType]; });
        dmg = Math.floor(dmg * typeMod);
        let isCrit = false; const critChance = attacker.isBoss ? 0.25 : 0.0625; if (Math.random() < critChance) { isCrit = true; dmg *= 2; }
        const message = typeMod > 1 ? "It's super\neffective!" : (typeMod === 0 ? "It had\nno effect!" : (typeMod < 1 ? "It's not very\neffective..." : ""));
        return { damage: dmg, desc: message, eff: typeMod, isCrit: isCrit };
    },

    processMove(attacker, defender, move, isPlayer, next, remainingAttacks = 0, isFollowUp = false) {
        const moveText = isFollowUp ? `${attacker.name} used\n${move.name} again!` : `${attacker.name} used\n${move.name}!`;
        this.typeText(moveText, () => {
            AudioEngine.playSfx(move.type);
            const scene = document.getElementById('scene'); scene.classList.add(`fx-${move.type}`);
            const targetSprite = isPlayer ? document.getElementById('enemy-sprite') : document.getElementById('player-sprite');
            setTimeout(() => {
                scene.classList.remove(`fx-${move.type}`);
                const result = this.calcDamage(attacker, defender, move);
                if (result.desc === "missed") { AudioEngine.playSfx('miss'); this.typeText(`${attacker.name}'s attack\nmissed!`, next); return; }
                if (result.desc === "status") { this.typeText("But it failed!", next); return; }
                
                if (result.damage > 0) {
                    targetSprite.classList.add('anim-hit');
                    if (result.isCrit) AudioEngine.playSfx('crit'); else if(result.eff > 1) AudioEngine.playSfx('super_effective'); else if(result.eff < 1) AudioEngine.playSfx('not_very_effective'); else AudioEngine.playSfx('damage');
                    setTimeout(() => targetSprite.classList.remove('anim-hit'), 400);
                    defender.currentHp -= result.damage; this.updateHUD(defender, isPlayer ? 'enemy' : 'player');
                    
                    if (!isPlayer && defender.currentHp / defender.maxHp < 0.33 && defender.currentHp > 0) {
                        if (Math.random() < 0.25) {
                            defender.rageLevel = Math.min(3, (defender.rageLevel || 0) + 1);
                            Battle.updateHUD(defender, 'enemy');
                            this.triggerRageAnim();
                            this.typeText("Enemy is getting\nANGRY!");
                        }
                    }
                }

                const continueTurn = () => {
                     if (remainingAttacks === 0 && defender.currentHp > 0 && !isPlayer) {
                        const hpBonus = (attacker.currentHp / attacker.maxHp < 0.33) ? 0.10 : 0.0;
                        const roll = Math.random();
                        const rl = attacker.rageLevel || 0;
                        if (rl === 3) { 
                            if (roll < (0.30 + hpBonus)) remainingAttacks = 2; 
                            else if (roll < (0.80 + hpBonus)) remainingAttacks = 1; 
                        } 
                        else if (rl === 2) { 
                            if (roll < (0.20 + hpBonus)) remainingAttacks = 2; 
                            else if (roll < (0.60 + hpBonus)) remainingAttacks = 1; 
                        } 
                        else if (rl === 1) { 
                            if (roll < (0.40 + hpBonus)) remainingAttacks = 1; 
                        }
                    }

                    const handleChain = () => {
                        if (defender.currentHp <= 0) { checkDeath(); return; }
                        if (remainingAttacks > 0) {
                            let msg = remainingAttacks === 2 ? "ULTRA RAGE!" : "RAGE CONTINUES!";
                            this.typeText(`${attacker.name} is\n${msg}`, () => { 
                                setTimeout(() => {
                                    this.processMove(attacker, defender, move, isPlayer, next, remainingAttacks - 1, true); 
                                }, 800);
                            });
                        } else { checkDeath(); }
                    };

                    const checkDeath = () => {
                        if (defender.currentHp <= 0) {
                            defender.currentHp = 0; 
                            if(!isPlayer) targetSprite.classList.add('anim-faint'); else targetSprite.style.opacity = 0; 
                            AudioEngine.playCry(defender.cry); this.typeText(`${defender.name}\nfainted!`, () => { if(isPlayer) Game.handleWin(false); else Game.handleLoss(); });
                        } else { next(); }
                    };

                    const stepEffect = () => { if (result.desc) this.typeText(result.desc, handleChain); else handleChain(); };
                    if (result.isCrit) this.typeText("A critical\nhit!", stepEffect); else stepEffect();
                };
                
                const dropRate = defender.isBoss ? 0.15 : 0.10; 
                if (isPlayer && result.damage > 0 && Math.random() < dropRate) {
                     const itemType = Game.getLoot(defender.isBoss);
                     Game.inventory[itemType]++; 
                     AudioEngine.playSfx('funfair'); 
                     this.typeText(`Oh! The ${defender.name}\ndropped a ${ITEMS[itemType].name}!`, () => { setTimeout(continueTurn, 1500); }); 
                } else { continueTurn(); }
            }, 500);
        });
    },

    performTurn(playerMove) {
        this.uiLocked = true; document.getElementById('move-menu').classList.add('hidden'); Input.setMode('NONE');
        const enemyMove = this.e.moves[Math.floor(Math.random() * this.e.moves.length)]; const playerFirst = this.p.stats.spe >= this.e.stats.spe;
        const turn2 = () => {
            if (this.p.currentHp <= 0 || this.e.currentHp <= 0) return;
            
            if (playerFirst) this.processMove(this.e, this.p, enemyMove, false, () => { this.uiLocked = false; this.uiToMenu(); });
            else this.processMove(this.p, this.e, playerMove, true, () => { this.uiLocked = false; this.uiToMenu(); });
        };
        if (playerFirst) this.processMove(this.p, this.e, playerMove, true, turn2); else this.processMove(this.e, this.p, enemyMove, false, turn2);
    }
};

Input.setMode('START');
</script>
</body>
</html>